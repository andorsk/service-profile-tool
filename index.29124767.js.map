{"mappings":"IkKsOI,EOnOA,E5BsHA2vD,EqBtGA,E,I,EGhBJ,EACA,ECHA,EAiCA,E,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,O,c,C,E,a,C,M,C,C,G,E,e,C,E,e,C,E,O,C,E,I,C,E,G,C,E,S,C,E,G,C,E,C,C,E,U,C,K,E,I,E,E,S,E,E,S,E,E,S,E,E,SpK5BA,IAAM,EAAoB,CAAC,cAAc,CAEnC,EAAiB,wCAEvB,OAAM,UAAY,EAAlB,OAAA,CACE,kBAAA,CACE,KAAK,CAAC,mBACN,EAAA,OAAA,CAAmB,OAAO,CAAC,AAAC,GAAM,IAAI,CAAC,aAAa,CAAC,IACjD,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,UAAU,CAAC,EAA7C,OAAA,CACF,CAEA,uBAAA,CAEE,GADA,KAAK,CAAC,wBACF,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAE,OACrB,IAAM,EAAa,IAAI,CAAC,IAAI,CAAC,KAAK,CAC9B,IAAI,CAAC,eAAe,CAAC,EAAkB,GACvC,EACJ,IAAI,CAAC,aAAa,CAAC,EAAY,EAAgB,CAAA,GAC/C,IAAI,CAAC,IAAI,CAAC,gCAAgC,CAAG,CAC/C,CAEA,aAAA,CACE,OAAQ,IAAI,CAAC,IAAI,CAAC,WAAW,CAC3B,KAAK,CAAC,eAAkB,CAAA,IAAI,CAAC,SAAS,CAAC,GAAkB,EAAiB,KAAA,CAAA,CAC9E,CACD,CAED,EAAO,OAAO,CAAG,EAAU,EAC3B,OAAO,cAAc,CAAC,EAAS,aAAc,CAAC,MAAO,CAAA,CAAI,GAEzD,EAAA,OAAA,CAAe,E,I,E,E,SA0BP,OAAA,cAAA,CAAA,EAAA,aAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,UAAA,AAAU,CAAA,G,I,E,E,SAIV,OAAA,cA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ACHvmC,EAAAA,EAAUyK,EAAM87B,EAAM56B,GAAUA,GACZ,WAAjBkqB,EAAO0Q,IACVvmC,CAAAA,EAAAA,EAAyBumC,EAAM56B,EADhC,EAIA26B,IAASC,C,E,E,e,CAGjB,SAAgCpqC,CAAhC,CAA4CwP,CAA5C,EACQxP,OAAAA,GAAOA,EAAI+iB,QAAJ,GAAesE,OAAf,CAAwB,AAAC7X,GAAYA,EAAQm2B,GAArB,CAAiD9H,EAAaP,MAAtF,CAAmDM,EAAaN,MAAxC,CAAuEqF,E,E,E,iB,C,E,O,c,C,E,a,C,M,C,C,E,E,E,O,C,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,SM/hB9G,IAAM,EAAmC,CACvC,EAAA,OAAA,CACA,EAAA,OAAA,CACA,AAAA,CAAA,EAAA,EAAA,OAAA,AAAA,IACA,EAAA,OAAA,CACA,EAAA,kBAAA,CACA,EAAA,iBAAA,CACD,AAED,CAAA,EAAA,OAAA,CAAA,OAAA,CAAe,C,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,G,I,E,E,S,E,E,SEZf,IAAM,EAAmB,CACvB,UACA,MACA,QACA,cACA,CAAC,QAAS,UAAU,EACpB,cACA,EAAA,OAAA,CACA,EAAA,OAAA,CACD,AAED,CAAA,EAAA,OAAA,CAAA,OAAA,CAAe,C,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,GENf,EAAA,OAAA,CAAA,OAAA,CAPmC,CACjC,QAAS,KACT,OACE,MAAM,AAAI,MAAM,uDAClB,CACD,C,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,O,C,E,O,C,W,C,K,E,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,SEgDD,SAAgB,EAAY,CAAe,CAAE,CAAc,EACzD,GAAM,CAAA,IAAC,CAAG,CAAC,CAAG,EACd,OAAO,EAAI,QAAQ,CACf,EAAI,UAAU,CAAC,WAAY,CAAC,IAAK,EAAI,QAAQ,AAAA,GAC7C,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,CAAC,CAAA,EAAG,EAAI,UAAU,CAAC,UAAW,CAAC,IAAK,CAA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","sources":["<anon>","node_modules/ajv/dist/ajv.js","node_modules/ajv/lib/ajv.ts","node_modules/ajv/dist/core.js","node_modules/ajv/lib/core.ts","node_modules/ajv/dist/compile/validate/index.js","node_modules/ajv/lib/compile/validate/index.ts","node_modules/ajv/dist/compile/validate/boolSchema.js","node_modules/ajv/lib/compile/validate/boolSchema.ts","node_modules/ajv/dist/compile/errors.js","node_modules/ajv/lib/compile/errors.ts","node_modules/ajv/dist/compile/codegen/index.js","node_modules/ajv/lib/compile/codegen/index.ts","node_modules/ajv/dist/compile/codegen/code.js","node_modules/ajv/lib/compile/codegen/code.ts","node_modules/ajv/dist/compile/codegen/scope.js","node_modules/ajv/lib/compile/codegen/scope.ts","node_modules/ajv/dist/compile/util.js","node_modules/ajv/lib/compile/util.ts","node_modules/ajv/dist/compile/names.js","node_modules/ajv/lib/compile/names.ts","node_modules/ajv/dist/compile/validate/dataType.js","node_modules/ajv/lib/compile/validate/dataType.ts","node_modules/ajv/dist/compile/rules.js","node_modules/ajv/lib/compile/rules.ts","node_modules/ajv/dist/compile/validate/applicability.js","node_modules/ajv/lib/compile/validate/applicability.ts","node_modules/ajv/dist/compile/validate/defaults.js","node_modules/ajv/lib/compile/validate/defaults.ts","node_modules/ajv/dist/compile/validate/keyword.js","node_modules/ajv/lib/compile/validate/keyword.ts","node_modules/ajv/dist/vocabularies/code.js","node_modules/ajv/lib/vocabularies/code.ts","node_modules/ajv/dist/compile/validate/subschema.js","node_modules/ajv/lib/compile/validate/subschema.ts","node_modules/ajv/dist/compile/resolve.js","node_modules/ajv/lib/compile/resolve.ts","node_modules/fast-deep-equal/index.js","node_modules/json-schema-traverse/index.js","node_modules/ajv/dist/runtime/validation_error.js","node_modules/ajv/lib/runtime/validation_error.ts","node_modules/ajv/dist/compile/ref_error.js","node_modules/ajv/lib/compile/ref_error.ts","node_modules/ajv/dist/compile/index.js","node_modules/ajv/lib/compile/index.ts","node_modules/ajv/dist/refs/data.json","node_modules/ajv/dist/runtime/uri.js","node_modules/ajv/lib/runtime/uri.ts","node_modules/uri-js/dist/es5/uri.all.js","node_modules/uri-js/src/index.ts","node_modules/uri-js/src/schemes/urn-uuid.ts","node_modules/uri-js/src/schemes/urn.ts","node_modules/uri-js/src/schemes/mailto.ts","node_modules/uri-js/src/schemes/wss.ts","node_modules/uri-js/src/schemes/ws.ts","node_modules/uri-js/src/schemes/https.ts","node_modules/uri-js/src/schemes/http.ts","node_modules/uri-js/src/uri.ts","node_modules/uri-js/node_modules/punycode/punycode.es6.js","node_modules/uri-js/src/regexps-iri.ts","node_modules/uri-js/src/regexps-uri.ts","node_modules/uri-js/src/util.ts","node_modules/ajv/dist/vocabularies/draft7.js","node_modules/ajv/lib/vocabularies/draft7.ts","node_modules/ajv/dist/vocabularies/core/index.js","node_modules/ajv/lib/vocabularies/core/index.ts","node_modules/ajv/dist/vocabularies/core/id.js","node_modules/ajv/lib/vocabularies/core/id.ts","node_modules/ajv/dist/vocabularies/core/ref.js","node_modules/ajv/lib/vocabularies/core/ref.ts","node_modules/ajv/dist/vocabularies/validation/index.js","node_modules/ajv/lib/vocabularies/validation/index.ts","node_modules/ajv/dist/vocabularies/validation/limitNumber.js","node_modules/ajv/lib/vocabularies/validation/limitNumber.ts","node_modules/ajv/dist/vocabularies/validation/multipleOf.js","node_modules/ajv/lib/vocabularies/validation/multipleOf.ts","node_modules/ajv/dist/vocabularies/validation/limitLength.js","node_modules/ajv/lib/vocabularies/validation/limitLength.ts","node_modules/ajv/dist/runtime/ucs2length.js","node_modules/ajv/lib/runtime/ucs2length.ts","node_modules/ajv/dist/vocabularies/validation/pattern.js","node_modules/ajv/lib/vocabularies/validation/pattern.ts","node_modules/ajv/dist/vocabularies/validation/limitProperties.js","node_modules/ajv/lib/vocabularies/validation/limitProperties.ts","node_modules/ajv/dist/vocabularies/validation/required.js","node_modules/ajv/lib/vocabularies/validation/required.ts","node_modules/ajv/dist/vocabularies/validation/limitItems.js","node_modules/ajv/lib/vocabularies/validation/limitItems.ts","node_modules/ajv/dist/vocabularies/validation/uniqueItems.js","node_modules/ajv/lib/vocabularies/validation/uniqueItems.ts","node_modules/ajv/dist/runtime/equal.js","node_modules/ajv/lib/runtime/equal.ts","node_modules/ajv/dist/vocabularies/validation/const.js","node_modules/ajv/lib/vocabularies/validation/const.ts","node_modules/ajv/dist/vocabularies/validation/enum.js","node_modules/ajv/lib/vocabularies/validation/enum.ts","node_modules/ajv/dist/vocabularies/applicator/index.js","node_modules/ajv/lib/vocabularies/applicator/index.ts","node_modules/ajv/dist/vocabularies/applicator/additionalItems.js","node_modules/ajv/lib/vocabularies/applicator/additionalItems.ts","node_modules/ajv/dist/vocabularies/applicator/prefixItems.js","node_modules/ajv/lib/vocabularies/applicator/prefixItems.ts","node_modules/ajv/dist/vocabularies/applicator/items.js","node_modules/ajv/lib/vocabularies/applicator/items.ts","node_modules/ajv/dist/vocabularies/applicator/items2020.js","node_modules/ajv/lib/vocabularies/applicator/items2020.ts","node_modules/ajv/dist/vocabularies/applicator/contains.js","node_modules/ajv/lib/vocabularies/applicator/contains.ts","node_modules/ajv/dist/vocabularies/applicator/dependencies.js","node_modules/ajv/lib/vocabularies/applicator/dependencies.ts","node_modules/ajv/dist/vocabularies/applicator/propertyNames.js","node_modules/ajv/lib/vocabularies/applicator/propertyNames.ts","node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js","node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts","node_modules/ajv/dist/vocabularies/applicator/properties.js","node_modules/ajv/lib/vocabularies/applicator/properties.ts","node_modules/ajv/dist/vocabularies/applicator/patternProperties.js","node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts","node_modules/ajv/dist/vocabularies/applicator/not.js","node_modules/ajv/lib/vocabularies/applicator/not.ts","node_modules/ajv/dist/vocabularies/applicator/anyOf.js","node_modules/ajv/lib/vocabularies/applicator/anyOf.ts","node_modules/ajv/dist/vocabularies/applicator/oneOf.js","node_modules/ajv/lib/vocabularies/applicator/oneOf.ts","node_modules/ajv/dist/vocabularies/applicator/allOf.js","node_modules/ajv/lib/vocabularies/applicator/allOf.ts","node_modules/ajv/dist/vocabularies/applicator/if.js","node_modules/ajv/lib/vocabularies/applicator/if.ts","node_modules/ajv/dist/vocabularies/applicator/thenElse.js","node_modules/ajv/lib/vocabularies/applicator/thenElse.ts","node_modules/ajv/dist/vocabularies/format/index.js","node_modules/ajv/lib/vocabularies/format/index.ts","node_modules/ajv/dist/vocabularies/format/format.js","node_modules/ajv/lib/vocabularies/format/format.ts","node_modules/ajv/dist/vocabularies/metadata.js","node_modules/ajv/lib/vocabularies/metadata.ts","node_modules/ajv/dist/vocabularies/discriminator/index.js","node_modules/ajv/lib/vocabularies/discriminator/index.ts","node_modules/ajv/dist/vocabularies/discriminator/types.js","node_modules/ajv/lib/vocabularies/discriminator/types.ts","node_modules/ajv/dist/refs/json-schema-draft-07.json","src/bin/service/views/index.ts","src/lib/validator.ts","src/schemas/profile.ts","src/lib/did.ts","src/schemas/serviceEndpoint.ts","src/bin/service/util.ts","src/lib/crypto.ts","node_modules/@noble/hashes/sha512.js","node_modules/@noble/hashes/src/sha512.ts","node_modules/@noble/hashes/_sha2.js","node_modules/@noble/hashes/src/_sha2.ts","node_modules/@noble/hashes/_assert.js","node_modules/@noble/hashes/src/_assert.ts","node_modules/@noble/hashes/utils.js","node_modules/@noble/hashes/src/utils.ts","node_modules/@noble/hashes/crypto.js","node_modules/@noble/hashes/src/crypto.ts","node_modules/@noble/hashes/_u64.js","node_modules/@noble/hashes/src/_u64.ts","node_modules/@noble/hashes/sha256.js","node_modules/@noble/hashes/src/sha256.ts","node_modules/@noble/ed25519/index.js","src/lib/proof.ts","node_modules/buffer/index.js","node_modules/base64-js/index.js","node_modules/ieee754/index.js","node_modules/uuid/dist/esm-browser/v4.js","node_modules/uuid/dist/esm-browser/native.js","node_modules/uuid/dist/esm-browser/rng.js","node_modules/uuid/dist/esm-browser/stringify.js","node_modules/uuid/dist/esm-browser/validate.js","node_modules/uuid/dist/esm-browser/regex.js"],"sourcesContent":["\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequirea83f\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequirea83f\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"ilwRK\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\n\nvar $5hxSG = parcelRequire(\"5hxSG\");\n\nvar $hHp9H = parcelRequire(\"hHp9H\");\n\nvar $81ULr = parcelRequire(\"81ULr\");\n\nvar $BbyF4 = parcelRequire(\"BbyF4\");\nconst META_SUPPORT_DATA = [\n    \"/properties\"\n];\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\";\nclass Ajv extends $5hxSG.default {\n    _addVocabularies() {\n        super._addVocabularies();\n        $hHp9H.default.forEach((v)=>this.addVocabulary(v));\n        if (this.opts.discriminator) this.addKeyword($81ULr.default);\n    }\n    _addDefaultMetaSchema() {\n        super._addDefaultMetaSchema();\n        if (!this.opts.meta) return;\n        const metaSchema = this.opts.$data ? this.$dataMetaSchema($BbyF4, META_SUPPORT_DATA) : $BbyF4;\n        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);\n        this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID;\n    }\n    defaultMeta() {\n        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined);\n    }\n}\nmodule.exports = exports = Ajv;\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = Ajv;\n\nvar $9hgV1 = parcelRequire(\"9hgV1\");\nObject.defineProperty(exports, \"KeywordCxt\", {\n    enumerable: true,\n    get: function() {\n        return $9hgV1.KeywordCxt;\n    }\n});\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\nObject.defineProperty(exports, \"_\", {\n    enumerable: true,\n    get: function() {\n        return $l2ufW._;\n    }\n});\nObject.defineProperty(exports, \"str\", {\n    enumerable: true,\n    get: function() {\n        return $l2ufW.str;\n    }\n});\nObject.defineProperty(exports, \"stringify\", {\n    enumerable: true,\n    get: function() {\n        return $l2ufW.stringify;\n    }\n});\nObject.defineProperty(exports, \"nil\", {\n    enumerable: true,\n    get: function() {\n        return $l2ufW.nil;\n    }\n});\nObject.defineProperty(exports, \"Name\", {\n    enumerable: true,\n    get: function() {\n        return $l2ufW.Name;\n    }\n});\nObject.defineProperty(exports, \"CodeGen\", {\n    enumerable: true,\n    get: function() {\n        return $l2ufW.CodeGen;\n    }\n});\n\nvar $2gvZO = parcelRequire(\"2gvZO\");\nObject.defineProperty(exports, \"ValidationError\", {\n    enumerable: true,\n    get: function() {\n        return $2gvZO.default;\n    }\n});\n\nvar $euTEo = parcelRequire(\"euTEo\");\nObject.defineProperty(exports, \"MissingRefError\", {\n    enumerable: true,\n    get: function() {\n        return $euTEo.default;\n    }\n});\n\n});\nparcelRegister(\"5hxSG\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.CodeGen = module.exports.Name = module.exports.nil = module.exports.stringify = module.exports.str = module.exports._ = module.exports.KeywordCxt = void 0;\n\nvar $9hgV1 = parcelRequire(\"9hgV1\");\nObject.defineProperty(module.exports, \"KeywordCxt\", {\n    enumerable: true,\n    get: function() {\n        return $9hgV1.KeywordCxt;\n    }\n});\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\nObject.defineProperty(module.exports, \"_\", {\n    enumerable: true,\n    get: function() {\n        return $l2ufW._;\n    }\n});\nObject.defineProperty(module.exports, \"str\", {\n    enumerable: true,\n    get: function() {\n        return $l2ufW.str;\n    }\n});\nObject.defineProperty(module.exports, \"stringify\", {\n    enumerable: true,\n    get: function() {\n        return $l2ufW.stringify;\n    }\n});\nObject.defineProperty(module.exports, \"nil\", {\n    enumerable: true,\n    get: function() {\n        return $l2ufW.nil;\n    }\n});\nObject.defineProperty(module.exports, \"Name\", {\n    enumerable: true,\n    get: function() {\n        return $l2ufW.Name;\n    }\n});\nObject.defineProperty(module.exports, \"CodeGen\", {\n    enumerable: true,\n    get: function() {\n        return $l2ufW.CodeGen;\n    }\n});\n\nvar $2gvZO = parcelRequire(\"2gvZO\");\n\nvar $euTEo = parcelRequire(\"euTEo\");\n\nvar $1sl6b = parcelRequire(\"1sl6b\");\n\nvar $jstQR = parcelRequire(\"jstQR\");\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $9ZpNV = parcelRequire(\"9ZpNV\");\n\nvar $46MS3 = parcelRequire(\"46MS3\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\n\nvar $83wzf = parcelRequire(\"83wzf\");\n\nvar $FaKkF = parcelRequire(\"FaKkF\");\nconst $3d88d258a9865bba$var$defaultRegExp = (str, flags)=>new RegExp(str, flags);\n$3d88d258a9865bba$var$defaultRegExp.code = \"new RegExp\";\nconst $3d88d258a9865bba$var$META_IGNORE_OPTIONS = [\n    \"removeAdditional\",\n    \"useDefaults\",\n    \"coerceTypes\"\n];\nconst $3d88d258a9865bba$var$EXT_SCOPE_NAMES = new Set([\n    \"validate\",\n    \"serialize\",\n    \"parse\",\n    \"wrapper\",\n    \"root\",\n    \"schema\",\n    \"keyword\",\n    \"pattern\",\n    \"formats\",\n    \"validate$data\",\n    \"func\",\n    \"obj\",\n    \"Error\"\n]);\nconst $3d88d258a9865bba$var$removedOptions = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\"\n};\nconst $3d88d258a9865bba$var$deprecatedOptions = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.'\n};\nconst $3d88d258a9865bba$var$MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction $3d88d258a9865bba$var$requiredOptions(o) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n    const s = o.strict;\n    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : $3d88d258a9865bba$var$defaultRegExp;\n    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : $FaKkF.default;\n    return {\n        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n        code: o.code ? {\n            ...o.code,\n            optimize: optimize,\n            regExp: regExp\n        } : {\n            optimize: optimize,\n            regExp: regExp\n        },\n        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : $3d88d258a9865bba$var$MAX_EXPRESSION,\n        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : $3d88d258a9865bba$var$MAX_EXPRESSION,\n        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n        uriResolver: uriResolver\n    };\n}\nclass $3d88d258a9865bba$var$Ajv {\n    constructor(opts = {}){\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = new Set();\n        this._loading = {};\n        this._cache = new Map();\n        opts = this.opts = {\n            ...opts,\n            ...$3d88d258a9865bba$var$requiredOptions(opts)\n        };\n        const { es5: es5, lines: lines } = this.opts.code;\n        this.scope = new $l2ufW.ValueScope({\n            scope: {},\n            prefixes: $3d88d258a9865bba$var$EXT_SCOPE_NAMES,\n            es5: es5,\n            lines: lines\n        });\n        this.logger = $3d88d258a9865bba$var$getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, $1sl6b.getRules)();\n        $3d88d258a9865bba$var$checkOptions.call(this, $3d88d258a9865bba$var$removedOptions, opts, \"NOT SUPPORTED\");\n        $3d88d258a9865bba$var$checkOptions.call(this, $3d88d258a9865bba$var$deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = $3d88d258a9865bba$var$getMetaSchemaOptions.call(this);\n        if (opts.formats) $3d88d258a9865bba$var$addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords) $3d88d258a9865bba$var$addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta);\n        $3d88d258a9865bba$var$addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n    }\n    _addVocabularies() {\n        this.addKeyword(\"$async\");\n    }\n    _addDefaultMetaSchema() {\n        const { $data: $data, meta: meta, schemaId: schemaId } = this.opts;\n        let _dataRefSchema = $83wzf;\n        if (schemaId === \"id\") {\n            _dataRefSchema = {\n                ...$83wzf\n            };\n            _dataRefSchema.id = _dataRefSchema.$id;\n            delete _dataRefSchema.$id;\n        }\n        if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n    defaultMeta() {\n        const { meta: meta, schemaId: schemaId } = this.opts;\n        return this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined;\n    }\n    validate(schemaKeyRef, data // to be validated\n    ) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n            v = this.getSchema(schemaKeyRef);\n            if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        } else v = this.compile(schemaKeyRef);\n        const valid = v(data);\n        if (!(\"$async\" in v)) this.errors = v.errors;\n        return valid;\n    }\n    compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return sch.validate || this._compileSchemaEnv(sch);\n    }\n    compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") throw new Error(\"options.loadSchema should be a function\");\n        const { loadSchema: loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n            await loadMetaSchema.call(this, _schema.$schema);\n            const sch = this._addSchema(_schema, _meta);\n            return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n            if ($ref && !this.getSchema($ref)) await runCompileAsync.call(this, {\n                $ref: $ref\n            }, true);\n        }\n        async function _compileAsync(sch) {\n            try {\n                return this._compileSchemaEnv(sch);\n            } catch (e) {\n                if (!(e instanceof $euTEo.default)) throw e;\n                checkLoaded.call(this, e);\n                await loadMissingSchema.call(this, e.missingSchema);\n                return _compileAsync.call(this, sch);\n            }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef: missingRef }) {\n            if (this.refs[ref]) throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n        }\n        async function loadMissingSchema(ref) {\n            const _schema = await _loadSchema.call(this, ref);\n            if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema);\n            if (!this.refs[ref]) this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n            const p = this._loading[ref];\n            if (p) return p;\n            try {\n                return await (this._loading[ref] = loadSchema(ref));\n            } finally{\n                delete this._loading[ref];\n            }\n        }\n    }\n    // Adds schema to the instance\n    addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    ) {\n        if (Array.isArray(schema)) {\n            for (const sch of schema)this.addSchema(sch, undefined, _meta, _validateSchema);\n            return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n            const { schemaId: schemaId } = this.opts;\n            id = schema[schemaId];\n            if (id !== undefined && typeof id != \"string\") throw new Error(`schema ${schemaId} must be string`);\n        }\n        key = (0, $9ZpNV.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n    addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    ) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n    }\n    //  Validate schema against its meta-schema\n    validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\") return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== undefined && typeof $schema != \"string\") throw new Error(\"$schema must be a string\");\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n            this.logger.warn(\"meta-schema not available\");\n            this.errors = null;\n            return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n            const message = \"schema is invalid: \" + this.errorsText();\n            if (this.opts.validateSchema === \"log\") this.logger.error(message);\n            else throw new Error(message);\n        }\n        return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n    getSchema(keyRef) {\n        let sch;\n        while(typeof (sch = $3d88d258a9865bba$var$getSchEnv.call(this, keyRef)) == \"string\")keyRef = sch;\n        if (sch === undefined) {\n            const { schemaId: schemaId } = this.opts;\n            const root = new $jstQR.SchemaEnv({\n                schema: {},\n                schemaId: schemaId\n            });\n            sch = $jstQR.resolveSchema.call(this, root, keyRef);\n            if (!sch) return;\n            this.refs[keyRef] = sch;\n        }\n        return sch.validate || this._compileSchemaEnv(sch);\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n            this._removeAllSchemas(this.schemas, schemaKeyRef);\n            this._removeAllSchemas(this.refs, schemaKeyRef);\n            return this;\n        }\n        switch(typeof schemaKeyRef){\n            case \"undefined\":\n                this._removeAllSchemas(this.schemas);\n                this._removeAllSchemas(this.refs);\n                this._cache.clear();\n                return this;\n            case \"string\":\n                {\n                    const sch = $3d88d258a9865bba$var$getSchEnv.call(this, schemaKeyRef);\n                    if (typeof sch == \"object\") this._cache.delete(sch.schema);\n                    delete this.schemas[schemaKeyRef];\n                    delete this.refs[schemaKeyRef];\n                    return this;\n                }\n            case \"object\":\n                {\n                    const cacheKey = schemaKeyRef;\n                    this._cache.delete(cacheKey);\n                    let id = schemaKeyRef[this.opts.schemaId];\n                    if (id) {\n                        id = (0, $9ZpNV.normalizeId)(id);\n                        delete this.schemas[id];\n                        delete this.refs[id];\n                    }\n                    return this;\n                }\n            default:\n                throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n    }\n    // add \"vocabulary\" - a collection of keywords\n    addVocabulary(definitions) {\n        for (const def of definitions)this.addKeyword(def);\n        return this;\n    }\n    addKeyword(kwdOrDef, def // deprecated\n    ) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n            keyword = kwdOrDef;\n            if (typeof def == \"object\") {\n                this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n                def.keyword = keyword;\n            }\n        } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n            def = kwdOrDef;\n            keyword = def.keyword;\n            if (Array.isArray(keyword) && !keyword.length) throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n        } else throw new Error(\"invalid addKeywords parameters\");\n        $3d88d258a9865bba$var$checkKeyword.call(this, keyword, def);\n        if (!def) {\n            (0, $7eX5i.eachItem)(keyword, (kwd)=>$3d88d258a9865bba$var$addRule.call(this, kwd));\n            return this;\n        }\n        $3d88d258a9865bba$var$keywordMetaschema.call(this, def);\n        const definition = {\n            ...def,\n            type: (0, $46MS3.getJSONTypes)(def.type),\n            schemaType: (0, $46MS3.getJSONTypes)(def.schemaType)\n        };\n        (0, $7eX5i.eachItem)(keyword, definition.type.length === 0 ? (k)=>$3d88d258a9865bba$var$addRule.call(this, k, definition) : (k)=>definition.type.forEach((t)=>$3d88d258a9865bba$var$addRule.call(this, k, definition, t)));\n        return this;\n    }\n    getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n    removeKeyword(keyword) {\n        // TODO return type should be Ajv\n        const { RULES: RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules){\n            const i = group.rules.findIndex((rule)=>rule.keyword === keyword);\n            if (i >= 0) group.rules.splice(i, 1);\n        }\n        return this;\n    }\n    // Add format\n    addFormat(name, format) {\n        if (typeof format == \"string\") format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n    }\n    errorsText(errors = this.errors, { separator: separator = \", \", dataVar: dataVar = \"data\" } = {} // optional options with properties `separator` and `dataVar`\n    ) {\n        if (!errors || errors.length === 0) return \"No errors\";\n        return errors.map((e)=>`${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg)=>text + separator + msg);\n    }\n    $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers){\n            const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n            let keywords = metaSchema;\n            for (const seg of segments)keywords = keywords[seg];\n            for(const key in rules){\n                const rule = rules[key];\n                if (typeof rule != \"object\") continue;\n                const { $data: $data } = rule.definition;\n                const schema = keywords[key];\n                if ($data && schema) keywords[key] = $3d88d258a9865bba$var$schemaOrData(schema);\n            }\n        }\n        return metaSchema;\n    }\n    _removeAllSchemas(schemas, regex) {\n        for(const keyRef in schemas){\n            const sch = schemas[keyRef];\n            if (!regex || regex.test(keyRef)) {\n                if (typeof sch == \"string\") delete schemas[keyRef];\n                else if (sch && !sch.meta) {\n                    this._cache.delete(sch.schema);\n                    delete schemas[keyRef];\n                }\n            }\n        }\n    }\n    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId: schemaId } = this.opts;\n        if (typeof schema == \"object\") id = schema[schemaId];\n        else {\n            if (this.opts.jtd) throw new Error(\"schema must be object\");\n            else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== undefined) return sch;\n        baseId = (0, $9ZpNV.normalizeId)(id || baseId);\n        const localRefs = $9ZpNV.getSchemaRefs.call(this, schema, baseId);\n        sch = new $jstQR.SchemaEnv({\n            schema: schema,\n            schemaId: schemaId,\n            meta: meta,\n            baseId: baseId,\n            localRefs: localRefs\n        });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n            if (baseId) this._checkUnique(baseId);\n            this.refs[baseId] = sch;\n        }\n        if (validateSchema) this.validateSchema(schema, true);\n        return sch;\n    }\n    _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) throw new Error(`schema with key or id \"${id}\" already exists`);\n    }\n    _compileSchemaEnv(sch) {\n        if (sch.meta) this._compileMetaSchema(sch);\n        else $jstQR.compileSchema.call(this, sch);\n        /* istanbul ignore if */ if (!sch.validate) throw new Error(\"ajv implementation error\");\n        return sch.validate;\n    }\n    _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n            $jstQR.compileSchema.call(this, sch);\n        } finally{\n            this.opts = currentOpts;\n        }\n    }\n}\nmodule.exports.default = $3d88d258a9865bba$var$Ajv;\n$3d88d258a9865bba$var$Ajv.ValidationError = $2gvZO.default;\n$3d88d258a9865bba$var$Ajv.MissingRefError = $euTEo.default;\nfunction $3d88d258a9865bba$var$checkOptions(checkOpts, options, msg, log = \"error\") {\n    for(const key in checkOpts){\n        const opt = key;\n        if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n    }\n}\nfunction $3d88d258a9865bba$var$getSchEnv(keyRef) {\n    keyRef = (0, $9ZpNV.normalizeId)(keyRef); // TODO tests fail without this line\n    return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction $3d88d258a9865bba$var$addInitialSchemas() {\n    const optsSchemas = this.opts.schemas;\n    if (!optsSchemas) return;\n    if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);\n    else for(const key in optsSchemas)this.addSchema(optsSchemas[key], key);\n}\nfunction $3d88d258a9865bba$var$addInitialFormats() {\n    for(const name in this.opts.formats){\n        const format = this.opts.formats[name];\n        if (format) this.addFormat(name, format);\n    }\n}\nfunction $3d88d258a9865bba$var$addInitialKeywords(defs) {\n    if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n    }\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for(const keyword in defs){\n        const def = defs[keyword];\n        if (!def.keyword) def.keyword = keyword;\n        this.addKeyword(def);\n    }\n}\nfunction $3d88d258a9865bba$var$getMetaSchemaOptions() {\n    const metaOpts = {\n        ...this.opts\n    };\n    for (const opt of $3d88d258a9865bba$var$META_IGNORE_OPTIONS)delete metaOpts[opt];\n    return metaOpts;\n}\nconst $3d88d258a9865bba$var$noLogs = {\n    log () {},\n    warn () {},\n    error () {}\n};\nfunction $3d88d258a9865bba$var$getLogger(logger) {\n    if (logger === false) return $3d88d258a9865bba$var$noLogs;\n    if (logger === undefined) return console;\n    if (logger.log && logger.warn && logger.error) return logger;\n    throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst $3d88d258a9865bba$var$KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction $3d88d258a9865bba$var$checkKeyword(keyword, def) {\n    const { RULES: RULES } = this;\n    (0, $7eX5i.eachItem)(keyword, (kwd)=>{\n        if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);\n        if (!$3d88d258a9865bba$var$KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);\n    });\n    if (!def) return;\n    if (def.$data && !(\"code\" in def || \"validate\" in def)) throw new Error('$data keyword must have \"code\" or \"validate\" function');\n}\nfunction $3d88d258a9865bba$var$addRule(keyword, definition, dataType) {\n    var _a;\n    const post = definition === null || definition === void 0 ? void 0 : definition.post;\n    if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"');\n    const { RULES: RULES } = this;\n    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t })=>t === dataType);\n    if (!ruleGroup) {\n        ruleGroup = {\n            type: dataType,\n            rules: []\n        };\n        RULES.rules.push(ruleGroup);\n    }\n    RULES.keywords[keyword] = true;\n    if (!definition) return;\n    const rule = {\n        keyword: keyword,\n        definition: {\n            ...definition,\n            type: (0, $46MS3.getJSONTypes)(definition.type),\n            schemaType: (0, $46MS3.getJSONTypes)(definition.schemaType)\n        }\n    };\n    if (definition.before) $3d88d258a9865bba$var$addBeforeRule.call(this, ruleGroup, rule, definition.before);\n    else ruleGroup.rules.push(rule);\n    RULES.all[keyword] = rule;\n    (_a = definition.implements) === null || _a === void 0 || _a.forEach((kwd)=>this.addKeyword(kwd));\n}\nfunction $3d88d258a9865bba$var$addBeforeRule(ruleGroup, rule, before) {\n    const i = ruleGroup.rules.findIndex((_rule)=>_rule.keyword === before);\n    if (i >= 0) ruleGroup.rules.splice(i, 0, rule);\n    else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n    }\n}\nfunction $3d88d258a9865bba$var$keywordMetaschema(def) {\n    let { metaSchema: metaSchema } = def;\n    if (metaSchema === undefined) return;\n    if (def.$data && this.opts.$data) metaSchema = $3d88d258a9865bba$var$schemaOrData(metaSchema);\n    def.validateSchema = this.compile(metaSchema, true);\n}\nconst $3d88d258a9865bba$var$$dataRef = {\n    $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\"\n};\nfunction $3d88d258a9865bba$var$schemaOrData(schema) {\n    return {\n        anyOf: [\n            schema,\n            $3d88d258a9865bba$var$$dataRef\n        ]\n    };\n}\n\n});\nparcelRegister(\"9hgV1\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.getData = module.exports.KeywordCxt = module.exports.validateFunctionCode = void 0;\n\nvar $75Cyv = parcelRequire(\"75Cyv\");\n\nvar $46MS3 = parcelRequire(\"46MS3\");\n\nvar $9KPK3 = parcelRequire(\"9KPK3\");\n\nvar $46MS3 = parcelRequire(\"46MS3\");\n\nvar $9OJAU = parcelRequire(\"9OJAU\");\n\nvar $dTewx = parcelRequire(\"dTewx\");\n\nvar $5eunN = parcelRequire(\"5eunN\");\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $dOpvc = parcelRequire(\"dOpvc\");\n\nvar $9ZpNV = parcelRequire(\"9ZpNV\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\n\nvar $hYgW9 = parcelRequire(\"hYgW9\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction $6c12d34a75202c62$var$validateFunctionCode(it) {\n    if ($6c12d34a75202c62$var$isSchemaObj(it)) {\n        $6c12d34a75202c62$var$checkKeywords(it);\n        if ($6c12d34a75202c62$var$schemaCxtHasRules(it)) {\n            $6c12d34a75202c62$var$topSchemaObjCode(it);\n            return;\n        }\n    }\n    $6c12d34a75202c62$var$validateFunction(it, ()=>(0, $75Cyv.topBoolOrEmptySchema)(it));\n}\nmodule.exports.validateFunctionCode = $6c12d34a75202c62$var$validateFunctionCode;\nfunction $6c12d34a75202c62$var$validateFunction({ gen: gen, validateName: validateName, schema: schema, schemaEnv: schemaEnv, opts: opts }, body) {\n    if (opts.code.es5) gen.func(validateName, (0, $l2ufW._)`${$dOpvc.default.data}, ${$dOpvc.default.valCxt}`, schemaEnv.$async, ()=>{\n        gen.code((0, $l2ufW._)`\"use strict\"; ${$6c12d34a75202c62$var$funcSourceUrl(schema, opts)}`);\n        $6c12d34a75202c62$var$destructureValCxtES5(gen, opts);\n        gen.code(body);\n    });\n    else gen.func(validateName, (0, $l2ufW._)`${$dOpvc.default.data}, ${$6c12d34a75202c62$var$destructureValCxt(opts)}`, schemaEnv.$async, ()=>gen.code($6c12d34a75202c62$var$funcSourceUrl(schema, opts)).code(body));\n}\nfunction $6c12d34a75202c62$var$destructureValCxt(opts) {\n    return (0, $l2ufW._)`{${$dOpvc.default.instancePath}=\"\", ${$dOpvc.default.parentData}, ${$dOpvc.default.parentDataProperty}, ${$dOpvc.default.rootData}=${$dOpvc.default.data}${opts.dynamicRef ? (0, $l2ufW._)`, ${$dOpvc.default.dynamicAnchors}={}` : $l2ufW.nil}}={}`;\n}\nfunction $6c12d34a75202c62$var$destructureValCxtES5(gen, opts) {\n    gen.if($dOpvc.default.valCxt, ()=>{\n        gen.var($dOpvc.default.instancePath, (0, $l2ufW._)`${$dOpvc.default.valCxt}.${$dOpvc.default.instancePath}`);\n        gen.var($dOpvc.default.parentData, (0, $l2ufW._)`${$dOpvc.default.valCxt}.${$dOpvc.default.parentData}`);\n        gen.var($dOpvc.default.parentDataProperty, (0, $l2ufW._)`${$dOpvc.default.valCxt}.${$dOpvc.default.parentDataProperty}`);\n        gen.var($dOpvc.default.rootData, (0, $l2ufW._)`${$dOpvc.default.valCxt}.${$dOpvc.default.rootData}`);\n        if (opts.dynamicRef) gen.var($dOpvc.default.dynamicAnchors, (0, $l2ufW._)`${$dOpvc.default.valCxt}.${$dOpvc.default.dynamicAnchors}`);\n    }, ()=>{\n        gen.var($dOpvc.default.instancePath, (0, $l2ufW._)`\"\"`);\n        gen.var($dOpvc.default.parentData, (0, $l2ufW._)`undefined`);\n        gen.var($dOpvc.default.parentDataProperty, (0, $l2ufW._)`undefined`);\n        gen.var($dOpvc.default.rootData, $dOpvc.default.data);\n        if (opts.dynamicRef) gen.var($dOpvc.default.dynamicAnchors, (0, $l2ufW._)`{}`);\n    });\n}\nfunction $6c12d34a75202c62$var$topSchemaObjCode(it) {\n    const { schema: schema, opts: opts, gen: gen } = it;\n    $6c12d34a75202c62$var$validateFunction(it, ()=>{\n        if (opts.$comment && schema.$comment) $6c12d34a75202c62$var$commentKeyword(it);\n        $6c12d34a75202c62$var$checkNoDefault(it);\n        gen.let($dOpvc.default.vErrors, null);\n        gen.let($dOpvc.default.errors, 0);\n        if (opts.unevaluated) $6c12d34a75202c62$var$resetEvaluated(it);\n        $6c12d34a75202c62$var$typeAndKeywords(it);\n        $6c12d34a75202c62$var$returnResults(it);\n    });\n    return;\n}\nfunction $6c12d34a75202c62$var$resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen: gen, validateName: validateName } = it;\n    it.evaluated = gen.const(\"evaluated\", (0, $l2ufW._)`${validateName}.evaluated`);\n    gen.if((0, $l2ufW._)`${it.evaluated}.dynamicProps`, ()=>gen.assign((0, $l2ufW._)`${it.evaluated}.props`, (0, $l2ufW._)`undefined`));\n    gen.if((0, $l2ufW._)`${it.evaluated}.dynamicItems`, ()=>gen.assign((0, $l2ufW._)`${it.evaluated}.items`, (0, $l2ufW._)`undefined`));\n}\nfunction $6c12d34a75202c62$var$funcSourceUrl(schema, opts) {\n    const schId = typeof schema == \"object\" && schema[opts.schemaId];\n    return schId && (opts.code.source || opts.code.process) ? (0, $l2ufW._)`/*# sourceURL=${schId} */` : $l2ufW.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction $6c12d34a75202c62$var$subschemaCode(it, valid) {\n    if ($6c12d34a75202c62$var$isSchemaObj(it)) {\n        $6c12d34a75202c62$var$checkKeywords(it);\n        if ($6c12d34a75202c62$var$schemaCxtHasRules(it)) {\n            $6c12d34a75202c62$var$subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    (0, $75Cyv.boolOrEmptySchema)(it, valid);\n}\nfunction $6c12d34a75202c62$var$schemaCxtHasRules({ schema: schema, self: self }) {\n    if (typeof schema == \"boolean\") return !schema;\n    for(const key in schema)if (self.RULES.all[key]) return true;\n    return false;\n}\nfunction $6c12d34a75202c62$var$isSchemaObj(it) {\n    return typeof it.schema != \"boolean\";\n}\nfunction $6c12d34a75202c62$var$subSchemaObjCode(it, valid) {\n    const { schema: schema, gen: gen, opts: opts } = it;\n    if (opts.$comment && schema.$comment) $6c12d34a75202c62$var$commentKeyword(it);\n    $6c12d34a75202c62$var$updateContext(it);\n    $6c12d34a75202c62$var$checkAsyncSchema(it);\n    const errsCount = gen.const(\"_errs\", $dOpvc.default.errors);\n    $6c12d34a75202c62$var$typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, (0, $l2ufW._)`${errsCount} === ${$dOpvc.default.errors}`);\n}\nfunction $6c12d34a75202c62$var$checkKeywords(it) {\n    (0, $7eX5i.checkUnknownRules)(it);\n    $6c12d34a75202c62$var$checkRefsAndKeywords(it);\n}\nfunction $6c12d34a75202c62$var$typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd) return $6c12d34a75202c62$var$schemaKeywords(it, [], false, errsCount);\n    const types = (0, $46MS3.getSchemaTypes)(it.schema);\n    const checkedTypes = (0, $46MS3.coerceAndCheckDataType)(it, types);\n    $6c12d34a75202c62$var$schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction $6c12d34a75202c62$var$checkRefsAndKeywords(it) {\n    const { schema: schema, errSchemaPath: errSchemaPath, opts: opts, self: self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, $7eX5i.schemaHasRulesButRef)(schema, self.RULES)) self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n}\nfunction $6c12d34a75202c62$var$checkNoDefault(it) {\n    const { schema: schema, opts: opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) (0, $7eX5i.checkStrictMode)(it, \"default is ignored in the schema root\");\n}\nfunction $6c12d34a75202c62$var$updateContext(it) {\n    const schId = it.schema[it.opts.schemaId];\n    if (schId) it.baseId = (0, $9ZpNV.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction $6c12d34a75202c62$var$checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\");\n}\nfunction $6c12d34a75202c62$var$commentKeyword({ gen: gen, schemaEnv: schemaEnv, schema: schema, errSchemaPath: errSchemaPath, opts: opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) gen.code((0, $l2ufW._)`${$dOpvc.default.self}.logger.log(${msg})`);\n    else if (typeof opts.$comment == \"function\") {\n        const schemaPath = (0, $l2ufW.str)`${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", {\n            ref: schemaEnv.root\n        });\n        gen.code((0, $l2ufW._)`${$dOpvc.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction $6c12d34a75202c62$var$returnResults(it) {\n    const { gen: gen, schemaEnv: schemaEnv, validateName: validateName, ValidationError: ValidationError, opts: opts } = it;\n    if (schemaEnv.$async) // TODO assign unevaluated\n    gen.if((0, $l2ufW._)`${$dOpvc.default.errors} === 0`, ()=>gen.return($dOpvc.default.data), ()=>gen.throw((0, $l2ufW._)`new ${ValidationError}(${$dOpvc.default.vErrors})`));\n    else {\n        gen.assign((0, $l2ufW._)`${validateName}.errors`, $dOpvc.default.vErrors);\n        if (opts.unevaluated) $6c12d34a75202c62$var$assignEvaluated(it);\n        gen.return((0, $l2ufW._)`${$dOpvc.default.errors} === 0`);\n    }\n}\nfunction $6c12d34a75202c62$var$assignEvaluated({ gen: gen, evaluated: evaluated, props: props, items: items }) {\n    if (props instanceof $l2ufW.Name) gen.assign((0, $l2ufW._)`${evaluated}.props`, props);\n    if (items instanceof $l2ufW.Name) gen.assign((0, $l2ufW._)`${evaluated}.items`, items);\n}\nfunction $6c12d34a75202c62$var$schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen: gen, schema: schema, data: data, allErrors: allErrors, opts: opts, self: self } = it;\n    const { RULES: RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, $7eX5i.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(()=>$6c12d34a75202c62$var$keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd) $6c12d34a75202c62$var$checkStrictTypes(it, types);\n    gen.block(()=>{\n        for (const group of RULES.rules)groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!(0, $9KPK3.shouldUseGroup)(schema, group)) return;\n        if (group.type) {\n            gen.if((0, $46MS3.checkDataType)(group.type, data, opts.strictNumbers));\n            $6c12d34a75202c62$var$iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                (0, $46MS3.reportTypeError)(it);\n            }\n            gen.endIf();\n        } else $6c12d34a75202c62$var$iterateKeywords(it, group);\n        // TODO make it \"ok\" call?\n        if (!allErrors) gen.if((0, $l2ufW._)`${$dOpvc.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction $6c12d34a75202c62$var$iterateKeywords(it, group) {\n    const { gen: gen, schema: schema, opts: { useDefaults: useDefaults } } = it;\n    if (useDefaults) (0, $9OJAU.assignDefaults)(it, group.type);\n    gen.block(()=>{\n        for (const rule of group.rules)if ((0, $9KPK3.shouldUseRule)(schema, rule)) $6c12d34a75202c62$var$keywordCode(it, rule.keyword, rule.definition, group.type);\n    });\n}\nfunction $6c12d34a75202c62$var$checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes) return;\n    $6c12d34a75202c62$var$checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes) $6c12d34a75202c62$var$checkMultipleTypes(it, types);\n    $6c12d34a75202c62$var$checkKeywordTypes(it, it.dataTypes);\n}\nfunction $6c12d34a75202c62$var$checkContextTypes(it, types) {\n    if (!types.length) return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t)=>{\n        if (!$6c12d34a75202c62$var$includesType(it.dataTypes, t)) $6c12d34a75202c62$var$strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n    });\n    $6c12d34a75202c62$var$narrowSchemaTypes(it, types);\n}\nfunction $6c12d34a75202c62$var$checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) $6c12d34a75202c62$var$strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n}\nfunction $6c12d34a75202c62$var$checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for(const keyword in rules){\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && (0, $9KPK3.shouldUseRule)(it.schema, rule)) {\n            const { type: type } = rule.definition;\n            if (type.length && !type.some((t)=>$6c12d34a75202c62$var$hasApplicableType(ts, t))) $6c12d34a75202c62$var$strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n        }\n    }\n}\nfunction $6c12d34a75202c62$var$hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || kwdT === \"number\" && schTs.includes(\"integer\");\n}\nfunction $6c12d34a75202c62$var$includesType(ts, t) {\n    return ts.includes(t) || t === \"integer\" && ts.includes(\"number\");\n}\nfunction $6c12d34a75202c62$var$narrowSchemaTypes(it, withTypes) {\n    const ts = [];\n    for (const t of it.dataTypes){\n        if ($6c12d34a75202c62$var$includesType(withTypes, t)) ts.push(t);\n        else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\");\n    }\n    it.dataTypes = ts;\n}\nfunction $6c12d34a75202c62$var$strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at \"${schemaPath}\" (strictTypes)`;\n    (0, $7eX5i.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass $6c12d34a75202c62$var$KeywordCxt {\n    constructor(it, def, keyword){\n        (0, $dTewx.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, $7eX5i.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) this.schemaCode = it.gen.const(\"vSchema\", $6c12d34a75202c62$var$getData(this.$data, it));\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!(0, $dTewx.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) this.errsCount = it.gen.const(\"_errs\", $dOpvc.default.errors);\n    }\n    result(condition, successAction, failAction) {\n        this.failResult((0, $l2ufW.not)(condition), successAction, failAction);\n    }\n    failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction) failAction();\n        else this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors) this.gen.endIf();\n        } else if (this.allErrors) this.gen.endIf();\n        else this.gen.else();\n    }\n    pass(condition, failAction) {\n        this.failResult((0, $l2ufW.not)(condition), undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors) this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors) this.gen.endIf();\n        else this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data) return this.fail(condition);\n        const { schemaCode: schemaCode } = this;\n        this.fail((0, $l2ufW._)`${schemaCode} !== undefined && (${(0, $l2ufW.or)(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        (append ? $hYgW9.reportExtraError : $hYgW9.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        (0, $hYgW9.reportError)(this, this.def.$dataError || $hYgW9.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition');\n        (0, $hYgW9.resetErrorsCount)(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors) this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign) Object.assign(this.params, obj);\n        else this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = $l2ufW.nil) {\n        this.gen.block(()=>{\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = $l2ufW.nil, $dataValid = $l2ufW.nil) {\n        if (!this.$data) return;\n        const { gen: gen, schemaCode: schemaCode, schemaType: schemaType, def: def } = this;\n        gen.if((0, $l2ufW.or)((0, $l2ufW._)`${schemaCode} === undefined`, $dataValid));\n        if (valid !== $l2ufW.nil) gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== $l2ufW.nil) gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen: gen, schemaCode: schemaCode, schemaType: schemaType, def: def, it: it } = this;\n        return (0, $l2ufW.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */ if (!(schemaCode instanceof $l2ufW.Name)) throw new Error(\"ajv implementation error\");\n                const st = Array.isArray(schemaType) ? schemaType : [\n                    schemaType\n                ];\n                return (0, $l2ufW._)`${(0, $46MS3.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, $46MS3.DataType.Wrong)}`;\n            }\n            return $l2ufW.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue(\"validate$data\", {\n                    ref: def.validateSchema\n                }); // TODO value.code for standalone\n                return (0, $l2ufW._)`!${validateSchemaRef}(${schemaCode})`;\n            }\n            return $l2ufW.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = (0, $5eunN.getSubschema)(this.it, appl);\n        (0, $5eunN.extendSubschemaData)(subschema, this.it, appl);\n        (0, $5eunN.extendSubschemaMode)(subschema, appl);\n        const nextContext = {\n            ...this.it,\n            ...subschema,\n            items: undefined,\n            props: undefined\n        };\n        $6c12d34a75202c62$var$subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it: it, gen: gen } = this;\n        if (!it.opts.unevaluated) return;\n        if (it.props !== true && schemaCxt.props !== undefined) it.props = $7eX5i.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        if (it.items !== true && schemaCxt.items !== undefined) it.items = $7eX5i.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it: it, gen: gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, ()=>this.mergeEvaluated(schemaCxt, $l2ufW.Name));\n            return true;\n        }\n    }\n}\nmodule.exports.KeywordCxt = $6c12d34a75202c62$var$KeywordCxt;\nfunction $6c12d34a75202c62$var$keywordCode(it, keyword, def, ruleType) {\n    const cxt = new $6c12d34a75202c62$var$KeywordCxt(it, def, keyword);\n    if (\"code\" in def) def.code(cxt, ruleType);\n    else if (cxt.$data && def.validate) (0, $dTewx.funcKeywordCode)(cxt, def);\n    else if (\"macro\" in def) (0, $dTewx.macroKeywordCode)(cxt, def);\n    else if (def.compile || def.validate) (0, $dTewx.funcKeywordCode)(cxt, def);\n}\nconst $6c12d34a75202c62$var$JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst $6c12d34a75202c62$var$RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction $6c12d34a75202c62$var$getData($data, { dataLevel: dataLevel, dataNames: dataNames, dataPathArr: dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === \"\") return $dOpvc.default.rootData;\n    if ($data[0] === \"/\") {\n        if (!$6c12d34a75202c62$var$JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = $dOpvc.default.rootData;\n    } else {\n        const matches = $6c12d34a75202c62$var$RELATIVE_JSON_POINTER.exec($data);\n        if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n            if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel) throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer) return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split(\"/\");\n    for (const segment of segments)if (segment) {\n        data = (0, $l2ufW._)`${data}${(0, $l2ufW.getProperty)((0, $7eX5i.unescapeJsonPointer)(segment))}`;\n        expr = (0, $l2ufW._)`${expr} && ${data}`;\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nmodule.exports.getData = $6c12d34a75202c62$var$getData;\n\n});\nparcelRegister(\"75Cyv\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.boolOrEmptySchema = module.exports.topBoolOrEmptySchema = void 0;\n\nvar $hYgW9 = parcelRequire(\"hYgW9\");\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $dOpvc = parcelRequire(\"dOpvc\");\nconst $5296e860644b4914$var$boolError = {\n    message: \"boolean schema is false\"\n};\nfunction $5296e860644b4914$var$topBoolOrEmptySchema(it) {\n    const { gen: gen, schema: schema, validateName: validateName } = it;\n    if (schema === false) $5296e860644b4914$var$falseSchemaError(it, false);\n    else if (typeof schema == \"object\" && schema.$async === true) gen.return($dOpvc.default.data);\n    else {\n        gen.assign((0, $l2ufW._)`${validateName}.errors`, null);\n        gen.return(true);\n    }\n}\nmodule.exports.topBoolOrEmptySchema = $5296e860644b4914$var$topBoolOrEmptySchema;\nfunction $5296e860644b4914$var$boolOrEmptySchema(it, valid) {\n    const { gen: gen, schema: schema } = it;\n    if (schema === false) {\n        gen.var(valid, false); // TODO var\n        $5296e860644b4914$var$falseSchemaError(it);\n    } else gen.var(valid, true); // TODO var\n}\nmodule.exports.boolOrEmptySchema = $5296e860644b4914$var$boolOrEmptySchema;\nfunction $5296e860644b4914$var$falseSchemaError(it, overrideAllErrors) {\n    const { gen: gen, data: data } = it;\n    // TODO maybe some other interface should be used for non-keyword validation errors...\n    const cxt = {\n        gen: gen,\n        keyword: \"false schema\",\n        data: data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it: it\n    };\n    (0, $hYgW9.reportError)(cxt, $5296e860644b4914$var$boolError, undefined, overrideAllErrors);\n}\n\n});\nparcelRegister(\"hYgW9\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.extendErrors = module.exports.resetErrorsCount = module.exports.reportExtraError = module.exports.reportError = module.exports.keyword$DataError = module.exports.keywordError = void 0;\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\n\nvar $dOpvc = parcelRequire(\"dOpvc\");\nmodule.exports.keywordError = {\n    message: ({ keyword: keyword })=>(0, $l2ufW.str)`must pass \"${keyword}\" keyword validation`\n};\nmodule.exports.keyword$DataError = {\n    message: ({ keyword: keyword, schemaType: schemaType })=>schemaType ? (0, $l2ufW.str)`\"${keyword}\" keyword must be ${schemaType} ($data)` : (0, $l2ufW.str)`\"${keyword}\" keyword is invalid ($data)`\n};\nfunction $d1552d9220cfb4a2$var$reportError(cxt, error = module.exports.keywordError, errorPaths, overrideAllErrors) {\n    const { it: it } = cxt;\n    const { gen: gen, compositeRule: compositeRule, allErrors: allErrors } = it;\n    const errObj = $d1552d9220cfb4a2$var$errorObjectCode(cxt, error, errorPaths);\n    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) $d1552d9220cfb4a2$var$addError(gen, errObj);\n    else $d1552d9220cfb4a2$var$returnErrors(it, (0, $l2ufW._)`[${errObj}]`);\n}\nmodule.exports.reportError = $d1552d9220cfb4a2$var$reportError;\nfunction $d1552d9220cfb4a2$var$reportExtraError(cxt, error = module.exports.keywordError, errorPaths) {\n    const { it: it } = cxt;\n    const { gen: gen, compositeRule: compositeRule, allErrors: allErrors } = it;\n    const errObj = $d1552d9220cfb4a2$var$errorObjectCode(cxt, error, errorPaths);\n    $d1552d9220cfb4a2$var$addError(gen, errObj);\n    if (!(compositeRule || allErrors)) $d1552d9220cfb4a2$var$returnErrors(it, $dOpvc.default.vErrors);\n}\nmodule.exports.reportExtraError = $d1552d9220cfb4a2$var$reportExtraError;\nfunction $d1552d9220cfb4a2$var$resetErrorsCount(gen, errsCount) {\n    gen.assign($dOpvc.default.errors, errsCount);\n    gen.if((0, $l2ufW._)`${$dOpvc.default.vErrors} !== null`, ()=>gen.if(errsCount, ()=>gen.assign((0, $l2ufW._)`${$dOpvc.default.vErrors}.length`, errsCount), ()=>gen.assign($dOpvc.default.vErrors, null)));\n}\nmodule.exports.resetErrorsCount = $d1552d9220cfb4a2$var$resetErrorsCount;\nfunction $d1552d9220cfb4a2$var$extendErrors({ gen: gen, keyword: keyword, schemaValue: schemaValue, data: data, errsCount: errsCount, it: it }) {\n    /* istanbul ignore if */ if (errsCount === undefined) throw new Error(\"ajv implementation error\");\n    const err = gen.name(\"err\");\n    gen.forRange(\"i\", errsCount, $dOpvc.default.errors, (i)=>{\n        gen.const(err, (0, $l2ufW._)`${$dOpvc.default.vErrors}[${i}]`);\n        gen.if((0, $l2ufW._)`${err}.instancePath === undefined`, ()=>gen.assign((0, $l2ufW._)`${err}.instancePath`, (0, $l2ufW.strConcat)($dOpvc.default.instancePath, it.errorPath)));\n        gen.assign((0, $l2ufW._)`${err}.schemaPath`, (0, $l2ufW.str)`${it.errSchemaPath}/${keyword}`);\n        if (it.opts.verbose) {\n            gen.assign((0, $l2ufW._)`${err}.schema`, schemaValue);\n            gen.assign((0, $l2ufW._)`${err}.data`, data);\n        }\n    });\n}\nmodule.exports.extendErrors = $d1552d9220cfb4a2$var$extendErrors;\nfunction $d1552d9220cfb4a2$var$addError(gen, errObj) {\n    const err = gen.const(\"err\", errObj);\n    gen.if((0, $l2ufW._)`${$dOpvc.default.vErrors} === null`, ()=>gen.assign($dOpvc.default.vErrors, (0, $l2ufW._)`[${err}]`), (0, $l2ufW._)`${$dOpvc.default.vErrors}.push(${err})`);\n    gen.code((0, $l2ufW._)`${$dOpvc.default.errors}++`);\n}\nfunction $d1552d9220cfb4a2$var$returnErrors(it, errs) {\n    const { gen: gen, validateName: validateName, schemaEnv: schemaEnv } = it;\n    if (schemaEnv.$async) gen.throw((0, $l2ufW._)`new ${it.ValidationError}(${errs})`);\n    else {\n        gen.assign((0, $l2ufW._)`${validateName}.errors`, errs);\n        gen.return(false);\n    }\n}\nconst $d1552d9220cfb4a2$var$E = {\n    keyword: new $l2ufW.Name(\"keyword\"),\n    schemaPath: new $l2ufW.Name(\"schemaPath\"),\n    params: new $l2ufW.Name(\"params\"),\n    propertyName: new $l2ufW.Name(\"propertyName\"),\n    message: new $l2ufW.Name(\"message\"),\n    schema: new $l2ufW.Name(\"schema\"),\n    parentSchema: new $l2ufW.Name(\"parentSchema\")\n};\nfunction $d1552d9220cfb4a2$var$errorObjectCode(cxt, error, errorPaths) {\n    const { createErrors: createErrors } = cxt.it;\n    if (createErrors === false) return (0, $l2ufW._)`{}`;\n    return $d1552d9220cfb4a2$var$errorObject(cxt, error, errorPaths);\n}\nfunction $d1552d9220cfb4a2$var$errorObject(cxt, error, errorPaths = {}) {\n    const { gen: gen, it: it } = cxt;\n    const keyValues = [\n        $d1552d9220cfb4a2$var$errorInstancePath(it, errorPaths),\n        $d1552d9220cfb4a2$var$errorSchemaPath(cxt, errorPaths)\n    ];\n    $d1552d9220cfb4a2$var$extraErrorProps(cxt, error, keyValues);\n    return gen.object(...keyValues);\n}\nfunction $d1552d9220cfb4a2$var$errorInstancePath({ errorPath: errorPath }, { instancePath: instancePath }) {\n    const instPath = instancePath ? (0, $l2ufW.str)`${errorPath}${(0, $7eX5i.getErrorPath)(instancePath, $7eX5i.Type.Str)}` : errorPath;\n    return [\n        $dOpvc.default.instancePath,\n        (0, $l2ufW.strConcat)($dOpvc.default.instancePath, instPath)\n    ];\n}\nfunction $d1552d9220cfb4a2$var$errorSchemaPath({ keyword: keyword, it: { errSchemaPath: errSchemaPath } }, { schemaPath: schemaPath, parentSchema: parentSchema }) {\n    let schPath = parentSchema ? errSchemaPath : (0, $l2ufW.str)`${errSchemaPath}/${keyword}`;\n    if (schemaPath) schPath = (0, $l2ufW.str)`${schPath}${(0, $7eX5i.getErrorPath)(schemaPath, $7eX5i.Type.Str)}`;\n    return [\n        $d1552d9220cfb4a2$var$E.schemaPath,\n        schPath\n    ];\n}\nfunction $d1552d9220cfb4a2$var$extraErrorProps(cxt, { params: params, message: message }, keyValues) {\n    const { keyword: keyword, data: data, schemaValue: schemaValue, it: it } = cxt;\n    const { opts: opts, propertyName: propertyName, topSchemaRef: topSchemaRef, schemaPath: schemaPath } = it;\n    keyValues.push([\n        $d1552d9220cfb4a2$var$E.keyword,\n        keyword\n    ], [\n        $d1552d9220cfb4a2$var$E.params,\n        typeof params == \"function\" ? params(cxt) : params || (0, $l2ufW._)`{}`\n    ]);\n    if (opts.messages) keyValues.push([\n        $d1552d9220cfb4a2$var$E.message,\n        typeof message == \"function\" ? message(cxt) : message\n    ]);\n    if (opts.verbose) keyValues.push([\n        $d1552d9220cfb4a2$var$E.schema,\n        schemaValue\n    ], [\n        $d1552d9220cfb4a2$var$E.parentSchema,\n        (0, $l2ufW._)`${topSchemaRef}${schemaPath}`\n    ], [\n        $dOpvc.default.data,\n        data\n    ]);\n    if (propertyName) keyValues.push([\n        $d1552d9220cfb4a2$var$E.propertyName,\n        propertyName\n    ]);\n}\n\n});\nparcelRegister(\"l2ufW\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.or = module.exports.and = module.exports.not = module.exports.CodeGen = module.exports.operators = module.exports.varKinds = module.exports.ValueScopeName = module.exports.ValueScope = module.exports.Scope = module.exports.Name = module.exports.regexpCode = module.exports.stringify = module.exports.getProperty = module.exports.nil = module.exports.strConcat = module.exports.str = module.exports._ = void 0;\n\nvar $4GpWJ = parcelRequire(\"4GpWJ\");\n\nvar $eNw2I = parcelRequire(\"eNw2I\");\n\nvar $4GpWJ = parcelRequire(\"4GpWJ\");\nObject.defineProperty(module.exports, \"_\", {\n    enumerable: true,\n    get: function() {\n        return $4GpWJ._;\n    }\n});\nObject.defineProperty(module.exports, \"str\", {\n    enumerable: true,\n    get: function() {\n        return $4GpWJ.str;\n    }\n});\nObject.defineProperty(module.exports, \"strConcat\", {\n    enumerable: true,\n    get: function() {\n        return $4GpWJ.strConcat;\n    }\n});\nObject.defineProperty(module.exports, \"nil\", {\n    enumerable: true,\n    get: function() {\n        return $4GpWJ.nil;\n    }\n});\nObject.defineProperty(module.exports, \"getProperty\", {\n    enumerable: true,\n    get: function() {\n        return $4GpWJ.getProperty;\n    }\n});\nObject.defineProperty(module.exports, \"stringify\", {\n    enumerable: true,\n    get: function() {\n        return $4GpWJ.stringify;\n    }\n});\nObject.defineProperty(module.exports, \"regexpCode\", {\n    enumerable: true,\n    get: function() {\n        return $4GpWJ.regexpCode;\n    }\n});\nObject.defineProperty(module.exports, \"Name\", {\n    enumerable: true,\n    get: function() {\n        return $4GpWJ.Name;\n    }\n});\n\nvar $eNw2I = parcelRequire(\"eNw2I\");\nObject.defineProperty(module.exports, \"Scope\", {\n    enumerable: true,\n    get: function() {\n        return $eNw2I.Scope;\n    }\n});\nObject.defineProperty(module.exports, \"ValueScope\", {\n    enumerable: true,\n    get: function() {\n        return $eNw2I.ValueScope;\n    }\n});\nObject.defineProperty(module.exports, \"ValueScopeName\", {\n    enumerable: true,\n    get: function() {\n        return $eNw2I.ValueScopeName;\n    }\n});\nObject.defineProperty(module.exports, \"varKinds\", {\n    enumerable: true,\n    get: function() {\n        return $eNw2I.varKinds;\n    }\n});\nmodule.exports.operators = {\n    GT: new $4GpWJ._Code(\">\"),\n    GTE: new $4GpWJ._Code(\">=\"),\n    LT: new $4GpWJ._Code(\"<\"),\n    LTE: new $4GpWJ._Code(\"<=\"),\n    EQ: new $4GpWJ._Code(\"===\"),\n    NEQ: new $4GpWJ._Code(\"!==\"),\n    NOT: new $4GpWJ._Code(\"!\"),\n    OR: new $4GpWJ._Code(\"||\"),\n    AND: new $4GpWJ._Code(\"&&\"),\n    ADD: new $4GpWJ._Code(\"+\")\n};\nclass $f511411e7bf8f284$var$Node {\n    optimizeNodes() {\n        return this;\n    }\n    optimizeNames(_names, _constants) {\n        return this;\n    }\n}\nclass $f511411e7bf8f284$var$Def extends $f511411e7bf8f284$var$Node {\n    constructor(varKind, name, rhs){\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.rhs = rhs;\n    }\n    render({ es5: es5, _n: _n }) {\n        const varKind = es5 ? $eNw2I.varKinds.var : this.varKind;\n        const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`;\n        return `${varKind} ${this.name}${rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (!names[this.name.str]) return;\n        if (this.rhs) this.rhs = $f511411e7bf8f284$var$optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        return this.rhs instanceof $4GpWJ._CodeOrName ? this.rhs.names : {};\n    }\n}\nclass $f511411e7bf8f284$var$Assign extends $f511411e7bf8f284$var$Node {\n    constructor(lhs, rhs, sideEffects){\n        super();\n        this.lhs = lhs;\n        this.rhs = rhs;\n        this.sideEffects = sideEffects;\n    }\n    render({ _n: _n }) {\n        return `${this.lhs} = ${this.rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (this.lhs instanceof $4GpWJ.Name && !names[this.lhs.str] && !this.sideEffects) return;\n        this.rhs = $f511411e7bf8f284$var$optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        const names = this.lhs instanceof $4GpWJ.Name ? {} : {\n            ...this.lhs.names\n        };\n        return $f511411e7bf8f284$var$addExprNames(names, this.rhs);\n    }\n}\nclass $f511411e7bf8f284$var$AssignOp extends $f511411e7bf8f284$var$Assign {\n    constructor(lhs, op, rhs, sideEffects){\n        super(lhs, rhs, sideEffects);\n        this.op = op;\n    }\n    render({ _n: _n }) {\n        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n    }\n}\nclass $f511411e7bf8f284$var$Label extends $f511411e7bf8f284$var$Node {\n    constructor(label){\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n: _n }) {\n        return `${this.label}:` + _n;\n    }\n}\nclass $f511411e7bf8f284$var$Break extends $f511411e7bf8f284$var$Node {\n    constructor(label){\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n: _n }) {\n        const label = this.label ? ` ${this.label}` : \"\";\n        return `break${label};` + _n;\n    }\n}\nclass $f511411e7bf8f284$var$Throw extends $f511411e7bf8f284$var$Node {\n    constructor(error){\n        super();\n        this.error = error;\n    }\n    render({ _n: _n }) {\n        return `throw ${this.error};` + _n;\n    }\n    get names() {\n        return this.error.names;\n    }\n}\nclass $f511411e7bf8f284$var$AnyCode extends $f511411e7bf8f284$var$Node {\n    constructor(code){\n        super();\n        this.code = code;\n    }\n    render({ _n: _n }) {\n        return `${this.code};` + _n;\n    }\n    optimizeNodes() {\n        return `${this.code}` ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        this.code = $f511411e7bf8f284$var$optimizeExpr(this.code, names, constants);\n        return this;\n    }\n    get names() {\n        return this.code instanceof $4GpWJ._CodeOrName ? this.code.names : {};\n    }\n}\nclass $f511411e7bf8f284$var$ParentNode extends $f511411e7bf8f284$var$Node {\n    constructor(nodes = []){\n        super();\n        this.nodes = nodes;\n    }\n    render(opts) {\n        return this.nodes.reduce((code, n)=>code + n.render(opts), \"\");\n    }\n    optimizeNodes() {\n        const { nodes: nodes } = this;\n        let i = nodes.length;\n        while(i--){\n            const n = nodes[i].optimizeNodes();\n            if (Array.isArray(n)) nodes.splice(i, 1, ...n);\n            else if (n) nodes[i] = n;\n            else nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        const { nodes: nodes } = this;\n        let i = nodes.length;\n        while(i--){\n            // iterating backwards improves 1-pass optimization\n            const n = nodes[i];\n            if (n.optimizeNames(names, constants)) continue;\n            $f511411e7bf8f284$var$subtractNames(names, n.names);\n            nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    get names() {\n        return this.nodes.reduce((names, n)=>$f511411e7bf8f284$var$addNames(names, n.names), {});\n    }\n}\nclass $f511411e7bf8f284$var$BlockNode extends $f511411e7bf8f284$var$ParentNode {\n    render(opts) {\n        return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n    }\n}\nclass $f511411e7bf8f284$var$Root extends $f511411e7bf8f284$var$ParentNode {\n}\nclass $f511411e7bf8f284$var$Else extends $f511411e7bf8f284$var$BlockNode {\n}\n$f511411e7bf8f284$var$Else.kind = \"else\";\nclass $f511411e7bf8f284$var$If extends $f511411e7bf8f284$var$BlockNode {\n    constructor(condition, nodes){\n        super(nodes);\n        this.condition = condition;\n    }\n    render(opts) {\n        let code = `if(${this.condition})` + super.render(opts);\n        if (this.else) code += \"else \" + this.else.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        super.optimizeNodes();\n        const cond = this.condition;\n        if (cond === true) return this.nodes; // else is ignored here\n        let e = this.else;\n        if (e) {\n            const ns = e.optimizeNodes();\n            e = this.else = Array.isArray(ns) ? new $f511411e7bf8f284$var$Else(ns) : ns;\n        }\n        if (e) {\n            if (cond === false) return e instanceof $f511411e7bf8f284$var$If ? e : e.nodes;\n            if (this.nodes.length) return this;\n            return new $f511411e7bf8f284$var$If($f511411e7bf8f284$var$not(cond), e instanceof $f511411e7bf8f284$var$If ? [\n                e\n            ] : e.nodes);\n        }\n        if (cond === false || !this.nodes.length) return undefined;\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a;\n        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        if (!(super.optimizeNames(names, constants) || this.else)) return;\n        this.condition = $f511411e7bf8f284$var$optimizeExpr(this.condition, names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        $f511411e7bf8f284$var$addExprNames(names, this.condition);\n        if (this.else) $f511411e7bf8f284$var$addNames(names, this.else.names);\n        return names;\n    }\n}\n$f511411e7bf8f284$var$If.kind = \"if\";\nclass $f511411e7bf8f284$var$For extends $f511411e7bf8f284$var$BlockNode {\n}\n$f511411e7bf8f284$var$For.kind = \"for\";\nclass $f511411e7bf8f284$var$ForLoop extends $f511411e7bf8f284$var$For {\n    constructor(iteration){\n        super();\n        this.iteration = iteration;\n    }\n    render(opts) {\n        return `for(${this.iteration})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants)) return;\n        this.iteration = $f511411e7bf8f284$var$optimizeExpr(this.iteration, names, constants);\n        return this;\n    }\n    get names() {\n        return $f511411e7bf8f284$var$addNames(super.names, this.iteration.names);\n    }\n}\nclass $f511411e7bf8f284$var$ForRange extends $f511411e7bf8f284$var$For {\n    constructor(varKind, name, from, to){\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.from = from;\n        this.to = to;\n    }\n    render(opts) {\n        const varKind = opts.es5 ? $eNw2I.varKinds.var : this.varKind;\n        const { name: name, from: from, to: to } = this;\n        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n    }\n    get names() {\n        const names = $f511411e7bf8f284$var$addExprNames(super.names, this.from);\n        return $f511411e7bf8f284$var$addExprNames(names, this.to);\n    }\n}\nclass $f511411e7bf8f284$var$ForIter extends $f511411e7bf8f284$var$For {\n    constructor(loop, varKind, name, iterable){\n        super();\n        this.loop = loop;\n        this.varKind = varKind;\n        this.name = name;\n        this.iterable = iterable;\n    }\n    render(opts) {\n        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants)) return;\n        this.iterable = $f511411e7bf8f284$var$optimizeExpr(this.iterable, names, constants);\n        return this;\n    }\n    get names() {\n        return $f511411e7bf8f284$var$addNames(super.names, this.iterable.names);\n    }\n}\nclass $f511411e7bf8f284$var$Func extends $f511411e7bf8f284$var$BlockNode {\n    constructor(name, args, async){\n        super();\n        this.name = name;\n        this.args = args;\n        this.async = async;\n    }\n    render(opts) {\n        const _async = this.async ? \"async \" : \"\";\n        return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n    }\n}\n$f511411e7bf8f284$var$Func.kind = \"func\";\nclass $f511411e7bf8f284$var$Return extends $f511411e7bf8f284$var$ParentNode {\n    render(opts) {\n        return \"return \" + super.render(opts);\n    }\n}\n$f511411e7bf8f284$var$Return.kind = \"return\";\nclass $f511411e7bf8f284$var$Try extends $f511411e7bf8f284$var$BlockNode {\n    render(opts) {\n        let code = \"try\" + super.render(opts);\n        if (this.catch) code += this.catch.render(opts);\n        if (this.finally) code += this.finally.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        var _a, _b;\n        super.optimizeNodes();\n        (_a = this.catch) === null || _a === void 0 || _a.optimizeNodes();\n        (_b = this.finally) === null || _b === void 0 || _b.optimizeNodes();\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a, _b;\n        super.optimizeNames(names, constants);\n        (_a = this.catch) === null || _a === void 0 || _a.optimizeNames(names, constants);\n        (_b = this.finally) === null || _b === void 0 || _b.optimizeNames(names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        if (this.catch) $f511411e7bf8f284$var$addNames(names, this.catch.names);\n        if (this.finally) $f511411e7bf8f284$var$addNames(names, this.finally.names);\n        return names;\n    }\n}\nclass $f511411e7bf8f284$var$Catch extends $f511411e7bf8f284$var$BlockNode {\n    constructor(error){\n        super();\n        this.error = error;\n    }\n    render(opts) {\n        return `catch(${this.error})` + super.render(opts);\n    }\n}\n$f511411e7bf8f284$var$Catch.kind = \"catch\";\nclass $f511411e7bf8f284$var$Finally extends $f511411e7bf8f284$var$BlockNode {\n    render(opts) {\n        return \"finally\" + super.render(opts);\n    }\n}\n$f511411e7bf8f284$var$Finally.kind = \"finally\";\nclass $f511411e7bf8f284$var$CodeGen {\n    constructor(extScope, opts = {}){\n        this._values = {};\n        this._blockStarts = [];\n        this._constants = {};\n        this.opts = {\n            ...opts,\n            _n: opts.lines ? \"\\n\" : \"\"\n        };\n        this._extScope = extScope;\n        this._scope = new $eNw2I.Scope({\n            parent: extScope\n        });\n        this._nodes = [\n            new $f511411e7bf8f284$var$Root()\n        ];\n    }\n    toString() {\n        return this._root.render(this.opts);\n    }\n    // returns unique name in the internal scope\n    name(prefix) {\n        return this._scope.name(prefix);\n    }\n    // reserves unique name in the external scope\n    scopeName(prefix) {\n        return this._extScope.name(prefix);\n    }\n    // reserves unique name in the external scope and assigns value to it\n    scopeValue(prefixOrName, value) {\n        const name = this._extScope.value(prefixOrName, value);\n        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());\n        vs.add(name);\n        return name;\n    }\n    getScopeValue(prefix, keyOrRef) {\n        return this._extScope.getValue(prefix, keyOrRef);\n    }\n    // return code that assigns values in the external scope to the names that are used internally\n    // (same names that were returned by gen.scopeName or gen.scopeValue)\n    scopeRefs(scopeName) {\n        return this._extScope.scopeRefs(scopeName, this._values);\n    }\n    scopeCode() {\n        return this._extScope.scopeCode(this._values);\n    }\n    _def(varKind, nameOrPrefix, rhs, constant) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (rhs !== undefined && constant) this._constants[name.str] = rhs;\n        this._leafNode(new $f511411e7bf8f284$var$Def(varKind, name, rhs));\n        return name;\n    }\n    // `const` declaration (`var` in es5 mode)\n    const(nameOrPrefix, rhs, _constant) {\n        return this._def($eNw2I.varKinds.const, nameOrPrefix, rhs, _constant);\n    }\n    // `let` declaration with optional assignment (`var` in es5 mode)\n    let(nameOrPrefix, rhs, _constant) {\n        return this._def($eNw2I.varKinds.let, nameOrPrefix, rhs, _constant);\n    }\n    // `var` declaration with optional assignment\n    var(nameOrPrefix, rhs, _constant) {\n        return this._def($eNw2I.varKinds.var, nameOrPrefix, rhs, _constant);\n    }\n    // assignment code\n    assign(lhs, rhs, sideEffects) {\n        return this._leafNode(new $f511411e7bf8f284$var$Assign(lhs, rhs, sideEffects));\n    }\n    // `+=` code\n    add(lhs, rhs) {\n        return this._leafNode(new $f511411e7bf8f284$var$AssignOp(lhs, module.exports.operators.ADD, rhs));\n    }\n    // appends passed SafeExpr to code or executes Block\n    code(c) {\n        if (typeof c == \"function\") c();\n        else if (c !== $4GpWJ.nil) this._leafNode(new $f511411e7bf8f284$var$AnyCode(c));\n        return this;\n    }\n    // returns code for object literal for the passed argument list of key-value pairs\n    object(...keyValues) {\n        const code = [\n            \"{\"\n        ];\n        for (const [key, value] of keyValues){\n            if (code.length > 1) code.push(\",\");\n            code.push(key);\n            if (key !== value || this.opts.es5) {\n                code.push(\":\");\n                (0, $4GpWJ.addCodeArg)(code, value);\n            }\n        }\n        code.push(\"}\");\n        return new $4GpWJ._Code(code);\n    }\n    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n    if(condition, thenBody, elseBody) {\n        this._blockNode(new $f511411e7bf8f284$var$If(condition));\n        if (thenBody && elseBody) this.code(thenBody).else().code(elseBody).endIf();\n        else if (thenBody) this.code(thenBody).endIf();\n        else if (elseBody) throw new Error('CodeGen: \"else\" body without \"then\" body');\n        return this;\n    }\n    // `else if` clause - invalid without `if` or after `else` clauses\n    elseIf(condition) {\n        return this._elseNode(new $f511411e7bf8f284$var$If(condition));\n    }\n    // `else` clause - only valid after `if` or `else if` clauses\n    else() {\n        return this._elseNode(new $f511411e7bf8f284$var$Else());\n    }\n    // end `if` statement (needed if gen.if was used only with condition)\n    endIf() {\n        return this._endBlockNode($f511411e7bf8f284$var$If, $f511411e7bf8f284$var$Else);\n    }\n    _for(node, forBody) {\n        this._blockNode(node);\n        if (forBody) this.code(forBody).endFor();\n        return this;\n    }\n    // a generic `for` clause (or statement if `forBody` is passed)\n    for(iteration, forBody) {\n        return this._for(new $f511411e7bf8f284$var$ForLoop(iteration), forBody);\n    }\n    // `for` statement for a range of values\n    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? $eNw2I.varKinds.var : $eNw2I.varKinds.let) {\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new $f511411e7bf8f284$var$ForRange(varKind, name, from, to), ()=>forBody(name));\n    }\n    // `for-of` statement (in es5 mode replace with a normal for loop)\n    forOf(nameOrPrefix, iterable, forBody, varKind = $eNw2I.varKinds.const) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (this.opts.es5) {\n            const arr = iterable instanceof $4GpWJ.Name ? iterable : this.var(\"_arr\", iterable);\n            return this.forRange(\"_i\", 0, (0, $4GpWJ._)`${arr}.length`, (i)=>{\n                this.var(name, (0, $4GpWJ._)`${arr}[${i}]`);\n                forBody(name);\n            });\n        }\n        return this._for(new $f511411e7bf8f284$var$ForIter(\"of\", varKind, name, iterable), ()=>forBody(name));\n    }\n    // `for-in` statement.\n    // With option `ownProperties` replaced with a `for-of` loop for object keys\n    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? $eNw2I.varKinds.var : $eNw2I.varKinds.const) {\n        if (this.opts.ownProperties) return this.forOf(nameOrPrefix, (0, $4GpWJ._)`Object.keys(${obj})`, forBody);\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new $f511411e7bf8f284$var$ForIter(\"in\", varKind, name, obj), ()=>forBody(name));\n    }\n    // end `for` loop\n    endFor() {\n        return this._endBlockNode($f511411e7bf8f284$var$For);\n    }\n    // `label` statement\n    label(label) {\n        return this._leafNode(new $f511411e7bf8f284$var$Label(label));\n    }\n    // `break` statement\n    break(label) {\n        return this._leafNode(new $f511411e7bf8f284$var$Break(label));\n    }\n    // `return` statement\n    return(value) {\n        const node = new $f511411e7bf8f284$var$Return();\n        this._blockNode(node);\n        this.code(value);\n        if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node');\n        return this._endBlockNode($f511411e7bf8f284$var$Return);\n    }\n    // `try` statement\n    try(tryBody, catchCode, finallyCode) {\n        if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n        const node = new $f511411e7bf8f284$var$Try();\n        this._blockNode(node);\n        this.code(tryBody);\n        if (catchCode) {\n            const error = this.name(\"e\");\n            this._currNode = node.catch = new $f511411e7bf8f284$var$Catch(error);\n            catchCode(error);\n        }\n        if (finallyCode) {\n            this._currNode = node.finally = new $f511411e7bf8f284$var$Finally();\n            this.code(finallyCode);\n        }\n        return this._endBlockNode($f511411e7bf8f284$var$Catch, $f511411e7bf8f284$var$Finally);\n    }\n    // `throw` statement\n    throw(error) {\n        return this._leafNode(new $f511411e7bf8f284$var$Throw(error));\n    }\n    // start self-balancing block\n    block(body, nodeCount) {\n        this._blockStarts.push(this._nodes.length);\n        if (body) this.code(body).endBlock(nodeCount);\n        return this;\n    }\n    // end the current self-balancing block\n    endBlock(nodeCount) {\n        const len = this._blockStarts.pop();\n        if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\");\n        const toClose = this._nodes.length - len;\n        if (toClose < 0 || nodeCount !== undefined && toClose !== nodeCount) throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n        this._nodes.length = len;\n        return this;\n    }\n    // `function` heading (or definition if funcBody is passed)\n    func(name, args = $4GpWJ.nil, async, funcBody) {\n        this._blockNode(new $f511411e7bf8f284$var$Func(name, args, async));\n        if (funcBody) this.code(funcBody).endFunc();\n        return this;\n    }\n    // end function definition\n    endFunc() {\n        return this._endBlockNode($f511411e7bf8f284$var$Func);\n    }\n    optimize(n = 1) {\n        while(n-- > 0){\n            this._root.optimizeNodes();\n            this._root.optimizeNames(this._root.names, this._constants);\n        }\n    }\n    _leafNode(node) {\n        this._currNode.nodes.push(node);\n        return this;\n    }\n    _blockNode(node) {\n        this._currNode.nodes.push(node);\n        this._nodes.push(node);\n    }\n    _endBlockNode(N1, N2) {\n        const n = this._currNode;\n        if (n instanceof N1 || N2 && n instanceof N2) {\n            this._nodes.pop();\n            return this;\n        }\n        throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`);\n    }\n    _elseNode(node) {\n        const n = this._currNode;\n        if (!(n instanceof $f511411e7bf8f284$var$If)) throw new Error('CodeGen: \"else\" without \"if\"');\n        this._currNode = n.else = node;\n        return this;\n    }\n    get _root() {\n        return this._nodes[0];\n    }\n    get _currNode() {\n        const ns = this._nodes;\n        return ns[ns.length - 1];\n    }\n    set _currNode(node) {\n        const ns = this._nodes;\n        ns[ns.length - 1] = node;\n    }\n}\nmodule.exports.CodeGen = $f511411e7bf8f284$var$CodeGen;\nfunction $f511411e7bf8f284$var$addNames(names, from) {\n    for(const n in from)names[n] = (names[n] || 0) + (from[n] || 0);\n    return names;\n}\nfunction $f511411e7bf8f284$var$addExprNames(names, from) {\n    return from instanceof $4GpWJ._CodeOrName ? $f511411e7bf8f284$var$addNames(names, from.names) : names;\n}\nfunction $f511411e7bf8f284$var$optimizeExpr(expr, names, constants) {\n    if (expr instanceof $4GpWJ.Name) return replaceName(expr);\n    if (!canOptimize(expr)) return expr;\n    return new $4GpWJ._Code(expr._items.reduce((items, c)=>{\n        if (c instanceof $4GpWJ.Name) c = replaceName(c);\n        if (c instanceof $4GpWJ._Code) items.push(...c._items);\n        else items.push(c);\n        return items;\n    }, []));\n    function replaceName(n) {\n        const c = constants[n.str];\n        if (c === undefined || names[n.str] !== 1) return n;\n        delete names[n.str];\n        return c;\n    }\n    function canOptimize(e) {\n        return e instanceof $4GpWJ._Code && e._items.some((c)=>c instanceof $4GpWJ.Name && names[c.str] === 1 && constants[c.str] !== undefined);\n    }\n}\nfunction $f511411e7bf8f284$var$subtractNames(names, from) {\n    for(const n in from)names[n] = (names[n] || 0) - (from[n] || 0);\n}\nfunction $f511411e7bf8f284$var$not(x) {\n    return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : (0, $4GpWJ._)`!${$f511411e7bf8f284$var$par(x)}`;\n}\nmodule.exports.not = $f511411e7bf8f284$var$not;\nconst $f511411e7bf8f284$var$andCode = $f511411e7bf8f284$var$mappend(module.exports.operators.AND);\n// boolean AND (&&) expression with the passed arguments\nfunction $f511411e7bf8f284$var$and(...args) {\n    return args.reduce($f511411e7bf8f284$var$andCode);\n}\nmodule.exports.and = $f511411e7bf8f284$var$and;\nconst $f511411e7bf8f284$var$orCode = $f511411e7bf8f284$var$mappend(module.exports.operators.OR);\n// boolean OR (||) expression with the passed arguments\nfunction $f511411e7bf8f284$var$or(...args) {\n    return args.reduce($f511411e7bf8f284$var$orCode);\n}\nmodule.exports.or = $f511411e7bf8f284$var$or;\nfunction $f511411e7bf8f284$var$mappend(op) {\n    return (x, y)=>x === $4GpWJ.nil ? y : y === $4GpWJ.nil ? x : (0, $4GpWJ._)`${$f511411e7bf8f284$var$par(x)} ${op} ${$f511411e7bf8f284$var$par(y)}`;\n}\nfunction $f511411e7bf8f284$var$par(x) {\n    return x instanceof $4GpWJ.Name ? x : (0, $4GpWJ._)`(${x})`;\n}\n\n});\nparcelRegister(\"4GpWJ\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.regexpCode = module.exports.getEsmExportName = module.exports.getProperty = module.exports.safeStringify = module.exports.stringify = module.exports.strConcat = module.exports.addCodeArg = module.exports.str = module.exports._ = module.exports.nil = module.exports._Code = module.exports.Name = module.exports.IDENTIFIER = module.exports._CodeOrName = void 0;\nclass $368f361121c33a9b$var$_CodeOrName {\n}\nmodule.exports._CodeOrName = $368f361121c33a9b$var$_CodeOrName;\nmodule.exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nclass $368f361121c33a9b$var$Name extends $368f361121c33a9b$var$_CodeOrName {\n    constructor(s){\n        super();\n        if (!module.exports.IDENTIFIER.test(s)) throw new Error(\"CodeGen: name must be a valid identifier\");\n        this.str = s;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        return false;\n    }\n    get names() {\n        return {\n            [this.str]: 1\n        };\n    }\n}\nmodule.exports.Name = $368f361121c33a9b$var$Name;\nclass $368f361121c33a9b$var$_Code extends $368f361121c33a9b$var$_CodeOrName {\n    constructor(code){\n        super();\n        this._items = typeof code === \"string\" ? [\n            code\n        ] : code;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        if (this._items.length > 1) return false;\n        const item = this._items[0];\n        return item === \"\" || item === '\"\"';\n    }\n    get str() {\n        var _a;\n        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c)=>`${s}${c}`, \"\");\n    }\n    get names() {\n        var _a;\n        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c)=>{\n            if (c instanceof $368f361121c33a9b$var$Name) names[c.str] = (names[c.str] || 0) + 1;\n            return names;\n        }, {});\n    }\n}\nmodule.exports._Code = $368f361121c33a9b$var$_Code;\nmodule.exports.nil = new $368f361121c33a9b$var$_Code(\"\");\nfunction $368f361121c33a9b$var$_(strs, ...args) {\n    const code = [\n        strs[0]\n    ];\n    let i = 0;\n    while(i < args.length){\n        $368f361121c33a9b$var$addCodeArg(code, args[i]);\n        code.push(strs[++i]);\n    }\n    return new $368f361121c33a9b$var$_Code(code);\n}\nmodule.exports._ = $368f361121c33a9b$var$_;\nconst $368f361121c33a9b$var$plus = new $368f361121c33a9b$var$_Code(\"+\");\nfunction $368f361121c33a9b$var$str(strs, ...args) {\n    const expr = [\n        $368f361121c33a9b$var$safeStringify(strs[0])\n    ];\n    let i = 0;\n    while(i < args.length){\n        expr.push($368f361121c33a9b$var$plus);\n        $368f361121c33a9b$var$addCodeArg(expr, args[i]);\n        expr.push($368f361121c33a9b$var$plus, $368f361121c33a9b$var$safeStringify(strs[++i]));\n    }\n    $368f361121c33a9b$var$optimize(expr);\n    return new $368f361121c33a9b$var$_Code(expr);\n}\nmodule.exports.str = $368f361121c33a9b$var$str;\nfunction $368f361121c33a9b$var$addCodeArg(code, arg) {\n    if (arg instanceof $368f361121c33a9b$var$_Code) code.push(...arg._items);\n    else if (arg instanceof $368f361121c33a9b$var$Name) code.push(arg);\n    else code.push($368f361121c33a9b$var$interpolate(arg));\n}\nmodule.exports.addCodeArg = $368f361121c33a9b$var$addCodeArg;\nfunction $368f361121c33a9b$var$optimize(expr) {\n    let i = 1;\n    while(i < expr.length - 1){\n        if (expr[i] === $368f361121c33a9b$var$plus) {\n            const res = $368f361121c33a9b$var$mergeExprItems(expr[i - 1], expr[i + 1]);\n            if (res !== undefined) {\n                expr.splice(i - 1, 3, res);\n                continue;\n            }\n            expr[i++] = \"+\";\n        }\n        i++;\n    }\n}\nfunction $368f361121c33a9b$var$mergeExprItems(a, b) {\n    if (b === '\"\"') return a;\n    if (a === '\"\"') return b;\n    if (typeof a == \"string\") {\n        if (b instanceof $368f361121c33a9b$var$Name || a[a.length - 1] !== '\"') return;\n        if (typeof b != \"string\") return `${a.slice(0, -1)}${b}\"`;\n        if (b[0] === '\"') return a.slice(0, -1) + b.slice(1);\n        return;\n    }\n    if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof $368f361121c33a9b$var$Name)) return `\"${a}${b.slice(1)}`;\n    return;\n}\nfunction $368f361121c33a9b$var$strConcat(c1, c2) {\n    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : $368f361121c33a9b$var$str`${c1}${c2}`;\n}\nmodule.exports.strConcat = $368f361121c33a9b$var$strConcat;\n// TODO do not allow arrays here\nfunction $368f361121c33a9b$var$interpolate(x) {\n    return typeof x == \"number\" || typeof x == \"boolean\" || x === null ? x : $368f361121c33a9b$var$safeStringify(Array.isArray(x) ? x.join(\",\") : x);\n}\nfunction $368f361121c33a9b$var$stringify(x) {\n    return new $368f361121c33a9b$var$_Code($368f361121c33a9b$var$safeStringify(x));\n}\nmodule.exports.stringify = $368f361121c33a9b$var$stringify;\nfunction $368f361121c33a9b$var$safeStringify(x) {\n    return JSON.stringify(x).replace(/\\u2028/g, \"\\\\u2028\").replace(/\\u2029/g, \"\\\\u2029\");\n}\nmodule.exports.safeStringify = $368f361121c33a9b$var$safeStringify;\nfunction $368f361121c33a9b$var$getProperty(key) {\n    return typeof key == \"string\" && module.exports.IDENTIFIER.test(key) ? new $368f361121c33a9b$var$_Code(`.${key}`) : $368f361121c33a9b$var$_`[${key}]`;\n}\nmodule.exports.getProperty = $368f361121c33a9b$var$getProperty;\n//Does best effort to format the name properly\nfunction $368f361121c33a9b$var$getEsmExportName(key) {\n    if (typeof key == \"string\" && module.exports.IDENTIFIER.test(key)) return new $368f361121c33a9b$var$_Code(`${key}`);\n    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);\n}\nmodule.exports.getEsmExportName = $368f361121c33a9b$var$getEsmExportName;\nfunction $368f361121c33a9b$var$regexpCode(rx) {\n    return new $368f361121c33a9b$var$_Code(rx.toString());\n}\nmodule.exports.regexpCode = $368f361121c33a9b$var$regexpCode;\n\n});\n\nparcelRegister(\"eNw2I\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.ValueScope = module.exports.ValueScopeName = module.exports.Scope = module.exports.varKinds = module.exports.UsedValueState = void 0;\n\nvar $4GpWJ = parcelRequire(\"4GpWJ\");\nclass $ac5e7f513a485aeb$var$ValueError extends Error {\n    constructor(name){\n        super(`CodeGen: \"code\" for ${name} not defined`);\n        this.value = name.value;\n    }\n}\nvar $ac5e7f513a485aeb$var$UsedValueState;\n(function(UsedValueState) {\n    UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n    UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})($ac5e7f513a485aeb$var$UsedValueState = module.exports.UsedValueState || (module.exports.UsedValueState = {}));\nmodule.exports.varKinds = {\n    const: new $4GpWJ.Name(\"const\"),\n    let: new $4GpWJ.Name(\"let\"),\n    var: new $4GpWJ.Name(\"var\")\n};\nclass $ac5e7f513a485aeb$var$Scope {\n    constructor({ prefixes: prefixes, parent: parent } = {}){\n        this._names = {};\n        this._prefixes = prefixes;\n        this._parent = parent;\n    }\n    toName(nameOrPrefix) {\n        return nameOrPrefix instanceof $4GpWJ.Name ? nameOrPrefix : this.name(nameOrPrefix);\n    }\n    name(prefix) {\n        return new $4GpWJ.Name(this._newName(prefix));\n    }\n    _newName(prefix) {\n        const ng = this._names[prefix] || this._nameGroup(prefix);\n        return `${prefix}${ng.index++}`;\n    }\n    _nameGroup(prefix) {\n        var _a, _b;\n        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n        return this._names[prefix] = {\n            prefix: prefix,\n            index: 0\n        };\n    }\n}\nmodule.exports.Scope = $ac5e7f513a485aeb$var$Scope;\nclass $ac5e7f513a485aeb$var$ValueScopeName extends $4GpWJ.Name {\n    constructor(prefix, nameStr){\n        super(nameStr);\n        this.prefix = prefix;\n    }\n    setValue(value, { property: property, itemIndex: itemIndex }) {\n        this.value = value;\n        this.scopePath = (0, $4GpWJ._)`.${new $4GpWJ.Name(property)}[${itemIndex}]`;\n    }\n}\nmodule.exports.ValueScopeName = $ac5e7f513a485aeb$var$ValueScopeName;\nconst $ac5e7f513a485aeb$var$line = (0, $4GpWJ._)`\\n`;\nclass $ac5e7f513a485aeb$var$ValueScope extends $ac5e7f513a485aeb$var$Scope {\n    constructor(opts){\n        super(opts);\n        this._values = {};\n        this._scope = opts.scope;\n        this.opts = {\n            ...opts,\n            _n: opts.lines ? $ac5e7f513a485aeb$var$line : $4GpWJ.nil\n        };\n    }\n    get() {\n        return this._scope;\n    }\n    name(prefix) {\n        return new $ac5e7f513a485aeb$var$ValueScopeName(prefix, this._newName(prefix));\n    }\n    value(nameOrPrefix, value) {\n        var _a;\n        if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\");\n        const name = this.toName(nameOrPrefix);\n        const { prefix: prefix } = name;\n        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n        let vs = this._values[prefix];\n        if (vs) {\n            const _name = vs.get(valueKey);\n            if (_name) return _name;\n        } else vs = this._values[prefix] = new Map();\n        vs.set(valueKey, name);\n        const s = this._scope[prefix] || (this._scope[prefix] = []);\n        const itemIndex = s.length;\n        s[itemIndex] = value.ref;\n        name.setValue(value, {\n            property: prefix,\n            itemIndex: itemIndex\n        });\n        return name;\n    }\n    getValue(prefix, keyOrRef) {\n        const vs = this._values[prefix];\n        if (!vs) return;\n        return vs.get(keyOrRef);\n    }\n    scopeRefs(scopeName, values = this._values) {\n        return this._reduceValues(values, (name)=>{\n            if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return (0, $4GpWJ._)`${scopeName}${name.scopePath}`;\n        });\n    }\n    scopeCode(values = this._values, usedValues, getCode) {\n        return this._reduceValues(values, (name)=>{\n            if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return name.value.code;\n        }, usedValues, getCode);\n    }\n    _reduceValues(values, valueCode, usedValues = {}, getCode) {\n        let code = $4GpWJ.nil;\n        for(const prefix in values){\n            const vs = values[prefix];\n            if (!vs) continue;\n            const nameSet = usedValues[prefix] = usedValues[prefix] || new Map();\n            vs.forEach((name)=>{\n                if (nameSet.has(name)) return;\n                nameSet.set(name, $ac5e7f513a485aeb$var$UsedValueState.Started);\n                let c = valueCode(name);\n                if (c) {\n                    const def = this.opts.es5 ? module.exports.varKinds.var : module.exports.varKinds.const;\n                    code = (0, $4GpWJ._)`${code}${def} ${name} = ${c};${this.opts._n}`;\n                } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) code = (0, $4GpWJ._)`${code}${c}${this.opts._n}`;\n                else throw new $ac5e7f513a485aeb$var$ValueError(name);\n                nameSet.set(name, $ac5e7f513a485aeb$var$UsedValueState.Completed);\n            });\n        }\n        return code;\n    }\n}\nmodule.exports.ValueScope = $ac5e7f513a485aeb$var$ValueScope;\n\n});\n\n\nparcelRegister(\"7eX5i\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.checkStrictMode = module.exports.getErrorPath = module.exports.Type = module.exports.useFunc = module.exports.setEvaluated = module.exports.evaluatedPropsToName = module.exports.mergeEvaluated = module.exports.eachItem = module.exports.unescapeJsonPointer = module.exports.escapeJsonPointer = module.exports.escapeFragment = module.exports.unescapeFragment = module.exports.schemaRefOrVal = module.exports.schemaHasRulesButRef = module.exports.schemaHasRules = module.exports.checkUnknownRules = module.exports.alwaysValidSchema = module.exports.toHash = void 0;\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $4GpWJ = parcelRequire(\"4GpWJ\");\n// TODO refactor to use Set\nfunction $5457ac2764e63104$var$toHash(arr) {\n    const hash = {};\n    for (const item of arr)hash[item] = true;\n    return hash;\n}\nmodule.exports.toHash = $5457ac2764e63104$var$toHash;\nfunction $5457ac2764e63104$var$alwaysValidSchema(it, schema) {\n    if (typeof schema == \"boolean\") return schema;\n    if (Object.keys(schema).length === 0) return true;\n    $5457ac2764e63104$var$checkUnknownRules(it, schema);\n    return !$5457ac2764e63104$var$schemaHasRules(schema, it.self.RULES.all);\n}\nmodule.exports.alwaysValidSchema = $5457ac2764e63104$var$alwaysValidSchema;\nfunction $5457ac2764e63104$var$checkUnknownRules(it, schema = it.schema) {\n    const { opts: opts, self: self } = it;\n    if (!opts.strictSchema) return;\n    if (typeof schema === \"boolean\") return;\n    const rules = self.RULES.keywords;\n    for(const key in schema)if (!rules[key]) $5457ac2764e63104$var$checkStrictMode(it, `unknown keyword: \"${key}\"`);\n}\nmodule.exports.checkUnknownRules = $5457ac2764e63104$var$checkUnknownRules;\nfunction $5457ac2764e63104$var$schemaHasRules(schema, rules) {\n    if (typeof schema == \"boolean\") return !schema;\n    for(const key in schema)if (rules[key]) return true;\n    return false;\n}\nmodule.exports.schemaHasRules = $5457ac2764e63104$var$schemaHasRules;\nfunction $5457ac2764e63104$var$schemaHasRulesButRef(schema, RULES) {\n    if (typeof schema == \"boolean\") return !schema;\n    for(const key in schema)if (key !== \"$ref\" && RULES.all[key]) return true;\n    return false;\n}\nmodule.exports.schemaHasRulesButRef = $5457ac2764e63104$var$schemaHasRulesButRef;\nfunction $5457ac2764e63104$var$schemaRefOrVal({ topSchemaRef: topSchemaRef, schemaPath: schemaPath }, schema, keyword, $data) {\n    if (!$data) {\n        if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema;\n        if (typeof schema == \"string\") return (0, $l2ufW._)`${schema}`;\n    }\n    return (0, $l2ufW._)`${topSchemaRef}${schemaPath}${(0, $l2ufW.getProperty)(keyword)}`;\n}\nmodule.exports.schemaRefOrVal = $5457ac2764e63104$var$schemaRefOrVal;\nfunction $5457ac2764e63104$var$unescapeFragment(str) {\n    return $5457ac2764e63104$var$unescapeJsonPointer(decodeURIComponent(str));\n}\nmodule.exports.unescapeFragment = $5457ac2764e63104$var$unescapeFragment;\nfunction $5457ac2764e63104$var$escapeFragment(str) {\n    return encodeURIComponent($5457ac2764e63104$var$escapeJsonPointer(str));\n}\nmodule.exports.escapeFragment = $5457ac2764e63104$var$escapeFragment;\nfunction $5457ac2764e63104$var$escapeJsonPointer(str) {\n    if (typeof str == \"number\") return `${str}`;\n    return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nmodule.exports.escapeJsonPointer = $5457ac2764e63104$var$escapeJsonPointer;\nfunction $5457ac2764e63104$var$unescapeJsonPointer(str) {\n    return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nmodule.exports.unescapeJsonPointer = $5457ac2764e63104$var$unescapeJsonPointer;\nfunction $5457ac2764e63104$var$eachItem(xs, f) {\n    if (Array.isArray(xs)) for (const x of xs)f(x);\n    else f(xs);\n}\nmodule.exports.eachItem = $5457ac2764e63104$var$eachItem;\nfunction $5457ac2764e63104$var$makeMergeEvaluated({ mergeNames: mergeNames, mergeToName: mergeToName, mergeValues: mergeValues, resultToName: resultToName }) {\n    return (gen, from, to, toName)=>{\n        const res = to === undefined ? from : to instanceof $l2ufW.Name ? (from instanceof $l2ufW.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof $l2ufW.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);\n        return toName === $l2ufW.Name && !(res instanceof $l2ufW.Name) ? resultToName(gen, res) : res;\n    };\n}\nmodule.exports.mergeEvaluated = {\n    props: $5457ac2764e63104$var$makeMergeEvaluated({\n        mergeNames: (gen, from, to)=>gen.if((0, $l2ufW._)`${to} !== true && ${from} !== undefined`, ()=>{\n                gen.if((0, $l2ufW._)`${from} === true`, ()=>gen.assign(to, true), ()=>gen.assign(to, (0, $l2ufW._)`${to} || {}`).code((0, $l2ufW._)`Object.assign(${to}, ${from})`));\n            }),\n        mergeToName: (gen, from, to)=>gen.if((0, $l2ufW._)`${to} !== true`, ()=>{\n                if (from === true) gen.assign(to, true);\n                else {\n                    gen.assign(to, (0, $l2ufW._)`${to} || {}`);\n                    $5457ac2764e63104$var$setEvaluated(gen, to, from);\n                }\n            }),\n        mergeValues: (from, to)=>from === true ? true : {\n                ...from,\n                ...to\n            },\n        resultToName: $5457ac2764e63104$var$evaluatedPropsToName\n    }),\n    items: $5457ac2764e63104$var$makeMergeEvaluated({\n        mergeNames: (gen, from, to)=>gen.if((0, $l2ufW._)`${to} !== true && ${from} !== undefined`, ()=>gen.assign(to, (0, $l2ufW._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n        mergeToName: (gen, from, to)=>gen.if((0, $l2ufW._)`${to} !== true`, ()=>gen.assign(to, from === true ? true : (0, $l2ufW._)`${to} > ${from} ? ${to} : ${from}`)),\n        mergeValues: (from, to)=>from === true ? true : Math.max(from, to),\n        resultToName: (gen, items)=>gen.var(\"items\", items)\n    })\n};\nfunction $5457ac2764e63104$var$evaluatedPropsToName(gen, ps) {\n    if (ps === true) return gen.var(\"props\", true);\n    const props = gen.var(\"props\", (0, $l2ufW._)`{}`);\n    if (ps !== undefined) $5457ac2764e63104$var$setEvaluated(gen, props, ps);\n    return props;\n}\nmodule.exports.evaluatedPropsToName = $5457ac2764e63104$var$evaluatedPropsToName;\nfunction $5457ac2764e63104$var$setEvaluated(gen, props, ps) {\n    Object.keys(ps).forEach((p)=>gen.assign((0, $l2ufW._)`${props}${(0, $l2ufW.getProperty)(p)}`, true));\n}\nmodule.exports.setEvaluated = $5457ac2764e63104$var$setEvaluated;\nconst $5457ac2764e63104$var$snippets = {};\nfunction $5457ac2764e63104$var$useFunc(gen, f) {\n    return gen.scopeValue(\"func\", {\n        ref: f,\n        code: $5457ac2764e63104$var$snippets[f.code] || ($5457ac2764e63104$var$snippets[f.code] = new $4GpWJ._Code(f.code))\n    });\n}\nmodule.exports.useFunc = $5457ac2764e63104$var$useFunc;\nvar $5457ac2764e63104$var$Type;\n(function(Type) {\n    Type[Type[\"Num\"] = 0] = \"Num\";\n    Type[Type[\"Str\"] = 1] = \"Str\";\n})($5457ac2764e63104$var$Type = module.exports.Type || (module.exports.Type = {}));\nfunction $5457ac2764e63104$var$getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n    // let path\n    if (dataProp instanceof $l2ufW.Name) {\n        const isNumber = dataPropType === $5457ac2764e63104$var$Type.Num;\n        return jsPropertySyntax ? isNumber ? (0, $l2ufW._)`\"[\" + ${dataProp} + \"]\"` : (0, $l2ufW._)`\"['\" + ${dataProp} + \"']\"` : isNumber ? (0, $l2ufW._)`\"/\" + ${dataProp}` : (0, $l2ufW._)`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n    }\n    return jsPropertySyntax ? (0, $l2ufW.getProperty)(dataProp).toString() : \"/\" + $5457ac2764e63104$var$escapeJsonPointer(dataProp);\n}\nmodule.exports.getErrorPath = $5457ac2764e63104$var$getErrorPath;\nfunction $5457ac2764e63104$var$checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n    if (!mode) return;\n    msg = `strict mode: ${msg}`;\n    if (mode === true) throw new Error(msg);\n    it.self.logger.warn(msg);\n}\nmodule.exports.checkStrictMode = $5457ac2764e63104$var$checkStrictMode;\n\n});\n\nparcelRegister(\"dOpvc\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\nconst $a0e3ba1039b4828f$var$names = {\n    // validation function arguments\n    data: new $l2ufW.Name(\"data\"),\n    // args passed from referencing schema\n    valCxt: new $l2ufW.Name(\"valCxt\"),\n    instancePath: new $l2ufW.Name(\"instancePath\"),\n    parentData: new $l2ufW.Name(\"parentData\"),\n    parentDataProperty: new $l2ufW.Name(\"parentDataProperty\"),\n    rootData: new $l2ufW.Name(\"rootData\"),\n    dynamicAnchors: new $l2ufW.Name(\"dynamicAnchors\"),\n    // function scoped variables\n    vErrors: new $l2ufW.Name(\"vErrors\"),\n    errors: new $l2ufW.Name(\"errors\"),\n    this: new $l2ufW.Name(\"this\"),\n    // \"globals\"\n    self: new $l2ufW.Name(\"self\"),\n    scope: new $l2ufW.Name(\"scope\"),\n    // JTD serialize/parse name for JSON string and position\n    json: new $l2ufW.Name(\"json\"),\n    jsonPos: new $l2ufW.Name(\"jsonPos\"),\n    jsonLen: new $l2ufW.Name(\"jsonLen\"),\n    jsonPart: new $l2ufW.Name(\"jsonPart\")\n};\nmodule.exports.default = $a0e3ba1039b4828f$var$names;\n\n});\n\n\n\nparcelRegister(\"46MS3\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.reportTypeError = module.exports.checkDataTypes = module.exports.checkDataType = module.exports.coerceAndCheckDataType = module.exports.getJSONTypes = module.exports.getSchemaTypes = module.exports.DataType = void 0;\n\nvar $1sl6b = parcelRequire(\"1sl6b\");\n\nvar $9KPK3 = parcelRequire(\"9KPK3\");\n\nvar $hYgW9 = parcelRequire(\"hYgW9\");\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\nvar $2fdda1abbf4dbf9f$var$DataType;\n(function(DataType) {\n    DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n    DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})($2fdda1abbf4dbf9f$var$DataType = module.exports.DataType || (module.exports.DataType = {}));\nfunction $2fdda1abbf4dbf9f$var$getSchemaTypes(schema) {\n    const types = $2fdda1abbf4dbf9f$var$getJSONTypes(schema.type);\n    const hasNull = types.includes(\"null\");\n    if (hasNull) {\n        if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\");\n    } else {\n        if (!types.length && schema.nullable !== undefined) throw new Error('\"nullable\" cannot be used without \"type\"');\n        if (schema.nullable === true) types.push(\"null\");\n    }\n    return types;\n}\nmodule.exports.getSchemaTypes = $2fdda1abbf4dbf9f$var$getSchemaTypes;\nfunction $2fdda1abbf4dbf9f$var$getJSONTypes(ts) {\n    const types = Array.isArray(ts) ? ts : ts ? [\n        ts\n    ] : [];\n    if (types.every($1sl6b.isJSONType)) return types;\n    throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nmodule.exports.getJSONTypes = $2fdda1abbf4dbf9f$var$getJSONTypes;\nfunction $2fdda1abbf4dbf9f$var$coerceAndCheckDataType(it, types) {\n    const { gen: gen, data: data, opts: opts } = it;\n    const coerceTo = $2fdda1abbf4dbf9f$var$coerceToTypes(types, opts.coerceTypes);\n    const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, $9KPK3.schemaHasRulesForType)(it, types[0]));\n    if (checkTypes) {\n        const wrongType = $2fdda1abbf4dbf9f$var$checkDataTypes(types, data, opts.strictNumbers, $2fdda1abbf4dbf9f$var$DataType.Wrong);\n        gen.if(wrongType, ()=>{\n            if (coerceTo.length) $2fdda1abbf4dbf9f$var$coerceData(it, types, coerceTo);\n            else $2fdda1abbf4dbf9f$var$reportTypeError(it);\n        });\n    }\n    return checkTypes;\n}\nmodule.exports.coerceAndCheckDataType = $2fdda1abbf4dbf9f$var$coerceAndCheckDataType;\nconst $2fdda1abbf4dbf9f$var$COERCIBLE = new Set([\n    \"string\",\n    \"number\",\n    \"integer\",\n    \"boolean\",\n    \"null\"\n]);\nfunction $2fdda1abbf4dbf9f$var$coerceToTypes(types, coerceTypes) {\n    return coerceTypes ? types.filter((t)=>$2fdda1abbf4dbf9f$var$COERCIBLE.has(t) || coerceTypes === \"array\" && t === \"array\") : [];\n}\nfunction $2fdda1abbf4dbf9f$var$coerceData(it, types, coerceTo) {\n    const { gen: gen, data: data, opts: opts } = it;\n    const dataType = gen.let(\"dataType\", (0, $l2ufW._)`typeof ${data}`);\n    const coerced = gen.let(\"coerced\", (0, $l2ufW._)`undefined`);\n    if (opts.coerceTypes === \"array\") gen.if((0, $l2ufW._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, ()=>gen.assign(data, (0, $l2ufW._)`${data}[0]`).assign(dataType, (0, $l2ufW._)`typeof ${data}`).if($2fdda1abbf4dbf9f$var$checkDataTypes(types, data, opts.strictNumbers), ()=>gen.assign(coerced, data)));\n    gen.if((0, $l2ufW._)`${coerced} !== undefined`);\n    for (const t of coerceTo)if ($2fdda1abbf4dbf9f$var$COERCIBLE.has(t) || t === \"array\" && opts.coerceTypes === \"array\") coerceSpecificType(t);\n    gen.else();\n    $2fdda1abbf4dbf9f$var$reportTypeError(it);\n    gen.endIf();\n    gen.if((0, $l2ufW._)`${coerced} !== undefined`, ()=>{\n        gen.assign(data, coerced);\n        $2fdda1abbf4dbf9f$var$assignParentData(it, coerced);\n    });\n    function coerceSpecificType(t) {\n        switch(t){\n            case \"string\":\n                gen.elseIf((0, $l2ufW._)`${dataType} == \"number\" || ${dataType} == \"boolean\"`).assign(coerced, (0, $l2ufW._)`\"\" + ${data}`).elseIf((0, $l2ufW._)`${data} === null`).assign(coerced, (0, $l2ufW._)`\"\"`);\n                return;\n            case \"number\":\n                gen.elseIf((0, $l2ufW._)`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`).assign(coerced, (0, $l2ufW._)`+${data}`);\n                return;\n            case \"integer\":\n                gen.elseIf((0, $l2ufW._)`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, $l2ufW._)`+${data}`);\n                return;\n            case \"boolean\":\n                gen.elseIf((0, $l2ufW._)`${data} === \"false\" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, $l2ufW._)`${data} === \"true\" || ${data} === 1`).assign(coerced, true);\n                return;\n            case \"null\":\n                gen.elseIf((0, $l2ufW._)`${data} === \"\" || ${data} === 0 || ${data} === false`);\n                gen.assign(coerced, null);\n                return;\n            case \"array\":\n                gen.elseIf((0, $l2ufW._)`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`).assign(coerced, (0, $l2ufW._)`[${data}]`);\n        }\n    }\n}\nfunction $2fdda1abbf4dbf9f$var$assignParentData({ gen: gen, parentData: parentData, parentDataProperty: parentDataProperty }, expr) {\n    // TODO use gen.property\n    gen.if((0, $l2ufW._)`${parentData} !== undefined`, ()=>gen.assign((0, $l2ufW._)`${parentData}[${parentDataProperty}]`, expr));\n}\nfunction $2fdda1abbf4dbf9f$var$checkDataType(dataType, data, strictNums, correct = $2fdda1abbf4dbf9f$var$DataType.Correct) {\n    const EQ = correct === $2fdda1abbf4dbf9f$var$DataType.Correct ? $l2ufW.operators.EQ : $l2ufW.operators.NEQ;\n    let cond;\n    switch(dataType){\n        case \"null\":\n            return (0, $l2ufW._)`${data} ${EQ} null`;\n        case \"array\":\n            cond = (0, $l2ufW._)`Array.isArray(${data})`;\n            break;\n        case \"object\":\n            cond = (0, $l2ufW._)`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n            break;\n        case \"integer\":\n            cond = numCond((0, $l2ufW._)`!(${data} % 1) && !isNaN(${data})`);\n            break;\n        case \"number\":\n            cond = numCond();\n            break;\n        default:\n            return (0, $l2ufW._)`typeof ${data} ${EQ} ${dataType}`;\n    }\n    return correct === $2fdda1abbf4dbf9f$var$DataType.Correct ? cond : (0, $l2ufW.not)(cond);\n    function numCond(_cond = $l2ufW.nil) {\n        return (0, $l2ufW.and)((0, $l2ufW._)`typeof ${data} == \"number\"`, _cond, strictNums ? (0, $l2ufW._)`isFinite(${data})` : $l2ufW.nil);\n    }\n}\nmodule.exports.checkDataType = $2fdda1abbf4dbf9f$var$checkDataType;\nfunction $2fdda1abbf4dbf9f$var$checkDataTypes(dataTypes, data, strictNums, correct) {\n    if (dataTypes.length === 1) return $2fdda1abbf4dbf9f$var$checkDataType(dataTypes[0], data, strictNums, correct);\n    let cond;\n    const types = (0, $7eX5i.toHash)(dataTypes);\n    if (types.array && types.object) {\n        const notObj = (0, $l2ufW._)`typeof ${data} != \"object\"`;\n        cond = types.null ? notObj : (0, $l2ufW._)`!${data} || ${notObj}`;\n        delete types.null;\n        delete types.array;\n        delete types.object;\n    } else cond = $l2ufW.nil;\n    if (types.number) delete types.integer;\n    for(const t in types)cond = (0, $l2ufW.and)(cond, $2fdda1abbf4dbf9f$var$checkDataType(t, data, strictNums, correct));\n    return cond;\n}\nmodule.exports.checkDataTypes = $2fdda1abbf4dbf9f$var$checkDataTypes;\nconst $2fdda1abbf4dbf9f$var$typeError = {\n    message: ({ schema: schema })=>`must be ${schema}`,\n    params: ({ schema: schema, schemaValue: schemaValue })=>typeof schema == \"string\" ? (0, $l2ufW._)`{type: ${schema}}` : (0, $l2ufW._)`{type: ${schemaValue}}`\n};\nfunction $2fdda1abbf4dbf9f$var$reportTypeError(it) {\n    const cxt = $2fdda1abbf4dbf9f$var$getTypeErrorContext(it);\n    (0, $hYgW9.reportError)(cxt, $2fdda1abbf4dbf9f$var$typeError);\n}\nmodule.exports.reportTypeError = $2fdda1abbf4dbf9f$var$reportTypeError;\nfunction $2fdda1abbf4dbf9f$var$getTypeErrorContext(it) {\n    const { gen: gen, data: data, schema: schema } = it;\n    const schemaCode = (0, $7eX5i.schemaRefOrVal)(it, schema, \"type\");\n    return {\n        gen: gen,\n        keyword: \"type\",\n        data: data,\n        schema: schema.type,\n        schemaCode: schemaCode,\n        schemaValue: schemaCode,\n        parentSchema: schema,\n        params: {},\n        it: it\n    };\n}\n\n});\nparcelRegister(\"1sl6b\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.getRules = module.exports.isJSONType = void 0;\nconst $10f8c5b811d8a69e$var$_jsonTypes = [\n    \"string\",\n    \"number\",\n    \"integer\",\n    \"boolean\",\n    \"null\",\n    \"object\",\n    \"array\"\n];\nconst $10f8c5b811d8a69e$var$jsonTypes = new Set($10f8c5b811d8a69e$var$_jsonTypes);\nfunction $10f8c5b811d8a69e$var$isJSONType(x) {\n    return typeof x == \"string\" && $10f8c5b811d8a69e$var$jsonTypes.has(x);\n}\nmodule.exports.isJSONType = $10f8c5b811d8a69e$var$isJSONType;\nfunction $10f8c5b811d8a69e$var$getRules() {\n    const groups = {\n        number: {\n            type: \"number\",\n            rules: []\n        },\n        string: {\n            type: \"string\",\n            rules: []\n        },\n        array: {\n            type: \"array\",\n            rules: []\n        },\n        object: {\n            type: \"object\",\n            rules: []\n        }\n    };\n    return {\n        types: {\n            ...groups,\n            integer: true,\n            boolean: true,\n            null: true\n        },\n        rules: [\n            {\n                rules: []\n            },\n            groups.number,\n            groups.string,\n            groups.array,\n            groups.object\n        ],\n        post: {\n            rules: []\n        },\n        all: {},\n        keywords: {}\n    };\n}\nmodule.exports.getRules = $10f8c5b811d8a69e$var$getRules;\n\n});\n\nparcelRegister(\"9KPK3\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.shouldUseRule = module.exports.shouldUseGroup = module.exports.schemaHasRulesForType = void 0;\nfunction $71a08bc6f5a5bab9$var$schemaHasRulesForType({ schema: schema, self: self }, type) {\n    const group = self.RULES.types[type];\n    return group && group !== true && $71a08bc6f5a5bab9$var$shouldUseGroup(schema, group);\n}\nmodule.exports.schemaHasRulesForType = $71a08bc6f5a5bab9$var$schemaHasRulesForType;\nfunction $71a08bc6f5a5bab9$var$shouldUseGroup(schema, group) {\n    return group.rules.some((rule)=>$71a08bc6f5a5bab9$var$shouldUseRule(schema, rule));\n}\nmodule.exports.shouldUseGroup = $71a08bc6f5a5bab9$var$shouldUseGroup;\nfunction $71a08bc6f5a5bab9$var$shouldUseRule(schema, rule) {\n    var _a;\n    return schema[rule.keyword] !== undefined || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd)=>schema[kwd] !== undefined));\n}\nmodule.exports.shouldUseRule = $71a08bc6f5a5bab9$var$shouldUseRule;\n\n});\n\n\nparcelRegister(\"9OJAU\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.assignDefaults = void 0;\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\nfunction $725c26a0727ed10f$var$assignDefaults(it, ty) {\n    const { properties: properties, items: items } = it.schema;\n    if (ty === \"object\" && properties) for(const key in properties)$725c26a0727ed10f$var$assignDefault(it, key, properties[key].default);\n    else if (ty === \"array\" && Array.isArray(items)) items.forEach((sch, i)=>$725c26a0727ed10f$var$assignDefault(it, i, sch.default));\n}\nmodule.exports.assignDefaults = $725c26a0727ed10f$var$assignDefaults;\nfunction $725c26a0727ed10f$var$assignDefault(it, prop, defaultValue) {\n    const { gen: gen, compositeRule: compositeRule, data: data, opts: opts } = it;\n    if (defaultValue === undefined) return;\n    const childData = (0, $l2ufW._)`${data}${(0, $l2ufW.getProperty)(prop)}`;\n    if (compositeRule) {\n        (0, $7eX5i.checkStrictMode)(it, `default is ignored for: ${childData}`);\n        return;\n    }\n    let condition = (0, $l2ufW._)`${childData} === undefined`;\n    if (opts.useDefaults === \"empty\") condition = (0, $l2ufW._)`${condition} || ${childData} === null || ${childData} === \"\"`;\n    // `${childData} === undefined` +\n    // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n    gen.if(condition, (0, $l2ufW._)`${childData} = ${(0, $l2ufW.stringify)(defaultValue)}`);\n}\n\n});\n\nparcelRegister(\"dTewx\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.validateKeywordUsage = module.exports.validSchemaType = module.exports.funcKeywordCode = module.exports.macroKeywordCode = void 0;\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $dOpvc = parcelRequire(\"dOpvc\");\n\nvar $7unnO = parcelRequire(\"7unnO\");\n\nvar $hYgW9 = parcelRequire(\"hYgW9\");\nfunction $a1cbad90d3b10795$var$macroKeywordCode(cxt, def) {\n    const { gen: gen, keyword: keyword, schema: schema, parentSchema: parentSchema, it: it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = $a1cbad90d3b10795$var$useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: $l2ufW.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true\n    }, valid);\n    cxt.pass(valid, ()=>cxt.error(true));\n}\nmodule.exports.macroKeywordCode = $a1cbad90d3b10795$var$macroKeywordCode;\nfunction $a1cbad90d3b10795$var$funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen: gen, keyword: keyword, schema: schema, parentSchema: parentSchema, $data: $data, it: it } = cxt;\n    $a1cbad90d3b10795$var$checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = $a1cbad90d3b10795$var$useKeyword(gen, keyword, validate);\n    const valid = gen.let(\"valid\");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying) $a1cbad90d3b10795$var$modifyData(cxt);\n            reportErrs(()=>cxt.error());\n        } else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying) $a1cbad90d3b10795$var$modifyData(cxt);\n            reportErrs(()=>$a1cbad90d3b10795$var$addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(()=>assignValid((0, $l2ufW._)`await `), (e)=>gen.assign(valid, false).if((0, $l2ufW._)`${e} instanceof ${it.ValidationError}`, ()=>gen.assign(ruleErrs, (0, $l2ufW._)`${e}.errors`), ()=>gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = (0, $l2ufW._)`${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid($l2ufW.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? (0, $l2ufW._)`await ` : $l2ufW.nil) {\n        const passCxt = it.opts.passContext ? $dOpvc.default.this : $dOpvc.default.self;\n        const passSchema = !(\"compile\" in def && !$data || def.schema === false);\n        gen.assign(valid, (0, $l2ufW._)`${_await}${(0, $7unnO.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if((0, $l2ufW.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nmodule.exports.funcKeywordCode = $a1cbad90d3b10795$var$funcKeywordCode;\nfunction $a1cbad90d3b10795$var$modifyData(cxt) {\n    const { gen: gen, data: data, it: it } = cxt;\n    gen.if(it.parentData, ()=>gen.assign(data, (0, $l2ufW._)`${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction $a1cbad90d3b10795$var$addErrs(cxt, errs) {\n    const { gen: gen } = cxt;\n    gen.if((0, $l2ufW._)`Array.isArray(${errs})`, ()=>{\n        gen.assign($dOpvc.default.vErrors, (0, $l2ufW._)`${$dOpvc.default.vErrors} === null ? ${errs} : ${$dOpvc.default.vErrors}.concat(${errs})`).assign($dOpvc.default.errors, (0, $l2ufW._)`${$dOpvc.default.vErrors}.length`);\n        (0, $hYgW9.extendErrors)(cxt);\n    }, ()=>cxt.error());\n}\nfunction $a1cbad90d3b10795$var$checkAsyncKeyword({ schemaEnv: schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\");\n}\nfunction $a1cbad90d3b10795$var$useKeyword(gen, keyword, result) {\n    if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`);\n    return gen.scopeValue(\"keyword\", typeof result == \"function\" ? {\n        ref: result\n    } : {\n        ref: result,\n        code: (0, $l2ufW.stringify)(result)\n    });\n}\nfunction $a1cbad90d3b10795$var$validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return !schemaType.length || schemaType.some((st)=>st === \"array\" ? Array.isArray(schema) : st === \"object\" ? schema && typeof schema == \"object\" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == \"undefined\");\n}\nmodule.exports.validSchemaType = $a1cbad90d3b10795$var$validSchemaType;\nfunction $a1cbad90d3b10795$var$validateKeywordUsage({ schema: schema, opts: opts, self: self, errSchemaPath: errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */ if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) throw new Error(\"ajv implementation error\");\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd)=>!Object.prototype.hasOwnProperty.call(schema, kwd))) throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` + self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === \"log\") self.logger.error(msg);\n            else throw new Error(msg);\n        }\n    }\n}\nmodule.exports.validateKeywordUsage = $a1cbad90d3b10795$var$validateKeywordUsage;\n\n});\nparcelRegister(\"7unnO\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.validateUnion = module.exports.validateArray = module.exports.usePattern = module.exports.callValidateCode = module.exports.schemaProperties = module.exports.allSchemaProperties = module.exports.noPropertyInData = module.exports.propertyInData = module.exports.isOwnProperty = module.exports.hasPropFunc = module.exports.reportMissingProp = module.exports.checkMissingProp = module.exports.checkReportMissingProp = void 0;\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\n\nvar $dOpvc = parcelRequire(\"dOpvc\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\nfunction $573d792233d8638b$var$checkReportMissingProp(cxt, prop) {\n    const { gen: gen, data: data, it: it } = cxt;\n    gen.if($573d792233d8638b$var$noPropertyInData(gen, data, prop, it.opts.ownProperties), ()=>{\n        cxt.setParams({\n            missingProperty: (0, $l2ufW._)`${prop}`\n        }, true);\n        cxt.error();\n    });\n}\nmodule.exports.checkReportMissingProp = $573d792233d8638b$var$checkReportMissingProp;\nfunction $573d792233d8638b$var$checkMissingProp({ gen: gen, data: data, it: { opts: opts } }, properties, missing) {\n    return (0, $l2ufW.or)(...properties.map((prop)=>(0, $l2ufW.and)($573d792233d8638b$var$noPropertyInData(gen, data, prop, opts.ownProperties), (0, $l2ufW._)`${missing} = ${prop}`)));\n}\nmodule.exports.checkMissingProp = $573d792233d8638b$var$checkMissingProp;\nfunction $573d792233d8638b$var$reportMissingProp(cxt, missing) {\n    cxt.setParams({\n        missingProperty: missing\n    }, true);\n    cxt.error();\n}\nmodule.exports.reportMissingProp = $573d792233d8638b$var$reportMissingProp;\nfunction $573d792233d8638b$var$hasPropFunc(gen) {\n    return gen.scopeValue(\"func\", {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        ref: Object.prototype.hasOwnProperty,\n        code: (0, $l2ufW._)`Object.prototype.hasOwnProperty`\n    });\n}\nmodule.exports.hasPropFunc = $573d792233d8638b$var$hasPropFunc;\nfunction $573d792233d8638b$var$isOwnProperty(gen, data, property) {\n    return (0, $l2ufW._)`${$573d792233d8638b$var$hasPropFunc(gen)}.call(${data}, ${property})`;\n}\nmodule.exports.isOwnProperty = $573d792233d8638b$var$isOwnProperty;\nfunction $573d792233d8638b$var$propertyInData(gen, data, property, ownProperties) {\n    const cond = (0, $l2ufW._)`${data}${(0, $l2ufW.getProperty)(property)} !== undefined`;\n    return ownProperties ? (0, $l2ufW._)`${cond} && ${$573d792233d8638b$var$isOwnProperty(gen, data, property)}` : cond;\n}\nmodule.exports.propertyInData = $573d792233d8638b$var$propertyInData;\nfunction $573d792233d8638b$var$noPropertyInData(gen, data, property, ownProperties) {\n    const cond = (0, $l2ufW._)`${data}${(0, $l2ufW.getProperty)(property)} === undefined`;\n    return ownProperties ? (0, $l2ufW.or)(cond, (0, $l2ufW.not)($573d792233d8638b$var$isOwnProperty(gen, data, property))) : cond;\n}\nmodule.exports.noPropertyInData = $573d792233d8638b$var$noPropertyInData;\nfunction $573d792233d8638b$var$allSchemaProperties(schemaMap) {\n    return schemaMap ? Object.keys(schemaMap).filter((p)=>p !== \"__proto__\") : [];\n}\nmodule.exports.allSchemaProperties = $573d792233d8638b$var$allSchemaProperties;\nfunction $573d792233d8638b$var$schemaProperties(it, schemaMap) {\n    return $573d792233d8638b$var$allSchemaProperties(schemaMap).filter((p)=>!(0, $7eX5i.alwaysValidSchema)(it, schemaMap[p]));\n}\nmodule.exports.schemaProperties = $573d792233d8638b$var$schemaProperties;\nfunction $573d792233d8638b$var$callValidateCode({ schemaCode: schemaCode, data: data, it: { gen: gen, topSchemaRef: topSchemaRef, schemaPath: schemaPath, errorPath: errorPath }, it: it }, func, context, passSchema) {\n    const dataAndSchema = passSchema ? (0, $l2ufW._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;\n    const valCxt = [\n        [\n            $dOpvc.default.instancePath,\n            (0, $l2ufW.strConcat)($dOpvc.default.instancePath, errorPath)\n        ],\n        [\n            $dOpvc.default.parentData,\n            it.parentData\n        ],\n        [\n            $dOpvc.default.parentDataProperty,\n            it.parentDataProperty\n        ],\n        [\n            $dOpvc.default.rootData,\n            $dOpvc.default.rootData\n        ]\n    ];\n    if (it.opts.dynamicRef) valCxt.push([\n        $dOpvc.default.dynamicAnchors,\n        $dOpvc.default.dynamicAnchors\n    ]);\n    const args = (0, $l2ufW._)`${dataAndSchema}, ${gen.object(...valCxt)}`;\n    return context !== $l2ufW.nil ? (0, $l2ufW._)`${func}.call(${context}, ${args})` : (0, $l2ufW._)`${func}(${args})`;\n}\nmodule.exports.callValidateCode = $573d792233d8638b$var$callValidateCode;\nconst $573d792233d8638b$var$newRegExp = (0, $l2ufW._)`new RegExp`;\nfunction $573d792233d8638b$var$usePattern({ gen: gen, it: { opts: opts } }, pattern) {\n    const u = opts.unicodeRegExp ? \"u\" : \"\";\n    const { regExp: regExp } = opts.code;\n    const rx = regExp(pattern, u);\n    return gen.scopeValue(\"pattern\", {\n        key: rx.toString(),\n        ref: rx,\n        code: (0, $l2ufW._)`${regExp.code === \"new RegExp\" ? $573d792233d8638b$var$newRegExp : (0, $7eX5i.useFunc)(gen, regExp)}(${pattern}, ${u})`\n    });\n}\nmodule.exports.usePattern = $573d792233d8638b$var$usePattern;\nfunction $573d792233d8638b$var$validateArray(cxt) {\n    const { gen: gen, data: data, keyword: keyword, it: it } = cxt;\n    const valid = gen.name(\"valid\");\n    if (it.allErrors) {\n        const validArr = gen.let(\"valid\", true);\n        validateItems(()=>gen.assign(validArr, false));\n        return validArr;\n    }\n    gen.var(valid, true);\n    validateItems(()=>gen.break());\n    return valid;\n    function validateItems(notValid) {\n        const len = gen.const(\"len\", (0, $l2ufW._)`${data}.length`);\n        gen.forRange(\"i\", 0, len, (i)=>{\n            cxt.subschema({\n                keyword: keyword,\n                dataProp: i,\n                dataPropType: $7eX5i.Type.Num\n            }, valid);\n            gen.if((0, $l2ufW.not)(valid), notValid);\n        });\n    }\n}\nmodule.exports.validateArray = $573d792233d8638b$var$validateArray;\nfunction $573d792233d8638b$var$validateUnion(cxt) {\n    const { gen: gen, schema: schema, keyword: keyword, it: it } = cxt;\n    /* istanbul ignore if */ if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n    const alwaysValid = schema.some((sch)=>(0, $7eX5i.alwaysValidSchema)(it, sch));\n    if (alwaysValid && !it.opts.unevaluated) return;\n    const valid = gen.let(\"valid\", false);\n    const schValid = gen.name(\"_valid\");\n    gen.block(()=>schema.forEach((_sch, i)=>{\n            const schCxt = cxt.subschema({\n                keyword: keyword,\n                schemaProp: i,\n                compositeRule: true\n            }, schValid);\n            gen.assign(valid, (0, $l2ufW._)`${valid} || ${schValid}`);\n            const merged = cxt.mergeValidEvaluated(schCxt, schValid);\n            // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n            // or if all properties and items were evaluated (it.props === true && it.items === true)\n            if (!merged) gen.if((0, $l2ufW.not)(valid));\n        }));\n    cxt.result(valid, ()=>cxt.reset(), ()=>cxt.error(true));\n}\nmodule.exports.validateUnion = $573d792233d8638b$var$validateUnion;\n\n});\n\n\nparcelRegister(\"5eunN\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.extendSubschemaMode = module.exports.extendSubschemaData = module.exports.getSubschema = void 0;\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\nfunction $3cf5d3ecc8063845$var$getSubschema(it, { keyword: keyword, schemaProp: schemaProp, schema: schema, schemaPath: schemaPath, errSchemaPath: errSchemaPath, topSchemaRef: topSchemaRef }) {\n    if (keyword !== undefined && schema !== undefined) throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n    if (keyword !== undefined) {\n        const sch = it.schema[keyword];\n        return schemaProp === undefined ? {\n            schema: sch,\n            schemaPath: (0, $l2ufW._)`${it.schemaPath}${(0, $l2ufW.getProperty)(keyword)}`,\n            errSchemaPath: `${it.errSchemaPath}/${keyword}`\n        } : {\n            schema: sch[schemaProp],\n            schemaPath: (0, $l2ufW._)`${it.schemaPath}${(0, $l2ufW.getProperty)(keyword)}${(0, $l2ufW.getProperty)(schemaProp)}`,\n            errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, $7eX5i.escapeFragment)(schemaProp)}`\n        };\n    }\n    if (schema !== undefined) {\n        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n        return {\n            schema: schema,\n            schemaPath: schemaPath,\n            topSchemaRef: topSchemaRef,\n            errSchemaPath: errSchemaPath\n        };\n    }\n    throw new Error('either \"keyword\" or \"schema\" must be passed');\n}\nmodule.exports.getSubschema = $3cf5d3ecc8063845$var$getSubschema;\nfunction $3cf5d3ecc8063845$var$extendSubschemaData(subschema, it, { dataProp: dataProp, dataPropType: dpType, data: data, dataTypes: dataTypes, propertyName: propertyName }) {\n    if (data !== undefined && dataProp !== undefined) throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n    const { gen: gen } = it;\n    if (dataProp !== undefined) {\n        const { errorPath: errorPath, dataPathArr: dataPathArr, opts: opts } = it;\n        const nextData = gen.let(\"data\", (0, $l2ufW._)`${it.data}${(0, $l2ufW.getProperty)(dataProp)}`, true);\n        dataContextProps(nextData);\n        subschema.errorPath = (0, $l2ufW.str)`${errorPath}${(0, $7eX5i.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;\n        subschema.parentDataProperty = (0, $l2ufW._)`${dataProp}`;\n        subschema.dataPathArr = [\n            ...dataPathArr,\n            subschema.parentDataProperty\n        ];\n    }\n    if (data !== undefined) {\n        const nextData = data instanceof $l2ufW.Name ? data : gen.let(\"data\", data, true); // replaceable if used once?\n        dataContextProps(nextData);\n        if (propertyName !== undefined) subschema.propertyName = propertyName;\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n    }\n    if (dataTypes) subschema.dataTypes = dataTypes;\n    function dataContextProps(_nextData) {\n        subschema.data = _nextData;\n        subschema.dataLevel = it.dataLevel + 1;\n        subschema.dataTypes = [];\n        it.definedProperties = new Set();\n        subschema.parentData = it.data;\n        subschema.dataNames = [\n            ...it.dataNames,\n            _nextData\n        ];\n    }\n}\nmodule.exports.extendSubschemaData = $3cf5d3ecc8063845$var$extendSubschemaData;\nfunction $3cf5d3ecc8063845$var$extendSubschemaMode(subschema, { jtdDiscriminator: jtdDiscriminator, jtdMetadata: jtdMetadata, compositeRule: compositeRule, createErrors: createErrors, allErrors: allErrors }) {\n    if (compositeRule !== undefined) subschema.compositeRule = compositeRule;\n    if (createErrors !== undefined) subschema.createErrors = createErrors;\n    if (allErrors !== undefined) subschema.allErrors = allErrors;\n    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited\n    subschema.jtdMetadata = jtdMetadata; // not inherited\n}\nmodule.exports.extendSubschemaMode = $3cf5d3ecc8063845$var$extendSubschemaMode;\n\n});\n\nparcelRegister(\"9ZpNV\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.getSchemaRefs = module.exports.resolveUrl = module.exports.normalizeId = module.exports._getFullPath = module.exports.getFullPath = module.exports.inlineRef = void 0;\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\n\nvar $7hFx0 = parcelRequire(\"7hFx0\");\n\nvar $7dBhG = parcelRequire(\"7dBhG\");\n// TODO refactor to use keyword definitions\nconst $745dd3bb66238608$var$SIMPLE_INLINED = new Set([\n    \"type\",\n    \"format\",\n    \"pattern\",\n    \"maxLength\",\n    \"minLength\",\n    \"maxProperties\",\n    \"minProperties\",\n    \"maxItems\",\n    \"minItems\",\n    \"maximum\",\n    \"minimum\",\n    \"uniqueItems\",\n    \"multipleOf\",\n    \"required\",\n    \"enum\",\n    \"const\"\n]);\nfunction $745dd3bb66238608$var$inlineRef(schema, limit = true) {\n    if (typeof schema == \"boolean\") return true;\n    if (limit === true) return !$745dd3bb66238608$var$hasRef(schema);\n    if (!limit) return false;\n    return $745dd3bb66238608$var$countKeys(schema) <= limit;\n}\nmodule.exports.inlineRef = $745dd3bb66238608$var$inlineRef;\nconst $745dd3bb66238608$var$REF_KEYWORDS = new Set([\n    \"$ref\",\n    \"$recursiveRef\",\n    \"$recursiveAnchor\",\n    \"$dynamicRef\",\n    \"$dynamicAnchor\"\n]);\nfunction $745dd3bb66238608$var$hasRef(schema) {\n    for(const key in schema){\n        if ($745dd3bb66238608$var$REF_KEYWORDS.has(key)) return true;\n        const sch = schema[key];\n        if (Array.isArray(sch) && sch.some($745dd3bb66238608$var$hasRef)) return true;\n        if (typeof sch == \"object\" && $745dd3bb66238608$var$hasRef(sch)) return true;\n    }\n    return false;\n}\nfunction $745dd3bb66238608$var$countKeys(schema) {\n    let count = 0;\n    for(const key in schema){\n        if (key === \"$ref\") return Infinity;\n        count++;\n        if ($745dd3bb66238608$var$SIMPLE_INLINED.has(key)) continue;\n        if (typeof schema[key] == \"object\") (0, $7eX5i.eachItem)(schema[key], (sch)=>count += $745dd3bb66238608$var$countKeys(sch));\n        if (count === Infinity) return Infinity;\n    }\n    return count;\n}\nfunction $745dd3bb66238608$var$getFullPath(resolver, id = \"\", normalize) {\n    if (normalize !== false) id = $745dd3bb66238608$var$normalizeId(id);\n    const p = resolver.parse(id);\n    return $745dd3bb66238608$var$_getFullPath(resolver, p);\n}\nmodule.exports.getFullPath = $745dd3bb66238608$var$getFullPath;\nfunction $745dd3bb66238608$var$_getFullPath(resolver, p) {\n    const serialized = resolver.serialize(p);\n    return serialized.split(\"#\")[0] + \"#\";\n}\nmodule.exports._getFullPath = $745dd3bb66238608$var$_getFullPath;\nconst $745dd3bb66238608$var$TRAILING_SLASH_HASH = /#\\/?$/;\nfunction $745dd3bb66238608$var$normalizeId(id) {\n    return id ? id.replace($745dd3bb66238608$var$TRAILING_SLASH_HASH, \"\") : \"\";\n}\nmodule.exports.normalizeId = $745dd3bb66238608$var$normalizeId;\nfunction $745dd3bb66238608$var$resolveUrl(resolver, baseId, id) {\n    id = $745dd3bb66238608$var$normalizeId(id);\n    return resolver.resolve(baseId, id);\n}\nmodule.exports.resolveUrl = $745dd3bb66238608$var$resolveUrl;\nconst $745dd3bb66238608$var$ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction $745dd3bb66238608$var$getSchemaRefs(schema, baseId) {\n    if (typeof schema == \"boolean\") return {};\n    const { schemaId: schemaId, uriResolver: uriResolver } = this.opts;\n    const schId = $745dd3bb66238608$var$normalizeId(schema[schemaId] || baseId);\n    const baseIds = {\n        \"\": schId\n    };\n    const pathPrefix = $745dd3bb66238608$var$getFullPath(uriResolver, schId, false);\n    const localRefs = {};\n    const schemaRefs = new Set();\n    $7dBhG(schema, {\n        allKeys: true\n    }, (sch, jsonPtr, _, parentJsonPtr)=>{\n        if (parentJsonPtr === undefined) return;\n        const fullPath = pathPrefix + jsonPtr;\n        let baseId = baseIds[parentJsonPtr];\n        if (typeof sch[schemaId] == \"string\") baseId = addRef.call(this, sch[schemaId]);\n        addAnchor.call(this, sch.$anchor);\n        addAnchor.call(this, sch.$dynamicAnchor);\n        baseIds[jsonPtr] = baseId;\n        function addRef(ref) {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            const _resolve = this.opts.uriResolver.resolve;\n            ref = $745dd3bb66238608$var$normalizeId(baseId ? _resolve(baseId, ref) : ref);\n            if (schemaRefs.has(ref)) throw ambiguos(ref);\n            schemaRefs.add(ref);\n            let schOrRef = this.refs[ref];\n            if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef];\n            if (typeof schOrRef == \"object\") checkAmbiguosRef(sch, schOrRef.schema, ref);\n            else if (ref !== $745dd3bb66238608$var$normalizeId(fullPath)) {\n                if (ref[0] === \"#\") {\n                    checkAmbiguosRef(sch, localRefs[ref], ref);\n                    localRefs[ref] = sch;\n                } else this.refs[ref] = fullPath;\n            }\n            return ref;\n        }\n        function addAnchor(anchor) {\n            if (typeof anchor == \"string\") {\n                if (!$745dd3bb66238608$var$ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`);\n                addRef.call(this, `#${anchor}`);\n            }\n        }\n    });\n    return localRefs;\n    function checkAmbiguosRef(sch1, sch2, ref) {\n        if (sch2 !== undefined && !$7hFx0(sch1, sch2)) throw ambiguos(ref);\n    }\n    function ambiguos(ref) {\n        return new Error(`reference \"${ref}\" resolves to more than one schema`);\n    }\n}\nmodule.exports.getSchemaRefs = $745dd3bb66238608$var$getSchemaRefs;\n\n});\nparcelRegister(\"7hFx0\", function(module, exports) {\n\"use strict\";\n// do not edit .js files directly - edit src/index.jst\nmodule.exports = function equal(a, b) {\n    if (a === b) return true;\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        if (a.constructor !== b.constructor) return false;\n        var length, i, keys;\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length != b.length) return false;\n            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;\n            return true;\n        }\n        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) return false;\n        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n        for(i = length; i-- !== 0;){\n            var key = keys[i];\n            if (!equal(a[key], b[key])) return false;\n        }\n        return true;\n    }\n    // true if both NaN, false otherwise\n    return a !== a && b !== b;\n};\n\n});\n\nparcelRegister(\"7dBhG\", function(module, exports) {\n\"use strict\";\nvar $5416ab2f1394f8d9$var$traverse = module.exports = function(schema, opts, cb) {\n    // Legacy support for v0.3.1 and earlier.\n    if (typeof opts == \"function\") {\n        cb = opts;\n        opts = {};\n    }\n    cb = opts.cb || cb;\n    var pre = typeof cb == \"function\" ? cb : cb.pre || function() {};\n    var post = cb.post || function() {};\n    $5416ab2f1394f8d9$var$_traverse(opts, pre, post, schema, \"\", schema);\n};\n$5416ab2f1394f8d9$var$traverse.keywords = {\n    additionalItems: true,\n    items: true,\n    contains: true,\n    additionalProperties: true,\n    propertyNames: true,\n    not: true,\n    if: true,\n    then: true,\n    else: true\n};\n$5416ab2f1394f8d9$var$traverse.arrayKeywords = {\n    items: true,\n    allOf: true,\n    anyOf: true,\n    oneOf: true\n};\n$5416ab2f1394f8d9$var$traverse.propsKeywords = {\n    $defs: true,\n    definitions: true,\n    properties: true,\n    patternProperties: true,\n    dependencies: true\n};\n$5416ab2f1394f8d9$var$traverse.skipKeywords = {\n    default: true,\n    enum: true,\n    const: true,\n    required: true,\n    maximum: true,\n    minimum: true,\n    exclusiveMaximum: true,\n    exclusiveMinimum: true,\n    multipleOf: true,\n    maxLength: true,\n    minLength: true,\n    pattern: true,\n    format: true,\n    maxItems: true,\n    minItems: true,\n    uniqueItems: true,\n    maxProperties: true,\n    minProperties: true\n};\nfunction $5416ab2f1394f8d9$var$_traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n    if (schema && typeof schema == \"object\" && !Array.isArray(schema)) {\n        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n        for(var key in schema){\n            var sch = schema[key];\n            if (Array.isArray(sch)) {\n                if (key in $5416ab2f1394f8d9$var$traverse.arrayKeywords) for(var i = 0; i < sch.length; i++)$5416ab2f1394f8d9$var$_traverse(opts, pre, post, sch[i], jsonPtr + \"/\" + key + \"/\" + i, rootSchema, jsonPtr, key, schema, i);\n            } else if (key in $5416ab2f1394f8d9$var$traverse.propsKeywords) {\n                if (sch && typeof sch == \"object\") for(var prop in sch)$5416ab2f1394f8d9$var$_traverse(opts, pre, post, sch[prop], jsonPtr + \"/\" + key + \"/\" + $5416ab2f1394f8d9$var$escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n            } else if (key in $5416ab2f1394f8d9$var$traverse.keywords || opts.allKeys && !(key in $5416ab2f1394f8d9$var$traverse.skipKeywords)) $5416ab2f1394f8d9$var$_traverse(opts, pre, post, sch, jsonPtr + \"/\" + key, rootSchema, jsonPtr, key, schema);\n        }\n        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    }\n}\nfunction $5416ab2f1394f8d9$var$escapeJsonPtr(str) {\n    return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\n\n});\n\n\n\nparcelRegister(\"2gvZO\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nclass $1a65e520856caceb$var$ValidationError extends Error {\n    constructor(errors){\n        super(\"validation failed\");\n        this.errors = errors;\n        this.ajv = this.validation = true;\n    }\n}\nmodule.exports.default = $1a65e520856caceb$var$ValidationError;\n\n});\n\nparcelRegister(\"euTEo\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $9ZpNV = parcelRequire(\"9ZpNV\");\nclass $a8df090d24729250$var$MissingRefError extends Error {\n    constructor(resolver, baseId, ref, msg){\n        super(msg || `can't resolve reference ${ref} from id ${baseId}`);\n        this.missingRef = (0, $9ZpNV.resolveUrl)(resolver, baseId, ref);\n        this.missingSchema = (0, $9ZpNV.normalizeId)((0, $9ZpNV.getFullPath)(resolver, this.missingRef));\n    }\n}\nmodule.exports.default = $a8df090d24729250$var$MissingRefError;\n\n});\n\nparcelRegister(\"jstQR\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.resolveSchema = module.exports.getCompilingSchema = module.exports.resolveRef = module.exports.compileSchema = module.exports.SchemaEnv = void 0;\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $2gvZO = parcelRequire(\"2gvZO\");\n\nvar $dOpvc = parcelRequire(\"dOpvc\");\n\nvar $9ZpNV = parcelRequire(\"9ZpNV\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\n\nvar $9hgV1 = parcelRequire(\"9hgV1\");\nclass $e2a7c9c4276e8f03$var$SchemaEnv {\n    constructor(env){\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\") schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, $9ZpNV.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n    }\n}\nmodule.exports.SchemaEnv = $e2a7c9c4276e8f03$var$SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction $e2a7c9c4276e8f03$var$compileSchema(sch) {\n    // TODO refactor - remove compilations\n    const _sch = $e2a7c9c4276e8f03$var$getCompilingSchema.call(this, sch);\n    if (_sch) return _sch;\n    const rootId = (0, $9ZpNV.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n    const { es5: es5, lines: lines } = this.opts.code;\n    const { ownProperties: ownProperties } = this.opts;\n    const gen = new $l2ufW.CodeGen(this.scope, {\n        es5: es5,\n        lines: lines,\n        ownProperties: ownProperties\n    });\n    let _ValidationError;\n    if (sch.$async) _ValidationError = gen.scopeValue(\"Error\", {\n        ref: $2gvZO.default,\n        code: (0, $l2ufW._)`require(\"ajv/dist/runtime/validation_error\").default`\n    });\n    const validateName = gen.scopeName(\"validate\");\n    sch.validateName = validateName;\n    const schemaCxt = {\n        gen: gen,\n        allErrors: this.opts.allErrors,\n        data: $dOpvc.default.data,\n        parentData: $dOpvc.default.parentData,\n        parentDataProperty: $dOpvc.default.parentDataProperty,\n        dataNames: [\n            $dOpvc.default.data\n        ],\n        dataPathArr: [\n            $l2ufW.nil\n        ],\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true ? {\n            ref: sch.schema,\n            code: (0, $l2ufW.stringify)(sch.schema)\n        } : {\n            ref: sch.schema\n        }),\n        validateName: validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId: rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: $l2ufW.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: (0, $l2ufW._)`\"\"`,\n        opts: this.opts,\n        self: this\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        (0, $9hgV1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        // gen.optimize(1)\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs($dOpvc.default.scope)}return ${validateCode}`;\n        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n        if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n        const makeValidate = new Function(`${$dOpvc.default.self}`, `${$dOpvc.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, {\n            ref: validate\n        });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async) validate.$async = true;\n        if (this.opts.code.source === true) validate.source = {\n            validateName: validateName,\n            validateCode: validateCode,\n            scopeValues: gen._values\n        };\n        if (this.opts.unevaluated) {\n            const { props: props, items: items } = schemaCxt;\n            validate.evaluated = {\n                props: props instanceof $l2ufW.Name ? undefined : props,\n                items: items instanceof $l2ufW.Name ? undefined : items,\n                dynamicProps: props instanceof $l2ufW.Name,\n                dynamicItems: items instanceof $l2ufW.Name\n            };\n            if (validate.source) validate.source.evaluated = (0, $l2ufW.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n    } catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n        throw e;\n    } finally{\n        this._compilations.delete(sch);\n    }\n}\nmodule.exports.compileSchema = $e2a7c9c4276e8f03$var$compileSchema;\nfunction $e2a7c9c4276e8f03$var$resolveRef(root, baseId, ref) {\n    var _a;\n    ref = (0, $9ZpNV.resolveUrl)(this.opts.uriResolver, baseId, ref);\n    const schOrFunc = root.refs[ref];\n    if (schOrFunc) return schOrFunc;\n    let _sch = $e2a7c9c4276e8f03$var$resolve.call(this, root, ref);\n    if (_sch === undefined) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n        const { schemaId: schemaId } = this.opts;\n        if (schema) _sch = new $e2a7c9c4276e8f03$var$SchemaEnv({\n            schema: schema,\n            schemaId: schemaId,\n            root: root,\n            baseId: baseId\n        });\n    }\n    if (_sch === undefined) return;\n    return root.refs[ref] = $e2a7c9c4276e8f03$var$inlineOrCompile.call(this, _sch);\n}\nmodule.exports.resolveRef = $e2a7c9c4276e8f03$var$resolveRef;\nfunction $e2a7c9c4276e8f03$var$inlineOrCompile(sch) {\n    if ((0, $9ZpNV.inlineRef)(sch.schema, this.opts.inlineRefs)) return sch.schema;\n    return sch.validate ? sch : $e2a7c9c4276e8f03$var$compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction $e2a7c9c4276e8f03$var$getCompilingSchema(schEnv) {\n    for (const sch of this._compilations){\n        if ($e2a7c9c4276e8f03$var$sameSchemaEnv(sch, schEnv)) return sch;\n    }\n}\nmodule.exports.getCompilingSchema = $e2a7c9c4276e8f03$var$getCompilingSchema;\nfunction $e2a7c9c4276e8f03$var$sameSchemaEnv(s1, s2) {\n    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction $e2a7c9c4276e8f03$var$resolve(root, ref // reference to resolve\n) {\n    let sch;\n    while(typeof (sch = this.refs[ref]) == \"string\")ref = sch;\n    return sch || this.schemas[ref] || $e2a7c9c4276e8f03$var$resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction $e2a7c9c4276e8f03$var$resolveSchema(root, ref // reference to resolve\n) {\n    const p = this.opts.uriResolver.parse(ref);\n    const refPath = (0, $9ZpNV._getFullPath)(this.opts.uriResolver, p);\n    let baseId = (0, $9ZpNV.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n    if (Object.keys(root.schema).length > 0 && refPath === baseId) return $e2a7c9c4276e8f03$var$getJsonPointer.call(this, p, root);\n    const id = (0, $9ZpNV.normalizeId)(refPath);\n    const schOrRef = this.refs[id] || this.schemas[id];\n    if (typeof schOrRef == \"string\") {\n        const sch = $e2a7c9c4276e8f03$var$resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\") return;\n        return $e2a7c9c4276e8f03$var$getJsonPointer.call(this, p, sch);\n    }\n    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\") return;\n    if (!schOrRef.validate) $e2a7c9c4276e8f03$var$compileSchema.call(this, schOrRef);\n    if (id === (0, $9ZpNV.normalizeId)(ref)) {\n        const { schema: schema } = schOrRef;\n        const { schemaId: schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId) baseId = (0, $9ZpNV.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        return new $e2a7c9c4276e8f03$var$SchemaEnv({\n            schema: schema,\n            schemaId: schemaId,\n            root: root,\n            baseId: baseId\n        });\n    }\n    return $e2a7c9c4276e8f03$var$getJsonPointer.call(this, p, schOrRef);\n}\nmodule.exports.resolveSchema = $e2a7c9c4276e8f03$var$resolveSchema;\nconst $e2a7c9c4276e8f03$var$PREVENT_SCOPE_CHANGE = new Set([\n    \"properties\",\n    \"patternProperties\",\n    \"enum\",\n    \"dependencies\",\n    \"definitions\"\n]);\nfunction $e2a7c9c4276e8f03$var$getJsonPointer(parsedRef, { baseId: baseId, schema: schema, root: root }) {\n    var _a;\n    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\") return;\n    for (const part of parsedRef.fragment.slice(1).split(\"/\")){\n        if (typeof schema === \"boolean\") return;\n        const partSchema = schema[(0, $7eX5i.unescapeFragment)(part)];\n        if (partSchema === undefined) return;\n        schema = partSchema;\n        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n        const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n        if (!$e2a7c9c4276e8f03$var$PREVENT_SCOPE_CHANGE.has(part) && schId) baseId = (0, $9ZpNV.resolveUrl)(this.opts.uriResolver, baseId, schId);\n    }\n    let env;\n    if (typeof schema != \"boolean\" && schema.$ref && !(0, $7eX5i.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, $9ZpNV.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n        env = $e2a7c9c4276e8f03$var$resolveSchema.call(this, root, $ref);\n    }\n    // even though resolution failed we need to return SchemaEnv to throw exception\n    // so that compileAsync loads missing schema.\n    const { schemaId: schemaId } = this.opts;\n    env = env || new $e2a7c9c4276e8f03$var$SchemaEnv({\n        schema: schema,\n        schemaId: schemaId,\n        root: root,\n        baseId: baseId\n    });\n    if (env.schema !== env.root.schema) return env;\n    return undefined;\n}\n\n});\n\nparcelRegister(\"83wzf\", function(module, exports) {\nmodule.exports = JSON.parse('{\"$id\":\"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\"description\":\"Meta-schema for $data reference (JSON AnySchema extension proposal)\",\"type\":\"object\",\"required\":[\"$data\"],\"properties\":{\"$data\":{\"type\":\"string\",\"anyOf\":[{\"format\":\"relative-json-pointer\"},{\"format\":\"json-pointer\"}]}},\"additionalProperties\":false}');\n\n});\n\nparcelRegister(\"FaKkF\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $2h43S = parcelRequire(\"2h43S\");\n$2h43S.code = 'require(\"ajv/dist/runtime/uri\").default';\nmodule.exports.default = $2h43S;\n\n});\nparcelRegister(\"2h43S\", function(module, exports) {\n/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */ (function(global, factory) {\n    factory(module.exports);\n})(module.exports, function(exports1) {\n    \"use strict\";\n    function merge() {\n        for(var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++)sets[_key] = arguments[_key];\n        if (sets.length > 1) {\n            sets[0] = sets[0].slice(0, -1);\n            var xl = sets.length - 1;\n            for(var x = 1; x < xl; ++x)sets[x] = sets[x].slice(1, -1);\n            sets[xl] = sets[xl].slice(1);\n            return sets.join(\"\");\n        } else return sets[0];\n    }\n    function subexp(str) {\n        return \"(?:\" + str + \")\";\n    }\n    function typeOf(o) {\n        return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n    }\n    function toUpperCase(str) {\n        return str.toUpperCase();\n    }\n    function toArray(obj) {\n        return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [\n            obj\n        ] : Array.prototype.slice.call(obj) : [];\n    }\n    function assign(target, source) {\n        var obj = target;\n        if (source) for(var key in source)obj[key] = source[key];\n        return obj;\n    }\n    function buildExps(isIRI) {\n        var ALPHA$$ = \"[A-Za-z]\", CR$ = \"[\\\\x0D]\", DIGIT$$ = \"[0-9]\", DQUOTE$$ = \"[\\\\x22]\", HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"), //case-insensitive\n        LF$$ = \"[\\\\x0A]\", SP$$ = \"[\\\\x20]\", PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)), //expanded\n        GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\", SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\", //subset, excludes bidi control characters\n        IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\", //subset\n        UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"), DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$), //relaxed parsing rules\n        IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$ + \"{1,4}\"), LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), //                           6( h16 \":\" ) ls32\n        IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), //                      \"::\" 5( h16 \":\" ) ls32\n        IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n        IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n        IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n        IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$), //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n        IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$), //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n        IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$), //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n        IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"), //[ *6( h16 \":\" ) h16 ] \"::\"\n        IPV6ADDRESS$ = subexp([\n            IPV6ADDRESS1$,\n            IPV6ADDRESS2$,\n            IPV6ADDRESS3$,\n            IPV6ADDRESS4$,\n            IPV6ADDRESS5$,\n            IPV6ADDRESS6$,\n            IPV6ADDRESS7$,\n            IPV6ADDRESS8$,\n            IPV6ADDRESS9$\n        ].join(\"|\")), ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"), //RFC 6874\n        IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$), //RFC 6874\n        IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$), //RFC 6874, with relaxed parsing rules\n        IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"), IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"), //RFC 6874\n        REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"), HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$), PORT$ = subexp(DIGIT$$ + \"*\"), AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"), PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")), SEGMENT$ = subexp(PCHAR$ + \"*\"), SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"), PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"), PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"), //simplified\n        PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), //simplified\n        PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), //simplified\n        PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\", PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"), FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"), HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"), GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\", SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n        return {\n            NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n            NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n            NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n            ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n            OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n            PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n            IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n            IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n        };\n    }\n    var URI_PROTOCOL = buildExps(false);\n    var IRI_PROTOCOL = buildExps(true);\n    var slicedToArray = function() {\n        function sliceIterator(arr, i) {\n            var _arr = [];\n            var _n = true;\n            var _d = false;\n            var _e = undefined;\n            try {\n                for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                    _arr.push(_s.value);\n                    if (i && _arr.length === i) break;\n                }\n            } catch (err) {\n                _d = true;\n                _e = err;\n            } finally{\n                try {\n                    if (!_n && _i[\"return\"]) _i[\"return\"]();\n                } finally{\n                    if (_d) throw _e;\n                }\n            }\n            return _arr;\n        }\n        return function(arr, i) {\n            if (Array.isArray(arr)) return arr;\n            else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i);\n            else throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n        };\n    }();\n    var toConsumableArray = function(arr) {\n        if (Array.isArray(arr)) {\n            for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++)arr2[i] = arr[i];\n            return arr2;\n        } else return Array.from(arr);\n    };\n    /** Highest positive signed 32-bit float value */ var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n    /** Bootstring parameters */ var base = 36;\n    var tMin = 1;\n    var tMax = 26;\n    var skew = 38;\n    var damp = 700;\n    var initialBias = 72;\n    var initialN = 128; // 0x80\n    var delimiter = \"-\"; // '\\x2D'\n    /** Regular expressions */ var regexPunycode = /^xn--/;\n    var regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\n    var regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n    /** Error messages */ var errors = {\n        \"overflow\": \"Overflow: input needs wider integers to process\",\n        \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n        \"invalid-input\": \"Invalid input\"\n    };\n    /** Convenience shortcuts */ var baseMinusTMin = base - tMin;\n    var floor = Math.floor;\n    var stringFromCharCode = String.fromCharCode;\n    /*--------------------------------------------------------------------------*/ /**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */ function error$1(type) {\n        throw new RangeError(errors[type]);\n    }\n    /**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */ function map(array, fn) {\n        var result = [];\n        var length = array.length;\n        while(length--)result[length] = fn(array[length]);\n        return result;\n    }\n    /**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */ function mapDomain(string, fn) {\n        var parts = string.split(\"@\");\n        var result = \"\";\n        if (parts.length > 1) {\n            // In email addresses, only the domain name should be punycoded. Leave\n            // the local part (i.e. everything up to `@`) intact.\n            result = parts[0] + \"@\";\n            string = parts[1];\n        }\n        // Avoid `split(regex)` for IE8 compatibility. See #17.\n        string = string.replace(regexSeparators, \".\");\n        var labels = string.split(\".\");\n        var encoded = map(labels, fn).join(\".\");\n        return result + encoded;\n    }\n    /**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */ function ucs2decode(string) {\n        var output = [];\n        var counter = 0;\n        var length = string.length;\n        while(counter < length){\n            var value = string.charCodeAt(counter++);\n            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                // It's a high surrogate, and there is a next character.\n                var extra = string.charCodeAt(counter++);\n                if ((extra & 0xFC00) == 0xDC00) // Low surrogate.\n                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                else {\n                    // It's an unmatched surrogate; only append this code unit, in case the\n                    // next code unit is the high surrogate of a surrogate pair.\n                    output.push(value);\n                    counter--;\n                }\n            } else output.push(value);\n        }\n        return output;\n    }\n    /**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */ var ucs2encode = function ucs2encode(array) {\n        return String.fromCodePoint.apply(String, toConsumableArray(array));\n    };\n    /**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */ var basicToDigit = function basicToDigit(codePoint) {\n        if (codePoint - 0x30 < 0x0A) return codePoint - 0x16;\n        if (codePoint - 0x41 < 0x1A) return codePoint - 0x41;\n        if (codePoint - 0x61 < 0x1A) return codePoint - 0x61;\n        return base;\n    };\n    /**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */ var digitToBasic = function digitToBasic(digit, flag) {\n        //  0..25 map to ASCII a..z or A..Z\n        // 26..35 map to ASCII 0..9\n        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n    };\n    /**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */ var adapt = function adapt(delta, numPoints, firstTime) {\n        var k = 0;\n        delta = firstTime ? floor(delta / damp) : delta >> 1;\n        delta += floor(delta / numPoints);\n        for(; delta > baseMinusTMin * tMax >> 1; k += base)delta = floor(delta / baseMinusTMin);\n        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n    };\n    /**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */ var decode = function decode(input) {\n        // Don't use UCS-2.\n        var output = [];\n        var inputLength = input.length;\n        var i = 0;\n        var n = initialN;\n        var bias = initialBias;\n        // Handle the basic code points: let `basic` be the number of input code\n        // points before the last delimiter, or `0` if there is none, then copy\n        // the first basic code points to the output.\n        var basic = input.lastIndexOf(delimiter);\n        if (basic < 0) basic = 0;\n        for(var j = 0; j < basic; ++j){\n            // if it's not a basic code point\n            if (input.charCodeAt(j) >= 0x80) error$1(\"not-basic\");\n            output.push(input.charCodeAt(j));\n        }\n        // Main decoding loop: start just after the last delimiter if any basic code\n        // points were copied; start at the beginning otherwise.\n        for(var index = basic > 0 ? basic + 1 : 0; index < inputLength;)/* no final expression */ {\n            // `index` is the index of the next character to be consumed.\n            // Decode a generalized variable-length integer into `delta`,\n            // which gets added to `i`. The overflow checking is easier\n            // if we increase `i` as we go, then subtract off its starting\n            // value at the end to obtain `delta`.\n            var oldi = i;\n            for(var w = 1, k = base;; k += base){\n                if (index >= inputLength) error$1(\"invalid-input\");\n                var digit = basicToDigit(input.charCodeAt(index++));\n                if (digit >= base || digit > floor((maxInt - i) / w)) error$1(\"overflow\");\n                i += digit * w;\n                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                if (digit < t) break;\n                var baseMinusT = base - t;\n                if (w > floor(maxInt / baseMinusT)) error$1(\"overflow\");\n                w *= baseMinusT;\n            }\n            var out = output.length + 1;\n            bias = adapt(i - oldi, out, oldi == 0);\n            // `i` was supposed to wrap around from `out` to `0`,\n            // incrementing `n` each time, so we'll fix that now:\n            if (floor(i / out) > maxInt - n) error$1(\"overflow\");\n            n += floor(i / out);\n            i %= out;\n            // Insert `n` at position `i` of the output.\n            output.splice(i++, 0, n);\n        }\n        return String.fromCodePoint.apply(String, output);\n    };\n    /**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */ var encode = function encode(input) {\n        var output = [];\n        // Convert the input in UCS-2 to an array of Unicode code points.\n        input = ucs2decode(input);\n        // Cache the length.\n        var inputLength = input.length;\n        // Initialize the state.\n        var n = initialN;\n        var delta = 0;\n        var bias = initialBias;\n        // Handle the basic code points.\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n            for(var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var _currentValue2 = _step.value;\n                if (_currentValue2 < 0x80) output.push(stringFromCharCode(_currentValue2));\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) _iterator.return();\n            } finally{\n                if (_didIteratorError) throw _iteratorError;\n            }\n        }\n        var basicLength = output.length;\n        var handledCPCount = basicLength;\n        // `handledCPCount` is the number of code points that have been handled;\n        // `basicLength` is the number of basic code points.\n        // Finish the basic string with a delimiter unless it's empty.\n        if (basicLength) output.push(delimiter);\n        // Main encoding loop:\n        while(handledCPCount < inputLength){\n            // All non-basic code points < n have been handled already. Find the next\n            // larger one:\n            var m = maxInt;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n            try {\n                for(var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){\n                    var currentValue = _step2.value;\n                    if (currentValue >= n && currentValue < m) m = currentValue;\n                }\n            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n            // but guard against overflow.\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) _iterator2.return();\n                } finally{\n                    if (_didIteratorError2) throw _iteratorError2;\n                }\n            }\n            var handledCPCountPlusOne = handledCPCount + 1;\n            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) error$1(\"overflow\");\n            delta += (m - n) * handledCPCountPlusOne;\n            n = m;\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n            try {\n                for(var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){\n                    var _currentValue = _step3.value;\n                    if (_currentValue < n && ++delta > maxInt) error$1(\"overflow\");\n                    if (_currentValue == n) {\n                        // Represent delta as a generalized variable-length integer.\n                        var q = delta;\n                        for(var k = base;; k += base){\n                            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                            if (q < t) break;\n                            var qMinusT = q - t;\n                            var baseMinusT = base - t;\n                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                            q = floor(qMinusT / baseMinusT);\n                        }\n                        output.push(stringFromCharCode(digitToBasic(q, 0)));\n                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                        delta = 0;\n                        ++handledCPCount;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) _iterator3.return();\n                } finally{\n                    if (_didIteratorError3) throw _iteratorError3;\n                }\n            }\n            ++delta;\n            ++n;\n        }\n        return output.join(\"\");\n    };\n    /**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */ var toUnicode = function toUnicode(input) {\n        return mapDomain(input, function(string) {\n            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n        });\n    };\n    /**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */ var toASCII = function toASCII(input) {\n        return mapDomain(input, function(string) {\n            return regexNonASCII.test(string) ? \"xn--\" + encode(string) : string;\n        });\n    };\n    /*--------------------------------------------------------------------------*/ /** Define the public API */ var punycode = {\n        /**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */ \"version\": \"2.1.0\",\n        /**\n  * An object of methods to convert from JavaScript's internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */ \"ucs2\": {\n            \"decode\": ucs2decode,\n            \"encode\": ucs2encode\n        },\n        \"decode\": decode,\n        \"encode\": encode,\n        \"toASCII\": toASCII,\n        \"toUnicode\": toUnicode\n    };\n    /**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */ /**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */ var SCHEMES = {};\n    function pctEncChar(chr) {\n        var c = chr.charCodeAt(0);\n        var e = void 0;\n        if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();\n        else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();\n        else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n        else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n        return e;\n    }\n    function pctDecChars(str) {\n        var newStr = \"\";\n        var i = 0;\n        var il = str.length;\n        while(i < il){\n            var c = parseInt(str.substr(i + 1, 2), 16);\n            if (c < 128) {\n                newStr += String.fromCharCode(c);\n                i += 3;\n            } else if (c >= 194 && c < 224) {\n                if (il - i >= 6) {\n                    var c2 = parseInt(str.substr(i + 4, 2), 16);\n                    newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n                } else newStr += str.substr(i, 6);\n                i += 6;\n            } else if (c >= 224) {\n                if (il - i >= 9) {\n                    var _c = parseInt(str.substr(i + 4, 2), 16);\n                    var c3 = parseInt(str.substr(i + 7, 2), 16);\n                    newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n                } else newStr += str.substr(i, 9);\n                i += 9;\n            } else {\n                newStr += str.substr(i, 3);\n                i += 3;\n            }\n        }\n        return newStr;\n    }\n    function _normalizeComponentEncoding(components, protocol) {\n        function decodeUnreserved(str) {\n            var decStr = pctDecChars(str);\n            return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n        }\n        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n        if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        return components;\n    }\n    function _stripLeadingZeros(str) {\n        return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n    }\n    function _normalizeIPv4(host, protocol) {\n        var matches = host.match(protocol.IPV4ADDRESS) || [];\n        var _matches = slicedToArray(matches, 2), address = _matches[1];\n        if (address) return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n        else return host;\n    }\n    function _normalizeIPv6(host, protocol) {\n        var matches = host.match(protocol.IPV6ADDRESS) || [];\n        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];\n        if (address) {\n            var _address$toLowerCase$ = address.toLowerCase().split(\"::\").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];\n            var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n            var lastFields = last.split(\":\").map(_stripLeadingZeros);\n            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n            var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n            var lastFieldsStart = lastFields.length - fieldCount;\n            var fields = Array(fieldCount);\n            for(var x = 0; x < fieldCount; ++x)fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || \"\";\n            if (isLastFieldIPv4Address) fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n            var allZeroFields = fields.reduce(function(acc, field, index) {\n                if (!field || field === \"0\") {\n                    var lastLongest = acc[acc.length - 1];\n                    if (lastLongest && lastLongest.index + lastLongest.length === index) lastLongest.length++;\n                    else acc.push({\n                        index: index,\n                        length: 1\n                    });\n                }\n                return acc;\n            }, []);\n            var longestZeroFields = allZeroFields.sort(function(a, b) {\n                return b.length - a.length;\n            })[0];\n            var newHost = void 0;\n            if (longestZeroFields && longestZeroFields.length > 1) {\n                var newFirst = fields.slice(0, longestZeroFields.index);\n                var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n                newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n            } else newHost = fields.join(\":\");\n            if (zone) newHost += \"%\" + zone;\n            return newHost;\n        } else return host;\n    }\n    var URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\n    var NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\n    function parse(uriString) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var components = {};\n        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n        if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n        var matches = uriString.match(URI_PARSE);\n        if (matches) {\n            if (NO_MATCH_IS_UNDEFINED) {\n                //store each component\n                components.scheme = matches[1];\n                components.userinfo = matches[3];\n                components.host = matches[4];\n                components.port = parseInt(matches[5], 10);\n                components.path = matches[6] || \"\";\n                components.query = matches[7];\n                components.fragment = matches[8];\n                //fix port number\n                if (isNaN(components.port)) components.port = matches[5];\n            } else {\n                //IE FIX for improper RegExp matching\n                //store each component\n                components.scheme = matches[1] || undefined;\n                components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n                components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n                components.port = parseInt(matches[5], 10);\n                components.path = matches[6] || \"\";\n                components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n                components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n                //fix port number\n                if (isNaN(components.port)) components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n            }\n            if (components.host) //normalize IP hosts\n            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n            //determine reference type\n            if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) components.reference = \"same-document\";\n            else if (components.scheme === undefined) components.reference = \"relative\";\n            else if (components.fragment === undefined) components.reference = \"absolute\";\n            else components.reference = \"uri\";\n            //check for reference errors\n            if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n            //find scheme handler\n            var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n            //check if scheme can't handle IRIs\n            if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n                //if host component is a domain name\n                if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) //convert Unicode IDN -> ASCII IDN\n                try {\n                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n                //convert IRI -> URI\n                _normalizeComponentEncoding(components, URI_PROTOCOL);\n            } else //normalize encodings\n            _normalizeComponentEncoding(components, protocol);\n            //perform scheme specific parsing\n            if (schemeHandler && schemeHandler.parse) schemeHandler.parse(components, options);\n        } else components.error = components.error || \"URI can not be parsed.\";\n        return components;\n    }\n    function _recomposeAuthority(components, options) {\n        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n        var uriTokens = [];\n        if (components.userinfo !== undefined) {\n            uriTokens.push(components.userinfo);\n            uriTokens.push(\"@\");\n        }\n        if (components.host !== undefined) //normalize IP hosts, add brackets and escape zone separator for IPv6\n        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {\n            return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n        }));\n        if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n            uriTokens.push(\":\");\n            uriTokens.push(String(components.port));\n        }\n        return uriTokens.length ? uriTokens.join(\"\") : undefined;\n    }\n    var RDS1 = /^\\.\\.?\\//;\n    var RDS2 = /^\\/\\.(\\/|$)/;\n    var RDS3 = /^\\/\\.\\.(\\/|$)/;\n    var RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n    function removeDotSegments(input) {\n        var output = [];\n        while(input.length){\n            if (input.match(RDS1)) input = input.replace(RDS1, \"\");\n            else if (input.match(RDS2)) input = input.replace(RDS2, \"/\");\n            else if (input.match(RDS3)) {\n                input = input.replace(RDS3, \"/\");\n                output.pop();\n            } else if (input === \".\" || input === \"..\") input = \"\";\n            else {\n                var im = input.match(RDS5);\n                if (im) {\n                    var s = im[0];\n                    input = input.slice(s.length);\n                    output.push(s);\n                } else throw new Error(\"Unexpected dot segment condition\");\n            }\n        }\n        return output.join(\"\");\n    }\n    function serialize(components) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n        var uriTokens = [];\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //perform scheme specific serialization\n        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n        if (components.host) {\n            //if host component is an IPv6 address\n            if (protocol.IPV6ADDRESS.test(components.host)) ;\n            else if (options.domainHost || schemeHandler && schemeHandler.domainHost) //convert IDN via punycode\n            try {\n                components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n            } catch (e) {\n                components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n            }\n        }\n        //normalize encoding\n        _normalizeComponentEncoding(components, protocol);\n        if (options.reference !== \"suffix\" && components.scheme) {\n            uriTokens.push(components.scheme);\n            uriTokens.push(\":\");\n        }\n        var authority = _recomposeAuthority(components, options);\n        if (authority !== undefined) {\n            if (options.reference !== \"suffix\") uriTokens.push(\"//\");\n            uriTokens.push(authority);\n            if (components.path && components.path.charAt(0) !== \"/\") uriTokens.push(\"/\");\n        }\n        if (components.path !== undefined) {\n            var s = components.path;\n            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) s = removeDotSegments(s);\n            if (authority === undefined) s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n            uriTokens.push(s);\n        }\n        if (components.query !== undefined) {\n            uriTokens.push(\"?\");\n            uriTokens.push(components.query);\n        }\n        if (components.fragment !== undefined) {\n            uriTokens.push(\"#\");\n            uriTokens.push(components.fragment);\n        }\n        return uriTokens.join(\"\"); //merge tokens into a string\n    }\n    function resolveComponents(base, relative) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var skipNormalization = arguments[3];\n        var target = {};\n        if (!skipNormalization) {\n            base = parse(serialize(base, options), options); //normalize base components\n            relative = parse(serialize(relative, options), options); //normalize relative components\n        }\n        options = options || {};\n        if (!options.tolerant && relative.scheme) {\n            target.scheme = relative.scheme;\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        } else {\n            if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n                //target.authority = relative.authority;\n                target.userinfo = relative.userinfo;\n                target.host = relative.host;\n                target.port = relative.port;\n                target.path = removeDotSegments(relative.path || \"\");\n                target.query = relative.query;\n            } else {\n                if (!relative.path) {\n                    target.path = base.path;\n                    if (relative.query !== undefined) target.query = relative.query;\n                    else target.query = base.query;\n                } else {\n                    if (relative.path.charAt(0) === \"/\") target.path = removeDotSegments(relative.path);\n                    else {\n                        if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) target.path = \"/\" + relative.path;\n                        else if (!base.path) target.path = relative.path;\n                        else target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                        target.path = removeDotSegments(target.path);\n                    }\n                    target.query = relative.query;\n                }\n                //target.authority = base.authority;\n                target.userinfo = base.userinfo;\n                target.host = base.host;\n                target.port = base.port;\n            }\n            target.scheme = base.scheme;\n        }\n        target.fragment = relative.fragment;\n        return target;\n    }\n    function resolve(baseURI, relativeURI, options) {\n        var schemelessOptions = assign({\n            scheme: \"null\"\n        }, options);\n        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n    }\n    function normalize(uri, options) {\n        if (typeof uri === \"string\") uri = serialize(parse(uri, options), options);\n        else if (typeOf(uri) === \"object\") uri = parse(serialize(uri, options), options);\n        return uri;\n    }\n    function equal(uriA, uriB, options) {\n        if (typeof uriA === \"string\") uriA = serialize(parse(uriA, options), options);\n        else if (typeOf(uriA) === \"object\") uriA = serialize(uriA, options);\n        if (typeof uriB === \"string\") uriB = serialize(parse(uriB, options), options);\n        else if (typeOf(uriB) === \"object\") uriB = serialize(uriB, options);\n        return uriA === uriB;\n    }\n    function escapeComponent(str, options) {\n        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n    }\n    function unescapeComponent(str, options) {\n        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n    }\n    var handler = {\n        scheme: \"http\",\n        domainHost: true,\n        parse: function parse(components, options) {\n            //report missing host\n            if (!components.host) components.error = components.error || \"HTTP URIs must have a host.\";\n            return components;\n        },\n        serialize: function serialize(components, options) {\n            var secure = String(components.scheme).toLowerCase() === \"https\";\n            //normalize the default port\n            if (components.port === (secure ? 443 : 80) || components.port === \"\") components.port = undefined;\n            //normalize the empty path\n            if (!components.path) components.path = \"/\";\n            //NOTE: We do not parse query strings for HTTP URIs\n            //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n            //and not the HTTP spec.\n            return components;\n        }\n    };\n    var handler$1 = {\n        scheme: \"https\",\n        domainHost: handler.domainHost,\n        parse: handler.parse,\n        serialize: handler.serialize\n    };\n    function isSecure(wsComponents) {\n        return typeof wsComponents.secure === \"boolean\" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n    }\n    //RFC 6455\n    var handler$2 = {\n        scheme: \"ws\",\n        domainHost: true,\n        parse: function parse(components, options) {\n            var wsComponents = components;\n            //indicate if the secure flag is set\n            wsComponents.secure = isSecure(wsComponents);\n            //construct resouce name\n            wsComponents.resourceName = (wsComponents.path || \"/\") + (wsComponents.query ? \"?\" + wsComponents.query : \"\");\n            wsComponents.path = undefined;\n            wsComponents.query = undefined;\n            return wsComponents;\n        },\n        serialize: function serialize(wsComponents, options) {\n            //normalize the default port\n            if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") wsComponents.port = undefined;\n            //ensure scheme matches secure flag\n            if (typeof wsComponents.secure === \"boolean\") {\n                wsComponents.scheme = wsComponents.secure ? \"wss\" : \"ws\";\n                wsComponents.secure = undefined;\n            }\n            //reconstruct path from resource name\n            if (wsComponents.resourceName) {\n                var _wsComponents$resourc = wsComponents.resourceName.split(\"?\"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];\n                wsComponents.path = path && path !== \"/\" ? path : undefined;\n                wsComponents.query = query;\n                wsComponents.resourceName = undefined;\n            }\n            //forbid fragment component\n            wsComponents.fragment = undefined;\n            return wsComponents;\n        }\n    };\n    var handler$3 = {\n        scheme: \"wss\",\n        domainHost: handler$2.domainHost,\n        parse: handler$2.parse,\n        serialize: handler$2.serialize\n    };\n    var O = {};\n    var isIRI = true;\n    //RFC 3986\n    var UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\n    var HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\n    var PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n    //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n    //const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n    //const WSP$$ = \"[\\\\x20\\\\x09]\";\n    //const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n    //const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n    //const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n    //const WSP$$ = \"[\\\\x20\\\\x09]\";\n    //const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n    //const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n    //const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n    //const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\n    var ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n    var QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\n    var VCHAR$$ = merge(QTEXT$$, '[\\\\\"\\\\\\\\]');\n    var SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\n    var UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\n    var PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\n    var NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\n    var NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\n    var NOT_HFVALUE = NOT_HFNAME;\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(UNRESERVED) ? str : decStr;\n    }\n    var handler$4 = {\n        scheme: \"mailto\",\n        parse: function parse$$1(components, options) {\n            var mailtoComponents = components;\n            var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n            mailtoComponents.path = undefined;\n            if (mailtoComponents.query) {\n                var unknownHeaders = false;\n                var headers = {};\n                var hfields = mailtoComponents.query.split(\"&\");\n                for(var x = 0, xl = hfields.length; x < xl; ++x){\n                    var hfield = hfields[x].split(\"=\");\n                    switch(hfield[0]){\n                        case \"to\":\n                            var toAddrs = hfield[1].split(\",\");\n                            for(var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x)to.push(toAddrs[_x]);\n                            break;\n                        case \"subject\":\n                            mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                            break;\n                        case \"body\":\n                            mailtoComponents.body = unescapeComponent(hfield[1], options);\n                            break;\n                        default:\n                            unknownHeaders = true;\n                            headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                            break;\n                    }\n                }\n                if (unknownHeaders) mailtoComponents.headers = headers;\n            }\n            mailtoComponents.query = undefined;\n            for(var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2){\n                var addr = to[_x2].split(\"@\");\n                addr[0] = unescapeComponent(addr[0]);\n                if (!options.unicodeSupport) //convert Unicode IDN -> ASCII IDN\n                try {\n                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                } catch (e) {\n                    mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n                else addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n                to[_x2] = addr.join(\"@\");\n            }\n            return mailtoComponents;\n        },\n        serialize: function serialize$$1(mailtoComponents, options) {\n            var components = mailtoComponents;\n            var to = toArray(mailtoComponents.to);\n            if (to) {\n                for(var x = 0, xl = to.length; x < xl; ++x){\n                    var toAddr = String(to[x]);\n                    var atIdx = toAddr.lastIndexOf(\"@\");\n                    var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                    var domain = toAddr.slice(atIdx + 1);\n                    //convert IDN via punycode\n                    try {\n                        domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                    } catch (e) {\n                        components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                    }\n                    to[x] = localPart + \"@\" + domain;\n                }\n                components.path = to.join(\",\");\n            }\n            var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n            if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n            if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n            var fields = [];\n            for(var name in headers)if (headers[name] !== O[name]) fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n            if (fields.length) components.query = fields.join(\"&\");\n            return components;\n        }\n    };\n    var URN_PARSE = /^([^\\:]+)\\:(.*)/;\n    //RFC 2141\n    var handler$5 = {\n        scheme: \"urn\",\n        parse: function parse$$1(components, options) {\n            var matches = components.path && components.path.match(URN_PARSE);\n            var urnComponents = components;\n            if (matches) {\n                var scheme = options.scheme || urnComponents.scheme || \"urn\";\n                var nid = matches[1].toLowerCase();\n                var nss = matches[2];\n                var urnScheme = scheme + \":\" + (options.nid || nid);\n                var schemeHandler = SCHEMES[urnScheme];\n                urnComponents.nid = nid;\n                urnComponents.nss = nss;\n                urnComponents.path = undefined;\n                if (schemeHandler) urnComponents = schemeHandler.parse(urnComponents, options);\n            } else urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n            return urnComponents;\n        },\n        serialize: function serialize$$1(urnComponents, options) {\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n            var nid = urnComponents.nid;\n            var urnScheme = scheme + \":\" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            if (schemeHandler) urnComponents = schemeHandler.serialize(urnComponents, options);\n            var uriComponents = urnComponents;\n            var nss = urnComponents.nss;\n            uriComponents.path = (nid || options.nid) + \":\" + nss;\n            return uriComponents;\n        }\n    };\n    var UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n    //RFC 4122\n    var handler$6 = {\n        scheme: \"urn:uuid\",\n        parse: function parse(urnComponents, options) {\n            var uuidComponents = urnComponents;\n            uuidComponents.uuid = uuidComponents.nss;\n            uuidComponents.nss = undefined;\n            if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n            return uuidComponents;\n        },\n        serialize: function serialize(uuidComponents, options) {\n            var urnComponents = uuidComponents;\n            //normalize UUID\n            urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n            return urnComponents;\n        }\n    };\n    SCHEMES[handler.scheme] = handler;\n    SCHEMES[handler$1.scheme] = handler$1;\n    SCHEMES[handler$2.scheme] = handler$2;\n    SCHEMES[handler$3.scheme] = handler$3;\n    SCHEMES[handler$4.scheme] = handler$4;\n    SCHEMES[handler$5.scheme] = handler$5;\n    SCHEMES[handler$6.scheme] = handler$6;\n    exports1.SCHEMES = SCHEMES;\n    exports1.pctEncChar = pctEncChar;\n    exports1.pctDecChars = pctDecChars;\n    exports1.parse = parse;\n    exports1.removeDotSegments = removeDotSegments;\n    exports1.serialize = serialize;\n    exports1.resolveComponents = resolveComponents;\n    exports1.resolve = resolve;\n    exports1.normalize = normalize;\n    exports1.equal = equal;\n    exports1.escapeComponent = escapeComponent;\n    exports1.unescapeComponent = unescapeComponent;\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n});\n\n});\n\n\n\nparcelRegister(\"hHp9H\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $kt8nB = parcelRequire(\"kt8nB\");\n\nvar $9hSw4 = parcelRequire(\"9hSw4\");\n\nvar $8U9k8 = parcelRequire(\"8U9k8\");\n\nvar $kLdb8 = parcelRequire(\"kLdb8\");\n\nvar $koD8T = parcelRequire(\"koD8T\");\nconst $ce29f730388cb405$var$draft7Vocabularies = [\n    $kt8nB.default,\n    $9hSw4.default,\n    (0, $8U9k8.default)(),\n    $kLdb8.default,\n    $koD8T.metadataVocabulary,\n    $koD8T.contentVocabulary\n];\nmodule.exports.default = $ce29f730388cb405$var$draft7Vocabularies;\n\n});\nparcelRegister(\"kt8nB\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $6qsig = parcelRequire(\"6qsig\");\n\nvar $kw3FV = parcelRequire(\"kw3FV\");\nconst $ee6d041c7fe7d577$var$core = [\n    \"$schema\",\n    \"$id\",\n    \"$defs\",\n    \"$vocabulary\",\n    {\n        keyword: \"$comment\"\n    },\n    \"definitions\",\n    $6qsig.default,\n    $kw3FV.default\n];\nmodule.exports.default = $ee6d041c7fe7d577$var$core;\n\n});\nparcelRegister(\"6qsig\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nconst $4adb1e4936824bf9$var$def = {\n    keyword: \"id\",\n    code () {\n        throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID');\n    }\n};\nmodule.exports.default = $4adb1e4936824bf9$var$def;\n\n});\n\nparcelRegister(\"kw3FV\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.callRef = module.exports.getValidate = void 0;\n\nvar $euTEo = parcelRequire(\"euTEo\");\n\nvar $7unnO = parcelRequire(\"7unnO\");\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $dOpvc = parcelRequire(\"dOpvc\");\n\nvar $jstQR = parcelRequire(\"jstQR\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\nconst $eef9a5a25da20ed8$var$def = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code (cxt) {\n        const { gen: gen, schema: $ref, it: it } = cxt;\n        const { baseId: baseId, schemaEnv: env, validateName: validateName, opts: opts, self: self } = it;\n        const { root: root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef();\n        const schOrEnv = $jstQR.resolveRef.call(self, root, baseId, $ref);\n        if (schOrEnv === undefined) throw new $euTEo.default(it.opts.uriResolver, baseId, $ref);\n        if (schOrEnv instanceof $jstQR.SchemaEnv) return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n            if (env === root) return $eef9a5a25da20ed8$var$callRef(cxt, validateName, env, env.$async);\n            const rootName = gen.scopeValue(\"root\", {\n                ref: root\n            });\n            return $eef9a5a25da20ed8$var$callRef(cxt, (0, $l2ufW._)`${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n            const v = $eef9a5a25da20ed8$var$getValidate(cxt, sch);\n            $eef9a5a25da20ed8$var$callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n            const schName = gen.scopeValue(\"schema\", opts.code.source === true ? {\n                ref: sch,\n                code: (0, $l2ufW.stringify)(sch)\n            } : {\n                ref: sch\n            });\n            const valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({\n                schema: sch,\n                dataTypes: [],\n                schemaPath: $l2ufW.nil,\n                topSchemaRef: schName,\n                errSchemaPath: $ref\n            }, valid);\n            cxt.mergeEvaluated(schCxt);\n            cxt.ok(valid);\n        }\n    }\n};\nfunction $eef9a5a25da20ed8$var$getValidate(cxt, sch) {\n    const { gen: gen } = cxt;\n    return sch.validate ? gen.scopeValue(\"validate\", {\n        ref: sch.validate\n    }) : (0, $l2ufW._)`${gen.scopeValue(\"wrapper\", {\n        ref: sch\n    })}.validate`;\n}\nmodule.exports.getValidate = $eef9a5a25da20ed8$var$getValidate;\nfunction $eef9a5a25da20ed8$var$callRef(cxt, v, sch, $async) {\n    const { gen: gen, it: it } = cxt;\n    const { allErrors: allErrors, schemaEnv: env, opts: opts } = it;\n    const passCxt = opts.passContext ? $dOpvc.default.this : $l2ufW.nil;\n    if ($async) callAsyncRef();\n    else callSyncRef();\n    function callAsyncRef() {\n        if (!env.$async) throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(()=>{\n            gen.code((0, $l2ufW._)`await ${(0, $7unnO.callValidateCode)(cxt, v, passCxt)}`);\n            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n            if (!allErrors) gen.assign(valid, true);\n        }, (e)=>{\n            gen.if((0, $l2ufW._)`!(${e} instanceof ${it.ValidationError})`, ()=>gen.throw(e));\n            addErrorsFrom(e);\n            if (!allErrors) gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n    }\n    function callSyncRef() {\n        cxt.result((0, $7unnO.callValidateCode)(cxt, v, passCxt), ()=>addEvaluatedFrom(v), ()=>addErrorsFrom(v));\n    }\n    function addErrorsFrom(source) {\n        const errs = (0, $l2ufW._)`${source}.errors`;\n        gen.assign($dOpvc.default.vErrors, (0, $l2ufW._)`${$dOpvc.default.vErrors} === null ? ${errs} : ${$dOpvc.default.vErrors}.concat(${errs})`); // TODO tagged\n        gen.assign($dOpvc.default.errors, (0, $l2ufW._)`${$dOpvc.default.vErrors}.length`);\n    }\n    function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated) return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        // TODO refactor\n        if (it.props !== true) {\n            if (schEvaluated && !schEvaluated.dynamicProps) {\n                if (schEvaluated.props !== undefined) it.props = $7eX5i.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n            } else {\n                const props = gen.var(\"props\", (0, $l2ufW._)`${source}.evaluated.props`);\n                it.props = $7eX5i.mergeEvaluated.props(gen, props, it.props, $l2ufW.Name);\n            }\n        }\n        if (it.items !== true) {\n            if (schEvaluated && !schEvaluated.dynamicItems) {\n                if (schEvaluated.items !== undefined) it.items = $7eX5i.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n            } else {\n                const items = gen.var(\"items\", (0, $l2ufW._)`${source}.evaluated.items`);\n                it.items = $7eX5i.mergeEvaluated.items(gen, items, it.items, $l2ufW.Name);\n            }\n        }\n    }\n}\nmodule.exports.callRef = $eef9a5a25da20ed8$var$callRef;\nmodule.exports.default = $eef9a5a25da20ed8$var$def;\n\n});\n\n\nparcelRegister(\"9hSw4\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $3WoId = parcelRequire(\"3WoId\");\n\nvar $bUCRi = parcelRequire(\"bUCRi\");\n\nvar $Nqi0g = parcelRequire(\"Nqi0g\");\n\nvar $9V0CC = parcelRequire(\"9V0CC\");\n\nvar $3HmRG = parcelRequire(\"3HmRG\");\n\nvar $aQ9E5 = parcelRequire(\"aQ9E5\");\n\nvar $37rVP = parcelRequire(\"37rVP\");\n\nvar $1ObWf = parcelRequire(\"1ObWf\");\n\nvar $1jiSd = parcelRequire(\"1jiSd\");\n\nvar $6bLKD = parcelRequire(\"6bLKD\");\nconst $6c2ffd64a2866684$var$validation = [\n    // number\n    $3WoId.default,\n    $bUCRi.default,\n    // string\n    $Nqi0g.default,\n    $9V0CC.default,\n    // object\n    $3HmRG.default,\n    $aQ9E5.default,\n    // array\n    $37rVP.default,\n    $1ObWf.default,\n    // any\n    {\n        keyword: \"type\",\n        schemaType: [\n            \"string\",\n            \"array\"\n        ]\n    },\n    {\n        keyword: \"nullable\",\n        schemaType: \"boolean\"\n    },\n    $1jiSd.default,\n    $6bLKD.default\n];\nmodule.exports.default = $6c2ffd64a2866684$var$validation;\n\n});\nparcelRegister(\"3WoId\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\nconst $2de9f5322632f65d$var$ops = $l2ufW.operators;\nconst $2de9f5322632f65d$var$KWDs = {\n    maximum: {\n        okStr: \"<=\",\n        ok: $2de9f5322632f65d$var$ops.LTE,\n        fail: $2de9f5322632f65d$var$ops.GT\n    },\n    minimum: {\n        okStr: \">=\",\n        ok: $2de9f5322632f65d$var$ops.GTE,\n        fail: $2de9f5322632f65d$var$ops.LT\n    },\n    exclusiveMaximum: {\n        okStr: \"<\",\n        ok: $2de9f5322632f65d$var$ops.LT,\n        fail: $2de9f5322632f65d$var$ops.GTE\n    },\n    exclusiveMinimum: {\n        okStr: \">\",\n        ok: $2de9f5322632f65d$var$ops.GT,\n        fail: $2de9f5322632f65d$var$ops.LTE\n    }\n};\nconst $2de9f5322632f65d$var$error = {\n    message: ({ keyword: keyword, schemaCode: schemaCode })=>(0, $l2ufW.str)`must be ${$2de9f5322632f65d$var$KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword: keyword, schemaCode: schemaCode })=>(0, $l2ufW._)`{comparison: ${$2de9f5322632f65d$var$KWDs[keyword].okStr}, limit: ${schemaCode}}`\n};\nconst $2de9f5322632f65d$var$def = {\n    keyword: Object.keys($2de9f5322632f65d$var$KWDs),\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error: $2de9f5322632f65d$var$error,\n    code (cxt) {\n        const { keyword: keyword, data: data, schemaCode: schemaCode } = cxt;\n        cxt.fail$data((0, $l2ufW._)`${data} ${$2de9f5322632f65d$var$KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);\n    }\n};\nmodule.exports.default = $2de9f5322632f65d$var$def;\n\n});\n\nparcelRegister(\"bUCRi\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\nconst $8ac31129cbdb6091$var$error = {\n    message: ({ schemaCode: schemaCode })=>(0, $l2ufW.str)`must be multiple of ${schemaCode}`,\n    params: ({ schemaCode: schemaCode })=>(0, $l2ufW._)`{multipleOf: ${schemaCode}}`\n};\nconst $8ac31129cbdb6091$var$def = {\n    keyword: \"multipleOf\",\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error: $8ac31129cbdb6091$var$error,\n    code (cxt) {\n        const { gen: gen, data: data, schemaCode: schemaCode, it: it } = cxt;\n        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n        const prec = it.opts.multipleOfPrecision;\n        const res = gen.let(\"res\");\n        const invalid = prec ? (0, $l2ufW._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, $l2ufW._)`${res} !== parseInt(${res})`;\n        cxt.fail$data((0, $l2ufW._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);\n    }\n};\nmodule.exports.default = $8ac31129cbdb6091$var$def;\n\n});\n\nparcelRegister(\"Nqi0g\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\n\nvar $6BTyZ = parcelRequire(\"6BTyZ\");\nconst $0948f83d70ebc31d$var$error = {\n    message ({ keyword: keyword, schemaCode: schemaCode }) {\n        const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\";\n        return (0, $l2ufW.str)`must NOT have ${comp} than ${schemaCode} characters`;\n    },\n    params: ({ schemaCode: schemaCode })=>(0, $l2ufW._)`{limit: ${schemaCode}}`\n};\nconst $0948f83d70ebc31d$var$def = {\n    keyword: [\n        \"maxLength\",\n        \"minLength\"\n    ],\n    type: \"string\",\n    schemaType: \"number\",\n    $data: true,\n    error: $0948f83d70ebc31d$var$error,\n    code (cxt) {\n        const { keyword: keyword, data: data, schemaCode: schemaCode, it: it } = cxt;\n        const op = keyword === \"maxLength\" ? $l2ufW.operators.GT : $l2ufW.operators.LT;\n        const len = it.opts.unicode === false ? (0, $l2ufW._)`${data}.length` : (0, $l2ufW._)`${(0, $7eX5i.useFunc)(cxt.gen, $6BTyZ.default)}(${data})`;\n        cxt.fail$data((0, $l2ufW._)`${len} ${op} ${schemaCode}`);\n    }\n};\nmodule.exports.default = $0948f83d70ebc31d$var$def;\n\n});\nparcelRegister(\"6BTyZ\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nfunction $4d014c7f52d4c6e1$var$ucs2length(str) {\n    const len = str.length;\n    let length = 0;\n    let pos = 0;\n    let value;\n    while(pos < len){\n        length++;\n        value = str.charCodeAt(pos++);\n        if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n            // high surrogate, and there is a next character\n            value = str.charCodeAt(pos);\n            if ((value & 0xfc00) === 0xdc00) pos++; // low surrogate\n        }\n    }\n    return length;\n}\nmodule.exports.default = $4d014c7f52d4c6e1$var$ucs2length;\n$4d014c7f52d4c6e1$var$ucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default';\n\n});\n\n\nparcelRegister(\"9V0CC\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $7unnO = parcelRequire(\"7unnO\");\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\nconst $7389eb6c89297209$var$error = {\n    message: ({ schemaCode: schemaCode })=>(0, $l2ufW.str)`must match pattern \"${schemaCode}\"`,\n    params: ({ schemaCode: schemaCode })=>(0, $l2ufW._)`{pattern: ${schemaCode}}`\n};\nconst $7389eb6c89297209$var$def = {\n    keyword: \"pattern\",\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error: $7389eb6c89297209$var$error,\n    code (cxt) {\n        const { data: data, $data: $data, schema: schema, schemaCode: schemaCode, it: it } = cxt;\n        // TODO regexp should be wrapped in try/catchs\n        const u = it.opts.unicodeRegExp ? \"u\" : \"\";\n        const regExp = $data ? (0, $l2ufW._)`(new RegExp(${schemaCode}, ${u}))` : (0, $7unnO.usePattern)(cxt, schema);\n        cxt.fail$data((0, $l2ufW._)`!${regExp}.test(${data})`);\n    }\n};\nmodule.exports.default = $7389eb6c89297209$var$def;\n\n});\n\nparcelRegister(\"3HmRG\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\nconst $2b171fbd18b88a3a$var$error = {\n    message ({ keyword: keyword, schemaCode: schemaCode }) {\n        const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\";\n        return (0, $l2ufW.str)`must NOT have ${comp} than ${schemaCode} properties`;\n    },\n    params: ({ schemaCode: schemaCode })=>(0, $l2ufW._)`{limit: ${schemaCode}}`\n};\nconst $2b171fbd18b88a3a$var$def = {\n    keyword: [\n        \"maxProperties\",\n        \"minProperties\"\n    ],\n    type: \"object\",\n    schemaType: \"number\",\n    $data: true,\n    error: $2b171fbd18b88a3a$var$error,\n    code (cxt) {\n        const { keyword: keyword, data: data, schemaCode: schemaCode } = cxt;\n        const op = keyword === \"maxProperties\" ? $l2ufW.operators.GT : $l2ufW.operators.LT;\n        cxt.fail$data((0, $l2ufW._)`Object.keys(${data}).length ${op} ${schemaCode}`);\n    }\n};\nmodule.exports.default = $2b171fbd18b88a3a$var$def;\n\n});\n\nparcelRegister(\"aQ9E5\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $7unnO = parcelRequire(\"7unnO\");\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\nconst $7e463e1d6144c89a$var$error = {\n    message: ({ params: { missingProperty: missingProperty } })=>(0, $l2ufW.str)`must have required property '${missingProperty}'`,\n    params: ({ params: { missingProperty: missingProperty } })=>(0, $l2ufW._)`{missingProperty: ${missingProperty}}`\n};\nconst $7e463e1d6144c89a$var$def = {\n    keyword: \"required\",\n    type: \"object\",\n    schemaType: \"array\",\n    $data: true,\n    error: $7e463e1d6144c89a$var$error,\n    code (cxt) {\n        const { gen: gen, schema: schema, schemaCode: schemaCode, data: data, $data: $data, it: it } = cxt;\n        const { opts: opts } = it;\n        if (!$data && schema.length === 0) return;\n        const useLoop = schema.length >= opts.loopRequired;\n        if (it.allErrors) allErrorsMode();\n        else exitOnErrorMode();\n        if (opts.strictRequired) {\n            const props = cxt.parentSchema.properties;\n            const { definedProperties: definedProperties } = cxt.it;\n            for (const requiredKey of schema)if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n                const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n                const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n                (0, $7eX5i.checkStrictMode)(it, msg, it.opts.strictRequired);\n            }\n        }\n        function allErrorsMode() {\n            if (useLoop || $data) cxt.block$data($l2ufW.nil, loopAllRequired);\n            else for (const prop of schema)(0, $7unnO.checkReportMissingProp)(cxt, prop);\n        }\n        function exitOnErrorMode() {\n            const missing = gen.let(\"missing\");\n            if (useLoop || $data) {\n                const valid = gen.let(\"valid\", true);\n                cxt.block$data(valid, ()=>loopUntilMissing(missing, valid));\n                cxt.ok(valid);\n            } else {\n                gen.if((0, $7unnO.checkMissingProp)(cxt, schema, missing));\n                (0, $7unnO.reportMissingProp)(cxt, missing);\n                gen.else();\n            }\n        }\n        function loopAllRequired() {\n            gen.forOf(\"prop\", schemaCode, (prop)=>{\n                cxt.setParams({\n                    missingProperty: prop\n                });\n                gen.if((0, $7unnO.noPropertyInData)(gen, data, prop, opts.ownProperties), ()=>cxt.error());\n            });\n        }\n        function loopUntilMissing(missing, valid) {\n            cxt.setParams({\n                missingProperty: missing\n            });\n            gen.forOf(missing, schemaCode, ()=>{\n                gen.assign(valid, (0, $7unnO.propertyInData)(gen, data, missing, opts.ownProperties));\n                gen.if((0, $l2ufW.not)(valid), ()=>{\n                    cxt.error();\n                    gen.break();\n                });\n            }, $l2ufW.nil);\n        }\n    }\n};\nmodule.exports.default = $7e463e1d6144c89a$var$def;\n\n});\n\nparcelRegister(\"37rVP\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\nconst $2457b12e61a8fb9a$var$error = {\n    message ({ keyword: keyword, schemaCode: schemaCode }) {\n        const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\";\n        return (0, $l2ufW.str)`must NOT have ${comp} than ${schemaCode} items`;\n    },\n    params: ({ schemaCode: schemaCode })=>(0, $l2ufW._)`{limit: ${schemaCode}}`\n};\nconst $2457b12e61a8fb9a$var$def = {\n    keyword: [\n        \"maxItems\",\n        \"minItems\"\n    ],\n    type: \"array\",\n    schemaType: \"number\",\n    $data: true,\n    error: $2457b12e61a8fb9a$var$error,\n    code (cxt) {\n        const { keyword: keyword, data: data, schemaCode: schemaCode } = cxt;\n        const op = keyword === \"maxItems\" ? $l2ufW.operators.GT : $l2ufW.operators.LT;\n        cxt.fail$data((0, $l2ufW._)`${data}.length ${op} ${schemaCode}`);\n    }\n};\nmodule.exports.default = $2457b12e61a8fb9a$var$def;\n\n});\n\nparcelRegister(\"1ObWf\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $46MS3 = parcelRequire(\"46MS3\");\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\n\nvar $cMsoH = parcelRequire(\"cMsoH\");\nconst $1513b8ab19deb343$var$error = {\n    message: ({ params: { i: i, j: j } })=>(0, $l2ufW.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n    params: ({ params: { i: i, j: j } })=>(0, $l2ufW._)`{i: ${i}, j: ${j}}`\n};\nconst $1513b8ab19deb343$var$def = {\n    keyword: \"uniqueItems\",\n    type: \"array\",\n    schemaType: \"boolean\",\n    $data: true,\n    error: $1513b8ab19deb343$var$error,\n    code (cxt) {\n        const { gen: gen, data: data, $data: $data, schema: schema, parentSchema: parentSchema, schemaCode: schemaCode, it: it } = cxt;\n        if (!$data && !schema) return;\n        const valid = gen.let(\"valid\");\n        const itemTypes = parentSchema.items ? (0, $46MS3.getSchemaTypes)(parentSchema.items) : [];\n        cxt.block$data(valid, validateUniqueItems, (0, $l2ufW._)`${schemaCode} === false`);\n        cxt.ok(valid);\n        function validateUniqueItems() {\n            const i = gen.let(\"i\", (0, $l2ufW._)`${data}.length`);\n            const j = gen.let(\"j\");\n            cxt.setParams({\n                i: i,\n                j: j\n            });\n            gen.assign(valid, true);\n            gen.if((0, $l2ufW._)`${i} > 1`, ()=>(canOptimize() ? loopN : loopN2)(i, j));\n        }\n        function canOptimize() {\n            return itemTypes.length > 0 && !itemTypes.some((t)=>t === \"object\" || t === \"array\");\n        }\n        function loopN(i, j) {\n            const item = gen.name(\"item\");\n            const wrongType = (0, $46MS3.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, $46MS3.DataType.Wrong);\n            const indices = gen.const(\"indices\", (0, $l2ufW._)`{}`);\n            gen.for((0, $l2ufW._)`;${i}--;`, ()=>{\n                gen.let(item, (0, $l2ufW._)`${data}[${i}]`);\n                gen.if(wrongType, (0, $l2ufW._)`continue`);\n                if (itemTypes.length > 1) gen.if((0, $l2ufW._)`typeof ${item} == \"string\"`, (0, $l2ufW._)`${item} += \"_\"`);\n                gen.if((0, $l2ufW._)`typeof ${indices}[${item}] == \"number\"`, ()=>{\n                    gen.assign(j, (0, $l2ufW._)`${indices}[${item}]`);\n                    cxt.error();\n                    gen.assign(valid, false).break();\n                }).code((0, $l2ufW._)`${indices}[${item}] = ${i}`);\n            });\n        }\n        function loopN2(i, j) {\n            const eql = (0, $7eX5i.useFunc)(gen, $cMsoH.default);\n            const outer = gen.name(\"outer\");\n            gen.label(outer).for((0, $l2ufW._)`;${i}--;`, ()=>gen.for((0, $l2ufW._)`${j} = ${i}; ${j}--;`, ()=>gen.if((0, $l2ufW._)`${eql}(${data}[${i}], ${data}[${j}])`, ()=>{\n                        cxt.error();\n                        gen.assign(valid, false).break(outer);\n                    })));\n        }\n    }\n};\nmodule.exports.default = $1513b8ab19deb343$var$def;\n\n});\nparcelRegister(\"cMsoH\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $7hFx0 = parcelRequire(\"7hFx0\");\n$7hFx0.code = 'require(\"ajv/dist/runtime/equal\").default';\nmodule.exports.default = $7hFx0;\n\n});\n\n\nparcelRegister(\"1jiSd\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\n\nvar $cMsoH = parcelRequire(\"cMsoH\");\nconst $0f4634aee52087bc$var$error = {\n    message: \"must be equal to constant\",\n    params: ({ schemaCode: schemaCode })=>(0, $l2ufW._)`{allowedValue: ${schemaCode}}`\n};\nconst $0f4634aee52087bc$var$def = {\n    keyword: \"const\",\n    $data: true,\n    error: $0f4634aee52087bc$var$error,\n    code (cxt) {\n        const { gen: gen, data: data, $data: $data, schemaCode: schemaCode, schema: schema } = cxt;\n        if ($data || schema && typeof schema == \"object\") cxt.fail$data((0, $l2ufW._)`!${(0, $7eX5i.useFunc)(gen, $cMsoH.default)}(${data}, ${schemaCode})`);\n        else cxt.fail((0, $l2ufW._)`${schema} !== ${data}`);\n    }\n};\nmodule.exports.default = $0f4634aee52087bc$var$def;\n\n});\n\nparcelRegister(\"6bLKD\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\n\nvar $cMsoH = parcelRequire(\"cMsoH\");\nconst $4818cf8a0c8b5641$var$error = {\n    message: \"must be equal to one of the allowed values\",\n    params: ({ schemaCode: schemaCode })=>(0, $l2ufW._)`{allowedValues: ${schemaCode}}`\n};\nconst $4818cf8a0c8b5641$var$def = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: true,\n    error: $4818cf8a0c8b5641$var$error,\n    code (cxt) {\n        const { gen: gen, data: data, $data: $data, schema: schema, schemaCode: schemaCode, it: it } = cxt;\n        if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        let eql;\n        const getEql = ()=>eql !== null && eql !== void 0 ? eql : eql = (0, $7eX5i.useFunc)(gen, $cMsoH.default);\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let(\"valid\");\n            cxt.block$data(valid, loopEnum);\n        } else {\n            /* istanbul ignore if */ if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n            const vSchema = gen.const(\"vSchema\", schemaCode);\n            valid = (0, $l2ufW.or)(...schema.map((_x, i)=>equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf(\"v\", schemaCode, (v)=>gen.if((0, $l2ufW._)`${getEql()}(${data}, ${v})`, ()=>gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return typeof sch === \"object\" && sch !== null ? (0, $l2ufW._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, $l2ufW._)`${data} === ${sch}`;\n        }\n    }\n};\nmodule.exports.default = $4818cf8a0c8b5641$var$def;\n\n});\n\n\nparcelRegister(\"8U9k8\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $7FQbu = parcelRequire(\"7FQbu\");\n\nvar $9llPm = parcelRequire(\"9llPm\");\n\nvar $cNKK7 = parcelRequire(\"cNKK7\");\n\nvar $a2HBF = parcelRequire(\"a2HBF\");\n\nvar $2dY63 = parcelRequire(\"2dY63\");\n\nvar $ksuYJ = parcelRequire(\"ksuYJ\");\n\nvar $bXp0l = parcelRequire(\"bXp0l\");\n\nvar $8Wg07 = parcelRequire(\"8Wg07\");\n\nvar $iBNsK = parcelRequire(\"iBNsK\");\n\nvar $eSOrH = parcelRequire(\"eSOrH\");\n\nvar $62Mii = parcelRequire(\"62Mii\");\n\nvar $d3kOu = parcelRequire(\"d3kOu\");\n\nvar $gC5PA = parcelRequire(\"gC5PA\");\n\nvar $fhXQa = parcelRequire(\"fhXQa\");\n\nvar $jfpXQ = parcelRequire(\"jfpXQ\");\n\nvar $5HS6k = parcelRequire(\"5HS6k\");\nfunction $67bac937e8bbc1f1$var$getApplicator(draft2020 = false) {\n    const applicator = [\n        // any\n        $62Mii.default,\n        $d3kOu.default,\n        $gC5PA.default,\n        $fhXQa.default,\n        $jfpXQ.default,\n        $5HS6k.default,\n        // object\n        $bXp0l.default,\n        $8Wg07.default,\n        $ksuYJ.default,\n        $iBNsK.default,\n        $eSOrH.default\n    ];\n    // array\n    if (draft2020) applicator.push($9llPm.default, $a2HBF.default);\n    else applicator.push($7FQbu.default, $cNKK7.default);\n    applicator.push($2dY63.default);\n    return applicator;\n}\nmodule.exports.default = $67bac937e8bbc1f1$var$getApplicator;\n\n});\nparcelRegister(\"7FQbu\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.validateAdditionalItems = void 0;\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\nconst $5964d7729d257dac$var$error = {\n    message: ({ params: { len: len } })=>(0, $l2ufW.str)`must NOT have more than ${len} items`,\n    params: ({ params: { len: len } })=>(0, $l2ufW._)`{limit: ${len}}`\n};\nconst $5964d7729d257dac$var$def = {\n    keyword: \"additionalItems\",\n    type: \"array\",\n    schemaType: [\n        \"boolean\",\n        \"object\"\n    ],\n    before: \"uniqueItems\",\n    error: $5964d7729d257dac$var$error,\n    code (cxt) {\n        const { parentSchema: parentSchema, it: it } = cxt;\n        const { items: items } = parentSchema;\n        if (!Array.isArray(items)) {\n            (0, $7eX5i.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n            return;\n        }\n        $5964d7729d257dac$var$validateAdditionalItems(cxt, items);\n    }\n};\nfunction $5964d7729d257dac$var$validateAdditionalItems(cxt, items) {\n    const { gen: gen, schema: schema, data: data, keyword: keyword, it: it } = cxt;\n    it.items = true;\n    const len = gen.const(\"len\", (0, $l2ufW._)`${data}.length`);\n    if (schema === false) {\n        cxt.setParams({\n            len: items.length\n        });\n        cxt.pass((0, $l2ufW._)`${len} <= ${items.length}`);\n    } else if (typeof schema == \"object\" && !(0, $7eX5i.alwaysValidSchema)(it, schema)) {\n        const valid = gen.var(\"valid\", (0, $l2ufW._)`${len} <= ${items.length}`); // TODO var\n        gen.if((0, $l2ufW.not)(valid), ()=>validateItems(valid));\n        cxt.ok(valid);\n    }\n    function validateItems(valid) {\n        gen.forRange(\"i\", items.length, len, (i)=>{\n            cxt.subschema({\n                keyword: keyword,\n                dataProp: i,\n                dataPropType: $7eX5i.Type.Num\n            }, valid);\n            if (!it.allErrors) gen.if((0, $l2ufW.not)(valid), ()=>gen.break());\n        });\n    }\n}\nmodule.exports.validateAdditionalItems = $5964d7729d257dac$var$validateAdditionalItems;\nmodule.exports.default = $5964d7729d257dac$var$def;\n\n});\n\nparcelRegister(\"9llPm\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $cNKK7 = parcelRequire(\"cNKK7\");\nconst $6cd701aaf66b3db3$var$def = {\n    keyword: \"prefixItems\",\n    type: \"array\",\n    schemaType: [\n        \"array\"\n    ],\n    before: \"uniqueItems\",\n    code: (cxt)=>(0, $cNKK7.validateTuple)(cxt, \"items\")\n};\nmodule.exports.default = $6cd701aaf66b3db3$var$def;\n\n});\nparcelRegister(\"cNKK7\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.validateTuple = void 0;\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\n\nvar $7unnO = parcelRequire(\"7unnO\");\nconst $951e51c9b8ab42ca$var$def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\n        \"object\",\n        \"array\",\n        \"boolean\"\n    ],\n    before: \"uniqueItems\",\n    code (cxt) {\n        const { schema: schema, it: it } = cxt;\n        if (Array.isArray(schema)) return $951e51c9b8ab42ca$var$validateTuple(cxt, \"additionalItems\", schema);\n        it.items = true;\n        if ((0, $7eX5i.alwaysValidSchema)(it, schema)) return;\n        cxt.ok((0, $7unnO.validateArray)(cxt));\n    }\n};\nfunction $951e51c9b8ab42ca$var$validateTuple(cxt, extraItems, schArr = cxt.schema) {\n    const { gen: gen, parentSchema: parentSchema, data: data, keyword: keyword, it: it } = cxt;\n    checkStrictTuple(parentSchema);\n    if (it.opts.unevaluated && schArr.length && it.items !== true) it.items = $7eX5i.mergeEvaluated.items(gen, schArr.length, it.items);\n    const valid = gen.name(\"valid\");\n    const len = gen.const(\"len\", (0, $l2ufW._)`${data}.length`);\n    schArr.forEach((sch, i)=>{\n        if ((0, $7eX5i.alwaysValidSchema)(it, sch)) return;\n        gen.if((0, $l2ufW._)`${len} > ${i}`, ()=>cxt.subschema({\n                keyword: keyword,\n                schemaProp: i,\n                dataProp: i\n            }, valid));\n        cxt.ok(valid);\n    });\n    function checkStrictTuple(sch) {\n        const { opts: opts, errSchemaPath: errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n            const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n            (0, $7eX5i.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n    }\n}\nmodule.exports.validateTuple = $951e51c9b8ab42ca$var$validateTuple;\nmodule.exports.default = $951e51c9b8ab42ca$var$def;\n\n});\n\n\nparcelRegister(\"a2HBF\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\n\nvar $7unnO = parcelRequire(\"7unnO\");\n\nvar $7FQbu = parcelRequire(\"7FQbu\");\nconst $74fbeaa6b7e34267$var$error = {\n    message: ({ params: { len: len } })=>(0, $l2ufW.str)`must NOT have more than ${len} items`,\n    params: ({ params: { len: len } })=>(0, $l2ufW._)`{limit: ${len}}`\n};\nconst $74fbeaa6b7e34267$var$def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\n        \"object\",\n        \"boolean\"\n    ],\n    before: \"uniqueItems\",\n    error: $74fbeaa6b7e34267$var$error,\n    code (cxt) {\n        const { schema: schema, parentSchema: parentSchema, it: it } = cxt;\n        const { prefixItems: prefixItems } = parentSchema;\n        it.items = true;\n        if ((0, $7eX5i.alwaysValidSchema)(it, schema)) return;\n        if (prefixItems) (0, $7FQbu.validateAdditionalItems)(cxt, prefixItems);\n        else cxt.ok((0, $7unnO.validateArray)(cxt));\n    }\n};\nmodule.exports.default = $74fbeaa6b7e34267$var$def;\n\n});\n\nparcelRegister(\"2dY63\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\nconst $19eb69a255f3d502$var$error = {\n    message: ({ params: { min: min, max: max } })=>max === undefined ? (0, $l2ufW.str)`must contain at least ${min} valid item(s)` : (0, $l2ufW.str)`must contain at least ${min} and no more than ${max} valid item(s)`,\n    params: ({ params: { min: min, max: max } })=>max === undefined ? (0, $l2ufW._)`{minContains: ${min}}` : (0, $l2ufW._)`{minContains: ${min}, maxContains: ${max}}`\n};\nconst $19eb69a255f3d502$var$def = {\n    keyword: \"contains\",\n    type: \"array\",\n    schemaType: [\n        \"object\",\n        \"boolean\"\n    ],\n    before: \"uniqueItems\",\n    trackErrors: true,\n    error: $19eb69a255f3d502$var$error,\n    code (cxt) {\n        const { gen: gen, schema: schema, parentSchema: parentSchema, data: data, it: it } = cxt;\n        let min;\n        let max;\n        const { minContains: minContains, maxContains: maxContains } = parentSchema;\n        if (it.opts.next) {\n            min = minContains === undefined ? 1 : minContains;\n            max = maxContains;\n        } else min = 1;\n        const len = gen.const(\"len\", (0, $l2ufW._)`${data}.length`);\n        cxt.setParams({\n            min: min,\n            max: max\n        });\n        if (max === undefined && min === 0) {\n            (0, $7eX5i.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n            return;\n        }\n        if (max !== undefined && min > max) {\n            (0, $7eX5i.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n            cxt.fail();\n            return;\n        }\n        if ((0, $7eX5i.alwaysValidSchema)(it, schema)) {\n            let cond = (0, $l2ufW._)`${len} >= ${min}`;\n            if (max !== undefined) cond = (0, $l2ufW._)`${cond} && ${len} <= ${max}`;\n            cxt.pass(cond);\n            return;\n        }\n        it.items = true;\n        const valid = gen.name(\"valid\");\n        if (max === undefined && min === 1) validateItems(valid, ()=>gen.if(valid, ()=>gen.break()));\n        else if (min === 0) {\n            gen.let(valid, true);\n            if (max !== undefined) gen.if((0, $l2ufW._)`${data}.length > 0`, validateItemsWithCount);\n        } else {\n            gen.let(valid, false);\n            validateItemsWithCount();\n        }\n        cxt.result(valid, ()=>cxt.reset());\n        function validateItemsWithCount() {\n            const schValid = gen.name(\"_valid\");\n            const count = gen.let(\"count\", 0);\n            validateItems(schValid, ()=>gen.if(schValid, ()=>checkLimits(count)));\n        }\n        function validateItems(_valid, block) {\n            gen.forRange(\"i\", 0, len, (i)=>{\n                cxt.subschema({\n                    keyword: \"contains\",\n                    dataProp: i,\n                    dataPropType: $7eX5i.Type.Num,\n                    compositeRule: true\n                }, _valid);\n                block();\n            });\n        }\n        function checkLimits(count) {\n            gen.code((0, $l2ufW._)`${count}++`);\n            if (max === undefined) gen.if((0, $l2ufW._)`${count} >= ${min}`, ()=>gen.assign(valid, true).break());\n            else {\n                gen.if((0, $l2ufW._)`${count} > ${max}`, ()=>gen.assign(valid, false).break());\n                if (min === 1) gen.assign(valid, true);\n                else gen.if((0, $l2ufW._)`${count} >= ${min}`, ()=>gen.assign(valid, true));\n            }\n        }\n    }\n};\nmodule.exports.default = $19eb69a255f3d502$var$def;\n\n});\n\nparcelRegister(\"ksuYJ\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.validateSchemaDeps = module.exports.validatePropertyDeps = module.exports.error = void 0;\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\n\nvar $7unnO = parcelRequire(\"7unnO\");\nmodule.exports.error = {\n    message: ({ params: { property: property, depsCount: depsCount, deps: deps } })=>{\n        const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n        return (0, $l2ufW.str)`must have ${property_ies} ${deps} when property ${property} is present`;\n    },\n    params: ({ params: { property: property, depsCount: depsCount, deps: deps, missingProperty: missingProperty } })=>(0, $l2ufW._)`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`\n};\nconst $ee4e73e135a0dc71$var$def = {\n    keyword: \"dependencies\",\n    type: \"object\",\n    schemaType: \"object\",\n    error: module.exports.error,\n    code (cxt) {\n        const [propDeps, schDeps] = $ee4e73e135a0dc71$var$splitDependencies(cxt);\n        $ee4e73e135a0dc71$var$validatePropertyDeps(cxt, propDeps);\n        $ee4e73e135a0dc71$var$validateSchemaDeps(cxt, schDeps);\n    }\n};\nfunction $ee4e73e135a0dc71$var$splitDependencies({ schema: schema }) {\n    const propertyDeps = {};\n    const schemaDeps = {};\n    for(const key in schema){\n        if (key === \"__proto__\") continue;\n        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n        deps[key] = schema[key];\n    }\n    return [\n        propertyDeps,\n        schemaDeps\n    ];\n}\nfunction $ee4e73e135a0dc71$var$validatePropertyDeps(cxt, propertyDeps = cxt.schema) {\n    const { gen: gen, data: data, it: it } = cxt;\n    if (Object.keys(propertyDeps).length === 0) return;\n    const missing = gen.let(\"missing\");\n    for(const prop in propertyDeps){\n        const deps = propertyDeps[prop];\n        if (deps.length === 0) continue;\n        const hasProperty = (0, $7unnO.propertyInData)(gen, data, prop, it.opts.ownProperties);\n        cxt.setParams({\n            property: prop,\n            depsCount: deps.length,\n            deps: deps.join(\", \")\n        });\n        if (it.allErrors) gen.if(hasProperty, ()=>{\n            for (const depProp of deps)(0, $7unnO.checkReportMissingProp)(cxt, depProp);\n        });\n        else {\n            gen.if((0, $l2ufW._)`${hasProperty} && (${(0, $7unnO.checkMissingProp)(cxt, deps, missing)})`);\n            (0, $7unnO.reportMissingProp)(cxt, missing);\n            gen.else();\n        }\n    }\n}\nmodule.exports.validatePropertyDeps = $ee4e73e135a0dc71$var$validatePropertyDeps;\nfunction $ee4e73e135a0dc71$var$validateSchemaDeps(cxt, schemaDeps = cxt.schema) {\n    const { gen: gen, data: data, keyword: keyword, it: it } = cxt;\n    const valid = gen.name(\"valid\");\n    for(const prop in schemaDeps){\n        if ((0, $7eX5i.alwaysValidSchema)(it, schemaDeps[prop])) continue;\n        gen.if((0, $7unnO.propertyInData)(gen, data, prop, it.opts.ownProperties), ()=>{\n            const schCxt = cxt.subschema({\n                keyword: keyword,\n                schemaProp: prop\n            }, valid);\n            cxt.mergeValidEvaluated(schCxt, valid);\n        }, ()=>gen.var(valid, true) // TODO var\n        );\n        cxt.ok(valid);\n    }\n}\nmodule.exports.validateSchemaDeps = $ee4e73e135a0dc71$var$validateSchemaDeps;\nmodule.exports.default = $ee4e73e135a0dc71$var$def;\n\n});\n\nparcelRegister(\"bXp0l\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\nconst $8b4899c22aaf5c4d$var$error = {\n    message: \"property name must be valid\",\n    params: ({ params: params })=>(0, $l2ufW._)`{propertyName: ${params.propertyName}}`\n};\nconst $8b4899c22aaf5c4d$var$def = {\n    keyword: \"propertyNames\",\n    type: \"object\",\n    schemaType: [\n        \"object\",\n        \"boolean\"\n    ],\n    error: $8b4899c22aaf5c4d$var$error,\n    code (cxt) {\n        const { gen: gen, schema: schema, data: data, it: it } = cxt;\n        if ((0, $7eX5i.alwaysValidSchema)(it, schema)) return;\n        const valid = gen.name(\"valid\");\n        gen.forIn(\"key\", data, (key)=>{\n            cxt.setParams({\n                propertyName: key\n            });\n            cxt.subschema({\n                keyword: \"propertyNames\",\n                data: key,\n                dataTypes: [\n                    \"string\"\n                ],\n                propertyName: key,\n                compositeRule: true\n            }, valid);\n            gen.if((0, $l2ufW.not)(valid), ()=>{\n                cxt.error(true);\n                if (!it.allErrors) gen.break();\n            });\n        });\n        cxt.ok(valid);\n    }\n};\nmodule.exports.default = $8b4899c22aaf5c4d$var$def;\n\n});\n\nparcelRegister(\"8Wg07\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $7unnO = parcelRequire(\"7unnO\");\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $dOpvc = parcelRequire(\"dOpvc\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\nconst $682026f44715605d$var$error = {\n    message: \"must NOT have additional properties\",\n    params: ({ params: params })=>(0, $l2ufW._)`{additionalProperty: ${params.additionalProperty}}`\n};\nconst $682026f44715605d$var$def = {\n    keyword: \"additionalProperties\",\n    type: [\n        \"object\"\n    ],\n    schemaType: [\n        \"boolean\",\n        \"object\"\n    ],\n    allowUndefined: true,\n    trackErrors: true,\n    error: $682026f44715605d$var$error,\n    code (cxt) {\n        const { gen: gen, schema: schema, parentSchema: parentSchema, data: data, errsCount: errsCount, it: it } = cxt;\n        /* istanbul ignore if */ if (!errsCount) throw new Error(\"ajv implementation error\");\n        const { allErrors: allErrors, opts: opts } = it;\n        it.props = true;\n        if (opts.removeAdditional !== \"all\" && (0, $7eX5i.alwaysValidSchema)(it, schema)) return;\n        const props = (0, $7unnO.allSchemaProperties)(parentSchema.properties);\n        const patProps = (0, $7unnO.allSchemaProperties)(parentSchema.patternProperties);\n        checkAdditionalProperties();\n        cxt.ok((0, $l2ufW._)`${errsCount} === ${$dOpvc.default.errors}`);\n        function checkAdditionalProperties() {\n            gen.forIn(\"key\", data, (key)=>{\n                if (!props.length && !patProps.length) additionalPropertyCode(key);\n                else gen.if(isAdditional(key), ()=>additionalPropertyCode(key));\n            });\n        }\n        function isAdditional(key) {\n            let definedProp;\n            if (props.length > 8) {\n                // TODO maybe an option instead of hard-coded 8?\n                const propsSchema = (0, $7eX5i.schemaRefOrVal)(it, parentSchema.properties, \"properties\");\n                definedProp = (0, $7unnO.isOwnProperty)(gen, propsSchema, key);\n            } else if (props.length) definedProp = (0, $l2ufW.or)(...props.map((p)=>(0, $l2ufW._)`${key} === ${p}`));\n            else definedProp = $l2ufW.nil;\n            if (patProps.length) definedProp = (0, $l2ufW.or)(definedProp, ...patProps.map((p)=>(0, $l2ufW._)`${(0, $7unnO.usePattern)(cxt, p)}.test(${key})`));\n            return (0, $l2ufW.not)(definedProp);\n        }\n        function deleteAdditional(key) {\n            gen.code((0, $l2ufW._)`delete ${data}[${key}]`);\n        }\n        function additionalPropertyCode(key) {\n            if (opts.removeAdditional === \"all\" || opts.removeAdditional && schema === false) {\n                deleteAdditional(key);\n                return;\n            }\n            if (schema === false) {\n                cxt.setParams({\n                    additionalProperty: key\n                });\n                cxt.error();\n                if (!allErrors) gen.break();\n                return;\n            }\n            if (typeof schema == \"object\" && !(0, $7eX5i.alwaysValidSchema)(it, schema)) {\n                const valid = gen.name(\"valid\");\n                if (opts.removeAdditional === \"failing\") {\n                    applyAdditionalSchema(key, valid, false);\n                    gen.if((0, $l2ufW.not)(valid), ()=>{\n                        cxt.reset();\n                        deleteAdditional(key);\n                    });\n                } else {\n                    applyAdditionalSchema(key, valid);\n                    if (!allErrors) gen.if((0, $l2ufW.not)(valid), ()=>gen.break());\n                }\n            }\n        }\n        function applyAdditionalSchema(key, valid, errors) {\n            const subschema = {\n                keyword: \"additionalProperties\",\n                dataProp: key,\n                dataPropType: $7eX5i.Type.Str\n            };\n            if (errors === false) Object.assign(subschema, {\n                compositeRule: true,\n                createErrors: false,\n                allErrors: false\n            });\n            cxt.subschema(subschema, valid);\n        }\n    }\n};\nmodule.exports.default = $682026f44715605d$var$def;\n\n});\n\nparcelRegister(\"iBNsK\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $9hgV1 = parcelRequire(\"9hgV1\");\n\nvar $7unnO = parcelRequire(\"7unnO\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\n\nvar $8Wg07 = parcelRequire(\"8Wg07\");\nconst $d8c20cf8939dcc93$var$def = {\n    keyword: \"properties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code (cxt) {\n        const { gen: gen, schema: schema, parentSchema: parentSchema, data: data, it: it } = cxt;\n        if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) $8Wg07.default.code(new $9hgV1.KeywordCxt(it, $8Wg07.default, \"additionalProperties\"));\n        const allProps = (0, $7unnO.allSchemaProperties)(schema);\n        for (const prop of allProps)it.definedProperties.add(prop);\n        if (it.opts.unevaluated && allProps.length && it.props !== true) it.props = $7eX5i.mergeEvaluated.props(gen, (0, $7eX5i.toHash)(allProps), it.props);\n        const properties = allProps.filter((p)=>!(0, $7eX5i.alwaysValidSchema)(it, schema[p]));\n        if (properties.length === 0) return;\n        const valid = gen.name(\"valid\");\n        for (const prop of properties){\n            if (hasDefault(prop)) applyPropertySchema(prop);\n            else {\n                gen.if((0, $7unnO.propertyInData)(gen, data, prop, it.opts.ownProperties));\n                applyPropertySchema(prop);\n                if (!it.allErrors) gen.else().var(valid, true);\n                gen.endIf();\n            }\n            cxt.it.definedProperties.add(prop);\n            cxt.ok(valid);\n        }\n        function hasDefault(prop) {\n            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;\n        }\n        function applyPropertySchema(prop) {\n            cxt.subschema({\n                keyword: \"properties\",\n                schemaProp: prop,\n                dataProp: prop\n            }, valid);\n        }\n    }\n};\nmodule.exports.default = $d8c20cf8939dcc93$var$def;\n\n});\n\nparcelRegister(\"eSOrH\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $7unnO = parcelRequire(\"7unnO\");\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\nconst $ad5d3d4f26070f68$var$def = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code (cxt) {\n        const { gen: gen, schema: schema, data: data, parentSchema: parentSchema, it: it } = cxt;\n        const { opts: opts } = it;\n        const patterns = (0, $7unnO.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p)=>(0, $7eX5i.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) return;\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof $l2ufW.Name)) it.props = (0, $7eX5i.evaluatedPropsToName)(gen, it.props);\n        const { props: props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns){\n                if (checkProperties) checkMatchingProperties(pat);\n                if (it.allErrors) validateProperties(pat);\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for(const prop in checkProperties)if (new RegExp(pat).test(prop)) (0, $7eX5i.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n        }\n        function validateProperties(pat) {\n            gen.forIn(\"key\", data, (key)=>{\n                gen.if((0, $l2ufW._)`${(0, $7unnO.usePattern)(cxt, pat)}.test(${key})`, ()=>{\n                    const alwaysValid = alwaysValidPatterns.includes(pat);\n                    if (!alwaysValid) cxt.subschema({\n                        keyword: \"patternProperties\",\n                        schemaProp: pat,\n                        dataProp: key,\n                        dataPropType: $7eX5i.Type.Str\n                    }, valid);\n                    if (it.opts.unevaluated && props !== true) gen.assign((0, $l2ufW._)`${props}[${key}]`, true);\n                    else if (!alwaysValid && !it.allErrors) // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                    // or if all properties were evaluated (props === true)\n                    gen.if((0, $l2ufW.not)(valid), ()=>gen.break());\n                });\n            });\n        }\n    }\n};\nmodule.exports.default = $ad5d3d4f26070f68$var$def;\n\n});\n\nparcelRegister(\"62Mii\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\nconst $46686429bf9656cd$var$def = {\n    keyword: \"not\",\n    schemaType: [\n        \"object\",\n        \"boolean\"\n    ],\n    trackErrors: true,\n    code (cxt) {\n        const { gen: gen, schema: schema, it: it } = cxt;\n        if ((0, $7eX5i.alwaysValidSchema)(it, schema)) {\n            cxt.fail();\n            return;\n        }\n        const valid = gen.name(\"valid\");\n        cxt.subschema({\n            keyword: \"not\",\n            compositeRule: true,\n            createErrors: false,\n            allErrors: false\n        }, valid);\n        cxt.failResult(valid, ()=>cxt.reset(), ()=>cxt.error());\n    },\n    error: {\n        message: \"must NOT be valid\"\n    }\n};\nmodule.exports.default = $46686429bf9656cd$var$def;\n\n});\n\nparcelRegister(\"d3kOu\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $7unnO = parcelRequire(\"7unnO\");\nconst $980bb340f96346f4$var$def = {\n    keyword: \"anyOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    code: $7unnO.validateUnion,\n    error: {\n        message: \"must match a schema in anyOf\"\n    }\n};\nmodule.exports.default = $980bb340f96346f4$var$def;\n\n});\n\nparcelRegister(\"gC5PA\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\nconst $c184b7de888f90fb$var$error = {\n    message: \"must match exactly one schema in oneOf\",\n    params: ({ params: params })=>(0, $l2ufW._)`{passingSchemas: ${params.passing}}`\n};\nconst $c184b7de888f90fb$var$def = {\n    keyword: \"oneOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    error: $c184b7de888f90fb$var$error,\n    code (cxt) {\n        const { gen: gen, schema: schema, parentSchema: parentSchema, it: it } = cxt;\n        /* istanbul ignore if */ if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n        if (it.opts.discriminator && parentSchema.discriminator) return;\n        const schArr = schema;\n        const valid = gen.let(\"valid\", false);\n        const passing = gen.let(\"passing\", null);\n        const schValid = gen.name(\"_valid\");\n        cxt.setParams({\n            passing: passing\n        });\n        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n        gen.block(validateOneOf);\n        cxt.result(valid, ()=>cxt.reset(), ()=>cxt.error(true));\n        function validateOneOf() {\n            schArr.forEach((sch, i)=>{\n                let schCxt;\n                if ((0, $7eX5i.alwaysValidSchema)(it, sch)) gen.var(schValid, true);\n                else schCxt = cxt.subschema({\n                    keyword: \"oneOf\",\n                    schemaProp: i,\n                    compositeRule: true\n                }, schValid);\n                if (i > 0) gen.if((0, $l2ufW._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, $l2ufW._)`[${passing}, ${i}]`).else();\n                gen.if(schValid, ()=>{\n                    gen.assign(valid, true);\n                    gen.assign(passing, i);\n                    if (schCxt) cxt.mergeEvaluated(schCxt, $l2ufW.Name);\n                });\n            });\n        }\n    }\n};\nmodule.exports.default = $c184b7de888f90fb$var$def;\n\n});\n\nparcelRegister(\"fhXQa\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\nconst $b216dc95106535e4$var$def = {\n    keyword: \"allOf\",\n    schemaType: \"array\",\n    code (cxt) {\n        const { gen: gen, schema: schema, it: it } = cxt;\n        /* istanbul ignore if */ if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n        const valid = gen.name(\"valid\");\n        schema.forEach((sch, i)=>{\n            if ((0, $7eX5i.alwaysValidSchema)(it, sch)) return;\n            const schCxt = cxt.subschema({\n                keyword: \"allOf\",\n                schemaProp: i\n            }, valid);\n            cxt.ok(valid);\n            cxt.mergeEvaluated(schCxt);\n        });\n    }\n};\nmodule.exports.default = $b216dc95106535e4$var$def;\n\n});\n\nparcelRegister(\"jfpXQ\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\nconst $e0338efb54c30e45$var$error = {\n    message: ({ params: params })=>(0, $l2ufW.str)`must match \"${params.ifClause}\" schema`,\n    params: ({ params: params })=>(0, $l2ufW._)`{failingKeyword: ${params.ifClause}}`\n};\nconst $e0338efb54c30e45$var$def = {\n    keyword: \"if\",\n    schemaType: [\n        \"object\",\n        \"boolean\"\n    ],\n    trackErrors: true,\n    error: $e0338efb54c30e45$var$error,\n    code (cxt) {\n        const { gen: gen, parentSchema: parentSchema, it: it } = cxt;\n        if (parentSchema.then === undefined && parentSchema.else === undefined) (0, $7eX5i.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n        const hasThen = $e0338efb54c30e45$var$hasSchema(it, \"then\");\n        const hasElse = $e0338efb54c30e45$var$hasSchema(it, \"else\");\n        if (!hasThen && !hasElse) return;\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        validateIf();\n        cxt.reset();\n        if (hasThen && hasElse) {\n            const ifClause = gen.let(\"ifClause\");\n            cxt.setParams({\n                ifClause: ifClause\n            });\n            gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n        } else if (hasThen) gen.if(schValid, validateClause(\"then\"));\n        else gen.if((0, $l2ufW.not)(schValid), validateClause(\"else\"));\n        cxt.pass(valid, ()=>cxt.error(true));\n        function validateIf() {\n            const schCxt = cxt.subschema({\n                keyword: \"if\",\n                compositeRule: true,\n                createErrors: false,\n                allErrors: false\n            }, schValid);\n            cxt.mergeEvaluated(schCxt);\n        }\n        function validateClause(keyword, ifClause) {\n            return ()=>{\n                const schCxt = cxt.subschema({\n                    keyword: keyword\n                }, schValid);\n                gen.assign(valid, schValid);\n                cxt.mergeValidEvaluated(schCxt, valid);\n                if (ifClause) gen.assign(ifClause, (0, $l2ufW._)`${keyword}`);\n                else cxt.setParams({\n                    ifClause: keyword\n                });\n            };\n        }\n    }\n};\nfunction $e0338efb54c30e45$var$hasSchema(it, keyword) {\n    const schema = it.schema[keyword];\n    return schema !== undefined && !(0, $7eX5i.alwaysValidSchema)(it, schema);\n}\nmodule.exports.default = $e0338efb54c30e45$var$def;\n\n});\n\nparcelRegister(\"5HS6k\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\nconst $427aef3e960393f3$var$def = {\n    keyword: [\n        \"then\",\n        \"else\"\n    ],\n    schemaType: [\n        \"object\",\n        \"boolean\"\n    ],\n    code ({ keyword: keyword, parentSchema: parentSchema, it: it }) {\n        if (parentSchema.if === undefined) (0, $7eX5i.checkStrictMode)(it, `\"${keyword}\" without \"if\" is ignored`);\n    }\n};\nmodule.exports.default = $427aef3e960393f3$var$def;\n\n});\n\n\nparcelRegister(\"kLdb8\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $k9lk2 = parcelRequire(\"k9lk2\");\nconst $f1d26b70ddc76007$var$format = [\n    $k9lk2.default\n];\nmodule.exports.default = $f1d26b70ddc76007$var$format;\n\n});\nparcelRegister(\"k9lk2\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\nconst $eab5300bdea14c03$var$error = {\n    message: ({ schemaCode: schemaCode })=>(0, $l2ufW.str)`must match format \"${schemaCode}\"`,\n    params: ({ schemaCode: schemaCode })=>(0, $l2ufW._)`{format: ${schemaCode}}`\n};\nconst $eab5300bdea14c03$var$def = {\n    keyword: \"format\",\n    type: [\n        \"number\",\n        \"string\"\n    ],\n    schemaType: \"string\",\n    $data: true,\n    error: $eab5300bdea14c03$var$error,\n    code (cxt, ruleType) {\n        const { gen: gen, data: data, $data: $data, schema: schema, schemaCode: schemaCode, it: it } = cxt;\n        const { opts: opts, errSchemaPath: errSchemaPath, schemaEnv: schemaEnv, self: self } = it;\n        if (!opts.validateFormats) return;\n        if ($data) validate$DataFormat();\n        else validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats\n            });\n            const fDef = gen.const(\"fDef\", (0, $l2ufW._)`${fmts}[${schemaCode}]`);\n            const fType = gen.let(\"fType\");\n            const format = gen.let(\"format\");\n            // TODO simplify\n            gen.if((0, $l2ufW._)`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, ()=>gen.assign(fType, (0, $l2ufW._)`${fDef}.type || \"string\"`).assign(format, (0, $l2ufW._)`${fDef}.validate`), ()=>gen.assign(fType, (0, $l2ufW._)`\"string\"`).assign(format, fDef));\n            cxt.fail$data((0, $l2ufW.or)(unknownFmt(), invalidFmt()));\n            function unknownFmt() {\n                if (opts.strictSchema === false) return $l2ufW.nil;\n                return (0, $l2ufW._)`${schemaCode} && !${format}`;\n            }\n            function invalidFmt() {\n                const callFormat = schemaEnv.$async ? (0, $l2ufW._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, $l2ufW._)`${format}(${data})`;\n                const validData = (0, $l2ufW._)`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n                return (0, $l2ufW._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n            }\n        }\n        function validateFormat() {\n            const formatDef = self.formats[schema];\n            if (!formatDef) {\n                unknownFormat();\n                return;\n            }\n            if (formatDef === true) return;\n            const [fmtType, format, fmtRef] = getFormat(formatDef);\n            if (fmtType === ruleType) cxt.pass(validCondition());\n            function unknownFormat() {\n                if (opts.strictSchema === false) {\n                    self.logger.warn(unknownMsg());\n                    return;\n                }\n                throw new Error(unknownMsg());\n                function unknownMsg() {\n                    return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n                }\n            }\n            function getFormat(fmtDef) {\n                const code = fmtDef instanceof RegExp ? (0, $l2ufW.regexpCode)(fmtDef) : opts.code.formats ? (0, $l2ufW._)`${opts.code.formats}${(0, $l2ufW.getProperty)(schema)}` : undefined;\n                const fmt = gen.scopeValue(\"formats\", {\n                    key: schema,\n                    ref: fmtDef,\n                    code: code\n                });\n                if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) return [\n                    fmtDef.type || \"string\",\n                    fmtDef.validate,\n                    (0, $l2ufW._)`${fmt}.validate`\n                ];\n                return [\n                    \"string\",\n                    fmtDef,\n                    fmt\n                ];\n            }\n            function validCondition() {\n                if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n                    if (!schemaEnv.$async) throw new Error(\"async format in sync schema\");\n                    return (0, $l2ufW._)`await ${fmtRef}(${data})`;\n                }\n                return typeof format == \"function\" ? (0, $l2ufW._)`${fmtRef}(${data})` : (0, $l2ufW._)`${fmtRef}.test(${data})`;\n            }\n        }\n    }\n};\nmodule.exports.default = $eab5300bdea14c03$var$def;\n\n});\n\n\nparcelRegister(\"koD8T\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.contentVocabulary = module.exports.metadataVocabulary = void 0;\nmodule.exports.metadataVocabulary = [\n    \"title\",\n    \"description\",\n    \"default\",\n    \"deprecated\",\n    \"readOnly\",\n    \"writeOnly\",\n    \"examples\"\n];\nmodule.exports.contentVocabulary = [\n    \"contentMediaType\",\n    \"contentEncoding\",\n    \"contentSchema\"\n];\n\n});\n\n\nparcelRegister(\"81ULr\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\nvar $l2ufW = parcelRequire(\"l2ufW\");\n\nvar $6x7md = parcelRequire(\"6x7md\");\n\nvar $jstQR = parcelRequire(\"jstQR\");\n\nvar $7eX5i = parcelRequire(\"7eX5i\");\nconst $5d8a72e3f593aa35$var$error = {\n    message: ({ params: { discrError: discrError, tagName: tagName } })=>discrError === $6x7md.DiscrError.Tag ? `tag \"${tagName}\" must be string` : `value of tag \"${tagName}\" must be in oneOf`,\n    params: ({ params: { discrError: discrError, tag: tag, tagName: tagName } })=>(0, $l2ufW._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`\n};\nconst $5d8a72e3f593aa35$var$def = {\n    keyword: \"discriminator\",\n    type: \"object\",\n    schemaType: \"object\",\n    error: $5d8a72e3f593aa35$var$error,\n    code (cxt) {\n        const { gen: gen, data: data, schema: schema, parentSchema: parentSchema, it: it } = cxt;\n        const { oneOf: oneOf } = parentSchema;\n        if (!it.opts.discriminator) throw new Error(\"discriminator: requires discriminator option\");\n        const tagName = schema.propertyName;\n        if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\");\n        if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\");\n        if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\");\n        const valid = gen.let(\"valid\", false);\n        const tag = gen.const(\"tag\", (0, $l2ufW._)`${data}${(0, $l2ufW.getProperty)(tagName)}`);\n        gen.if((0, $l2ufW._)`typeof ${tag} == \"string\"`, ()=>validateMapping(), ()=>cxt.error(false, {\n                discrError: $6x7md.DiscrError.Tag,\n                tag: tag,\n                tagName: tagName\n            }));\n        cxt.ok(valid);\n        function validateMapping() {\n            const mapping = getMapping();\n            gen.if(false);\n            for(const tagValue in mapping){\n                gen.elseIf((0, $l2ufW._)`${tag} === ${tagValue}`);\n                gen.assign(valid, applyTagSchema(mapping[tagValue]));\n            }\n            gen.else();\n            cxt.error(false, {\n                discrError: $6x7md.DiscrError.Mapping,\n                tag: tag,\n                tagName: tagName\n            });\n            gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n            const _valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({\n                keyword: \"oneOf\",\n                schemaProp: schemaProp\n            }, _valid);\n            cxt.mergeEvaluated(schCxt, $l2ufW.Name);\n            return _valid;\n        }\n        function getMapping() {\n            var _a;\n            const oneOfMapping = {};\n            const topRequired = hasRequired(parentSchema);\n            let tagRequired = true;\n            for(let i = 0; i < oneOf.length; i++){\n                let sch = oneOf[i];\n                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, $7eX5i.schemaHasRulesButRef)(sch, it.self.RULES)) {\n                    sch = $jstQR.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);\n                    if (sch instanceof $jstQR.SchemaEnv) sch = sch.schema;\n                }\n                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n                if (typeof propSch != \"object\") throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n                tagRequired = tagRequired && (topRequired || hasRequired(sch));\n                addMappings(propSch, i);\n            }\n            if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`);\n            return oneOfMapping;\n            function hasRequired({ required: required }) {\n                return Array.isArray(required) && required.includes(tagName);\n            }\n            function addMappings(sch, i) {\n                if (sch.const) addMapping(sch.const, i);\n                else if (sch.enum) for (const tagValue of sch.enum)addMapping(tagValue, i);\n                else throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n            }\n            function addMapping(tagValue, i) {\n                if (typeof tagValue != \"string\" || tagValue in oneOfMapping) throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n                oneOfMapping[tagValue] = i;\n            }\n        }\n    }\n};\nmodule.exports.default = $5d8a72e3f593aa35$var$def;\n\n});\nparcelRegister(\"6x7md\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.DiscrError = void 0;\nvar $4c1b8829d2a29cc7$var$DiscrError;\n(function(DiscrError) {\n    DiscrError[\"Tag\"] = \"tag\";\n    DiscrError[\"Mapping\"] = \"mapping\";\n})($4c1b8829d2a29cc7$var$DiscrError = module.exports.DiscrError || (module.exports.DiscrError = {}));\n\n});\n\n\nparcelRegister(\"BbyF4\", function(module, exports) {\nmodule.exports = JSON.parse('{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$id\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"Core schema meta-schema\",\"definitions\":{\"schemaArray\":{\"type\":\"array\",\"minItems\":1,\"items\":{\"$ref\":\"#\"}},\"nonNegativeInteger\":{\"type\":\"integer\",\"minimum\":0},\"nonNegativeIntegerDefault0\":{\"allOf\":[{\"$ref\":\"#/definitions/nonNegativeInteger\"},{\"default\":0}]},\"simpleTypes\":{\"enum\":[\"array\",\"boolean\",\"integer\",\"null\",\"number\",\"object\",\"string\"]},\"stringArray\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"uniqueItems\":true,\"default\":[]}},\"type\":[\"object\",\"boolean\"],\"properties\":{\"$id\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$schema\":{\"type\":\"string\",\"format\":\"uri\"},\"$ref\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$comment\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"default\":true,\"readOnly\":{\"type\":\"boolean\",\"default\":false},\"examples\":{\"type\":\"array\",\"items\":true},\"multipleOf\":{\"type\":\"number\",\"exclusiveMinimum\":0},\"maximum\":{\"type\":\"number\"},\"exclusiveMaximum\":{\"type\":\"number\"},\"minimum\":{\"type\":\"number\"},\"exclusiveMinimum\":{\"type\":\"number\"},\"maxLength\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minLength\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"pattern\":{\"type\":\"string\",\"format\":\"regex\"},\"additionalItems\":{\"$ref\":\"#\"},\"items\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/schemaArray\"}],\"default\":true},\"maxItems\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minItems\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"uniqueItems\":{\"type\":\"boolean\",\"default\":false},\"contains\":{\"$ref\":\"#\"},\"maxProperties\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minProperties\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"required\":{\"$ref\":\"#/definitions/stringArray\"},\"additionalProperties\":{\"$ref\":\"#\"},\"definitions\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"properties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"patternProperties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"propertyNames\":{\"format\":\"regex\"},\"default\":{}},\"dependencies\":{\"type\":\"object\",\"additionalProperties\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/stringArray\"}]}},\"propertyNames\":{\"$ref\":\"#\"},\"const\":true,\"enum\":{\"type\":\"array\",\"items\":true,\"minItems\":1,\"uniqueItems\":true},\"type\":{\"anyOf\":[{\"$ref\":\"#/definitions/simpleTypes\"},{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/simpleTypes\"},\"minItems\":1,\"uniqueItems\":true}]},\"format\":{\"type\":\"string\"},\"contentMediaType\":{\"type\":\"string\"},\"contentEncoding\":{\"type\":\"string\"},\"if\":{\"$ref\":\"#\"},\"then\":{\"$ref\":\"#\"},\"else\":{\"$ref\":\"#\"},\"allOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"anyOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"oneOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"not\":{\"$ref\":\"#\"}},\"default\":true}');\n\n});\n\n\n// import { SchemaValidator } from \"/bundle.js\";\n// TODO : import directly from the bundle.js file\n\nvar $ilwRK = parcelRequire(\"ilwRK\");\nconst $cf76942c31581396$export$bd9e0fcae8e65975 = {\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"metadata\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The decentralized identifier representing the profile in the DID format.\"\n                },\n                \"type\": {\n                    \"type\": \"string\",\n                    \"description\": \"A string indicating the type of the profile.\"\n                },\n                \"checksum\": {\n                    \"type\": \"string\",\n                    \"description\": \"A checksum value for data integrity validation.\"\n                },\n                \"created\": {\n                    \"type\": \"string\",\n                    \"description\": \"Timestamp indicating profile creation date.\"\n                },\n                \"name\": {\n                    \"type\": \"string\",\n                    \"description\": \"A human-readable name for the profile.\"\n                },\n                \"previous\": {\n                    \"type\": \"string\",\n                    \"description\": \"Reference to a previous version of the profile data.\"\n                },\n                \"description\": {\n                    \"type\": \"string\",\n                    \"description\": \"A detailed description of the profile.\"\n                },\n                \"short_description\": {\n                    \"type\": \"string\",\n                    \"description\": \"A concise description of the profile.\"\n                },\n                \"docs_url\": {\n                    \"type\": \"string\",\n                    \"description\": \"URL to documentation for the profile data.\"\n                },\n                \"version\": {\n                    \"type\": \"string\",\n                    \"description\": \"The version of the profile data, following semver.\"\n                },\n                \"tags\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"type\": \"string\"\n                    },\n                    \"description\": \"Tags associated with the profile data.\"\n                }\n            },\n            \"required\": [\n                \"id\"\n            ],\n            \"additionalProperties\": true\n        },\n        \"definitions\": {\n            \"type\": \"object\",\n            \"description\": \"Defines capabilities or services related to the profile data.\"\n        },\n        \"proof\": {\n            \"type\": \"object\",\n            \"description\": \"Information related to proofing the authenticity of the profile data.\"\n        }\n    },\n    \"required\": [\n        \"metadata\"\n    ],\n    \"additionalProperties\": false\n};\n\n\nclass $151113e9b29588b6$export$5ea2dbb44eae89d6 {\n    static{\n        this.ajv = new (0, (/*@__PURE__*/$parcel$interopDefault($ilwRK)))();\n    }\n    static{\n        this.validator = $151113e9b29588b6$export$5ea2dbb44eae89d6.ajv.compile((0, $cf76942c31581396$export$bd9e0fcae8e65975));\n    }\n    constructor(){}\n    static validate(data) {\n        return $151113e9b29588b6$export$5ea2dbb44eae89d6.validator(data);\n    }\n}\n\n\n\nvar $ilwRK = parcelRequire(\"ilwRK\");\nconst $22ed35696b271362$export$71895420a317a9e8 = {\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"uri\": {\n            \"type\": \"string\"\n        },\n        \"profile\": {\n            \"type\": \"string\"\n        },\n        \"integrity\": {\n            \"type\": \"string\"\n        }\n    },\n    \"required\": [\n        \"uri\",\n        \"profile\"\n    ],\n    \"additionalProperties\": false\n};\n\n\nconst $afbb33d5df9729d3$export$bb95c122214a8b29 = async (did, RESOLVER_API_URL = \"https://dev.uniresolver.io/1.0/identifiers/\")=>{\n    try {\n        const url = `${RESOLVER_API_URL}${did}`;\n        const response = await fetch(url, {\n            method: \"GET\"\n        });\n        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}. ${response.statusText}}`);\n        const data = await response.json();\n        return data.didDocument; // Assuming you want to return the response data\n    } catch (error) {\n        throw new Error(`Error resolving DID: ${error}`);\n    }\n};\nconst $afbb33d5df9729d3$export$dde6e0634f2231e4 = (didDocument)=>{\n    const ajv = new (0, (/*@__PURE__*/$parcel$interopDefault($ilwRK)))();\n    const validate = ajv.compile((0, $22ed35696b271362$export$71895420a317a9e8));\n    const results = [];\n    if (didDocument.service && Array.isArray(didDocument.service)) didDocument.service.forEach((service)=>{\n        if (service.serviceEndpoint) {\n            const isValid = validate(service.serviceEndpoint);\n            results.push({\n                id: service.id,\n                isValid: isValid,\n                errors: validate.errors ? validate.errors : null\n            });\n        }\n    });\n    return results;\n};\n\n\nconst $443fec48b5d8e69c$export$b35af804a0ff5bd0 = async (url)=>{\n    const response = await fetch(url, {\n        method: \"GET\"\n    });\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n    const data = await response.json();\n    return data;\n};\n\n\n// import { createHash } from \"node:crypto\";\nvar $2579977b4e52adba$exports = {};\n\"use strict\";\nObject.defineProperty($2579977b4e52adba$exports, \"__esModule\", {\n    value: true\n});\n$2579977b4e52adba$exports.sha384 = $2579977b4e52adba$exports.sha512_256 = $2579977b4e52adba$exports.sha512_224 = $2579977b4e52adba$exports.sha512 = $2579977b4e52adba$exports.SHA512 = void 0;\nvar $bc3a993d7d38a7a0$exports = {};\n\"use strict\";\nObject.defineProperty($bc3a993d7d38a7a0$exports, \"__esModule\", {\n    value: true\n});\n$bc3a993d7d38a7a0$exports.SHA2 = void 0;\nvar $a0ae23f5901291b4$exports = {};\n\"use strict\";\nObject.defineProperty($a0ae23f5901291b4$exports, \"__esModule\", {\n    value: true\n});\n$a0ae23f5901291b4$exports.output = $a0ae23f5901291b4$exports.exists = $a0ae23f5901291b4$exports.hash = $a0ae23f5901291b4$exports.bytes = $a0ae23f5901291b4$exports.bool = $a0ae23f5901291b4$exports.number = void 0;\nfunction $a0ae23f5901291b4$var$number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n$a0ae23f5901291b4$exports.number = $a0ae23f5901291b4$var$number;\nfunction $a0ae23f5901291b4$var$bool(b) {\n    if (typeof b !== \"boolean\") throw new Error(`Expected boolean, not ${b}`);\n}\n$a0ae23f5901291b4$exports.bool = $a0ae23f5901291b4$var$bool;\n// copied from utils\nfunction $a0ae23f5901291b4$var$isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\nfunction $a0ae23f5901291b4$var$bytes(b, ...lengths) {\n    if (!$a0ae23f5901291b4$var$isBytes(b)) throw new Error(\"Expected Uint8Array\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n$a0ae23f5901291b4$exports.bytes = $a0ae23f5901291b4$var$bytes;\nfunction $a0ae23f5901291b4$var$hash(hash) {\n    if (typeof hash !== \"function\" || typeof hash.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    $a0ae23f5901291b4$var$number(hash.outputLen);\n    $a0ae23f5901291b4$var$number(hash.blockLen);\n}\n$a0ae23f5901291b4$exports.hash = $a0ae23f5901291b4$var$hash;\nfunction $a0ae23f5901291b4$var$exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\n$a0ae23f5901291b4$exports.exists = $a0ae23f5901291b4$var$exists;\nfunction $a0ae23f5901291b4$var$output(out, instance) {\n    $a0ae23f5901291b4$var$bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n}\n$a0ae23f5901291b4$exports.output = $a0ae23f5901291b4$var$output;\nconst $a0ae23f5901291b4$var$assert = {\n    number: $a0ae23f5901291b4$var$number,\n    bool: $a0ae23f5901291b4$var$bool,\n    bytes: $a0ae23f5901291b4$var$bytes,\n    hash: $a0ae23f5901291b4$var$hash,\n    exists: $a0ae23f5901291b4$var$exists,\n    output: $a0ae23f5901291b4$var$output\n};\n$a0ae23f5901291b4$exports.default = $a0ae23f5901291b4$var$assert;\n\n\nvar $29ee4d3171d9809b$exports = {};\n\"use strict\";\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty($29ee4d3171d9809b$exports, \"__esModule\", {\n    value: true\n});\n$29ee4d3171d9809b$exports.randomBytes = $29ee4d3171d9809b$exports.wrapXOFConstructorWithOpts = $29ee4d3171d9809b$exports.wrapConstructorWithOpts = $29ee4d3171d9809b$exports.wrapConstructor = $29ee4d3171d9809b$exports.checkOpts = $29ee4d3171d9809b$exports.Hash = $29ee4d3171d9809b$exports.concatBytes = $29ee4d3171d9809b$exports.toBytes = $29ee4d3171d9809b$exports.utf8ToBytes = $29ee4d3171d9809b$exports.asyncLoop = $29ee4d3171d9809b$exports.nextTick = $29ee4d3171d9809b$exports.hexToBytes = $29ee4d3171d9809b$exports.bytesToHex = $29ee4d3171d9809b$exports.isLE = $29ee4d3171d9809b$exports.rotr = $29ee4d3171d9809b$exports.createView = $29ee4d3171d9809b$exports.u32 = $29ee4d3171d9809b$exports.u8 = void 0;\nvar $a20ad0ecd1be3cb3$exports = {};\n\"use strict\";\nObject.defineProperty($a20ad0ecd1be3cb3$exports, \"__esModule\", {\n    value: true\n});\n$a20ad0ecd1be3cb3$exports.crypto = void 0;\n$a20ad0ecd1be3cb3$exports.crypto = typeof globalThis === \"object\" && \"crypto\" in globalThis ? globalThis.crypto : undefined;\n\n\n// Cast array to different type\nconst $29ee4d3171d9809b$var$u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n$29ee4d3171d9809b$exports.u8 = $29ee4d3171d9809b$var$u8;\nconst $29ee4d3171d9809b$var$u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n$29ee4d3171d9809b$exports.u32 = $29ee4d3171d9809b$var$u32;\nfunction $29ee4d3171d9809b$var$isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\n// Cast array to view\nconst $29ee4d3171d9809b$var$createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n$29ee4d3171d9809b$exports.createView = $29ee4d3171d9809b$var$createView;\n// The rotate right (circular right shift) operation for uint32\nconst $29ee4d3171d9809b$var$rotr = (word, shift)=>word << 32 - shift | word >>> shift;\n$29ee4d3171d9809b$exports.rotr = $29ee4d3171d9809b$var$rotr;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\n$29ee4d3171d9809b$exports.isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\nif (!$29ee4d3171d9809b$exports.isLE) throw new Error(\"Non little-endian hardware is not supported\");\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst $29ee4d3171d9809b$var$hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function $29ee4d3171d9809b$var$bytesToHex(bytes) {\n    if (!$29ee4d3171d9809b$var$isBytes(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++)hex += $29ee4d3171d9809b$var$hexes[bytes[i]];\n    return hex;\n}\n$29ee4d3171d9809b$exports.bytesToHex = $29ee4d3171d9809b$var$bytesToHex;\n// We use optimized technique to convert hex string to byte array\nconst $29ee4d3171d9809b$var$asciis = {\n    _0: 48,\n    _9: 57,\n    _A: 65,\n    _F: 70,\n    _a: 97,\n    _f: 102\n};\nfunction $29ee4d3171d9809b$var$asciiToBase16(char) {\n    if (char >= $29ee4d3171d9809b$var$asciis._0 && char <= $29ee4d3171d9809b$var$asciis._9) return char - $29ee4d3171d9809b$var$asciis._0;\n    if (char >= $29ee4d3171d9809b$var$asciis._A && char <= $29ee4d3171d9809b$var$asciis._F) return char - ($29ee4d3171d9809b$var$asciis._A - 10);\n    if (char >= $29ee4d3171d9809b$var$asciis._a && char <= $29ee4d3171d9809b$var$asciis._f) return char - ($29ee4d3171d9809b$var$asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function $29ee4d3171d9809b$var$hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = $29ee4d3171d9809b$var$asciiToBase16(hex.charCodeAt(hi));\n        const n2 = $29ee4d3171d9809b$var$asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n$29ee4d3171d9809b$exports.hexToBytes = $29ee4d3171d9809b$var$hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst $29ee4d3171d9809b$var$nextTick = async ()=>{};\n$29ee4d3171d9809b$exports.nextTick = $29ee4d3171d9809b$var$nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function $29ee4d3171d9809b$var$asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await (0, $29ee4d3171d9809b$exports.nextTick)();\n        ts += diff;\n    }\n}\n$29ee4d3171d9809b$exports.asyncLoop = $29ee4d3171d9809b$var$asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function $29ee4d3171d9809b$var$utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n$29ee4d3171d9809b$exports.utf8ToBytes = $29ee4d3171d9809b$var$utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function $29ee4d3171d9809b$var$toBytes(data) {\n    if (typeof data === \"string\") data = $29ee4d3171d9809b$var$utf8ToBytes(data);\n    if (!$29ee4d3171d9809b$var$isBytes(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n$29ee4d3171d9809b$exports.toBytes = $29ee4d3171d9809b$var$toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */ function $29ee4d3171d9809b$var$concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        if (!$29ee4d3171d9809b$var$isBytes(a)) throw new Error(\"Uint8Array expected\");\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n$29ee4d3171d9809b$exports.concatBytes = $29ee4d3171d9809b$var$concatBytes;\n// For runtime check if class implements interface\nclass $29ee4d3171d9809b$var$Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n$29ee4d3171d9809b$exports.Hash = $29ee4d3171d9809b$var$Hash;\nconst $29ee4d3171d9809b$var$toStr = {}.toString;\nfunction $29ee4d3171d9809b$var$checkOpts(defaults, opts) {\n    if (opts !== undefined && $29ee4d3171d9809b$var$toStr.call(opts) !== \"[object Object]\") throw new Error(\"Options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n$29ee4d3171d9809b$exports.checkOpts = $29ee4d3171d9809b$var$checkOpts;\nfunction $29ee4d3171d9809b$var$wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update($29ee4d3171d9809b$var$toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\n$29ee4d3171d9809b$exports.wrapConstructor = $29ee4d3171d9809b$var$wrapConstructor;\nfunction $29ee4d3171d9809b$var$wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update($29ee4d3171d9809b$var$toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\n$29ee4d3171d9809b$exports.wrapConstructorWithOpts = $29ee4d3171d9809b$var$wrapConstructorWithOpts;\nfunction $29ee4d3171d9809b$var$wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update($29ee4d3171d9809b$var$toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\n$29ee4d3171d9809b$exports.wrapXOFConstructorWithOpts = $29ee4d3171d9809b$var$wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function $29ee4d3171d9809b$var$randomBytes(bytesLength = 32) {\n    if ($a20ad0ecd1be3cb3$exports.crypto && typeof $a20ad0ecd1be3cb3$exports.crypto.getRandomValues === \"function\") return $a20ad0ecd1be3cb3$exports.crypto.getRandomValues(new Uint8Array(bytesLength));\n    throw new Error(\"crypto.getRandomValues must be defined\");\n}\n$29ee4d3171d9809b$exports.randomBytes = $29ee4d3171d9809b$var$randomBytes;\n\n\n// Polyfill for Safari 14\nfunction $bc3a993d7d38a7a0$var$setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass $bc3a993d7d38a7a0$var$SHA2 extends $29ee4d3171d9809b$exports.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, $29ee4d3171d9809b$exports.createView)(this.buffer);\n    }\n    update(data) {\n        (0, $a0ae23f5901291b4$exports.exists)(this);\n        const { view: view, buffer: buffer, blockLen: blockLen } = this;\n        data = (0, $29ee4d3171d9809b$exports.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, $29ee4d3171d9809b$exports.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, $a0ae23f5901291b4$exports.exists)(this);\n        (0, $a0ae23f5901291b4$exports.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer: buffer, view: view, blockLen: blockLen, isLE: isLE } = this;\n        let { pos: pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        $bc3a993d7d38a7a0$var$setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, $29ee4d3171d9809b$exports.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer: buffer, outputLen: outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen: blockLen, buffer: buffer, length: length, finished: finished, destroyed: destroyed, pos: pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n}\n$bc3a993d7d38a7a0$exports.SHA2 = $bc3a993d7d38a7a0$var$SHA2;\n\n\nvar $aa71b30d36adb919$exports = {};\n\"use strict\";\nObject.defineProperty($aa71b30d36adb919$exports, \"__esModule\", {\n    value: true\n});\n$aa71b30d36adb919$exports.add5L = $aa71b30d36adb919$exports.add5H = $aa71b30d36adb919$exports.add4H = $aa71b30d36adb919$exports.add4L = $aa71b30d36adb919$exports.add3H = $aa71b30d36adb919$exports.add3L = $aa71b30d36adb919$exports.add = $aa71b30d36adb919$exports.rotlBL = $aa71b30d36adb919$exports.rotlBH = $aa71b30d36adb919$exports.rotlSL = $aa71b30d36adb919$exports.rotlSH = $aa71b30d36adb919$exports.rotr32L = $aa71b30d36adb919$exports.rotr32H = $aa71b30d36adb919$exports.rotrBL = $aa71b30d36adb919$exports.rotrBH = $aa71b30d36adb919$exports.rotrSL = $aa71b30d36adb919$exports.rotrSH = $aa71b30d36adb919$exports.shrSL = $aa71b30d36adb919$exports.shrSH = $aa71b30d36adb919$exports.toBig = $aa71b30d36adb919$exports.split = $aa71b30d36adb919$exports.fromBig = void 0;\nconst $aa71b30d36adb919$var$U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst $aa71b30d36adb919$var$_32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction $aa71b30d36adb919$var$fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & $aa71b30d36adb919$var$U32_MASK64),\n        l: Number(n >> $aa71b30d36adb919$var$_32n & $aa71b30d36adb919$var$U32_MASK64)\n    };\n    return {\n        h: Number(n >> $aa71b30d36adb919$var$_32n & $aa71b30d36adb919$var$U32_MASK64) | 0,\n        l: Number(n & $aa71b30d36adb919$var$U32_MASK64) | 0\n    };\n}\n$aa71b30d36adb919$exports.fromBig = $aa71b30d36adb919$var$fromBig;\nfunction $aa71b30d36adb919$var$split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for(let i = 0; i < lst.length; i++){\n        const { h: h, l: l } = $aa71b30d36adb919$var$fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\n$aa71b30d36adb919$exports.split = $aa71b30d36adb919$var$split;\nconst $aa71b30d36adb919$var$toBig = (h, l)=>BigInt(h >>> 0) << $aa71b30d36adb919$var$_32n | BigInt(l >>> 0);\n$aa71b30d36adb919$exports.toBig = $aa71b30d36adb919$var$toBig;\n// for Shift in [0, 32)\nconst $aa71b30d36adb919$var$shrSH = (h, _l, s)=>h >>> s;\n$aa71b30d36adb919$exports.shrSH = $aa71b30d36adb919$var$shrSH;\nconst $aa71b30d36adb919$var$shrSL = (h, l, s)=>h << 32 - s | l >>> s;\n$aa71b30d36adb919$exports.shrSL = $aa71b30d36adb919$var$shrSL;\n// Right rotate for Shift in [1, 32)\nconst $aa71b30d36adb919$var$rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\n$aa71b30d36adb919$exports.rotrSH = $aa71b30d36adb919$var$rotrSH;\nconst $aa71b30d36adb919$var$rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\n$aa71b30d36adb919$exports.rotrSL = $aa71b30d36adb919$var$rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst $aa71b30d36adb919$var$rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\n$aa71b30d36adb919$exports.rotrBH = $aa71b30d36adb919$var$rotrBH;\nconst $aa71b30d36adb919$var$rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\n$aa71b30d36adb919$exports.rotrBL = $aa71b30d36adb919$var$rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst $aa71b30d36adb919$var$rotr32H = (_h, l)=>l;\n$aa71b30d36adb919$exports.rotr32H = $aa71b30d36adb919$var$rotr32H;\nconst $aa71b30d36adb919$var$rotr32L = (h, _l)=>h;\n$aa71b30d36adb919$exports.rotr32L = $aa71b30d36adb919$var$rotr32L;\n// Left rotate for Shift in [1, 32)\nconst $aa71b30d36adb919$var$rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\n$aa71b30d36adb919$exports.rotlSH = $aa71b30d36adb919$var$rotlSH;\nconst $aa71b30d36adb919$var$rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\n$aa71b30d36adb919$exports.rotlSL = $aa71b30d36adb919$var$rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst $aa71b30d36adb919$var$rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\n$aa71b30d36adb919$exports.rotlBH = $aa71b30d36adb919$var$rotlBH;\nconst $aa71b30d36adb919$var$rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\n$aa71b30d36adb919$exports.rotlBL = $aa71b30d36adb919$var$rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction $aa71b30d36adb919$var$add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\n$aa71b30d36adb919$exports.add = $aa71b30d36adb919$var$add;\n// Addition with more than 2 elements\nconst $aa71b30d36adb919$var$add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\n$aa71b30d36adb919$exports.add3L = $aa71b30d36adb919$var$add3L;\nconst $aa71b30d36adb919$var$add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\n$aa71b30d36adb919$exports.add3H = $aa71b30d36adb919$var$add3H;\nconst $aa71b30d36adb919$var$add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\n$aa71b30d36adb919$exports.add4L = $aa71b30d36adb919$var$add4L;\nconst $aa71b30d36adb919$var$add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\n$aa71b30d36adb919$exports.add4H = $aa71b30d36adb919$var$add4H;\nconst $aa71b30d36adb919$var$add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\n$aa71b30d36adb919$exports.add5L = $aa71b30d36adb919$var$add5L;\nconst $aa71b30d36adb919$var$add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n$aa71b30d36adb919$exports.add5H = $aa71b30d36adb919$var$add5H;\n// prettier-ignore\nconst $aa71b30d36adb919$var$u64 = {\n    fromBig: $aa71b30d36adb919$var$fromBig,\n    split: $aa71b30d36adb919$var$split,\n    toBig: $aa71b30d36adb919$var$toBig,\n    shrSH: $aa71b30d36adb919$var$shrSH,\n    shrSL: $aa71b30d36adb919$var$shrSL,\n    rotrSH: $aa71b30d36adb919$var$rotrSH,\n    rotrSL: $aa71b30d36adb919$var$rotrSL,\n    rotrBH: $aa71b30d36adb919$var$rotrBH,\n    rotrBL: $aa71b30d36adb919$var$rotrBL,\n    rotr32H: $aa71b30d36adb919$var$rotr32H,\n    rotr32L: $aa71b30d36adb919$var$rotr32L,\n    rotlSH: $aa71b30d36adb919$var$rotlSH,\n    rotlSL: $aa71b30d36adb919$var$rotlSL,\n    rotlBH: $aa71b30d36adb919$var$rotlBH,\n    rotlBL: $aa71b30d36adb919$var$rotlBL,\n    add: $aa71b30d36adb919$var$add,\n    add3L: $aa71b30d36adb919$var$add3L,\n    add3H: $aa71b30d36adb919$var$add3H,\n    add4L: $aa71b30d36adb919$var$add4L,\n    add4H: $aa71b30d36adb919$var$add4H,\n    add5H: $aa71b30d36adb919$var$add5H,\n    add5L: $aa71b30d36adb919$var$add5L\n};\n$aa71b30d36adb919$exports.default = $aa71b30d36adb919$var$u64;\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [$2579977b4e52adba$var$SHA512_Kh, $2579977b4e52adba$var$SHA512_Kl] = /* @__PURE__ */ (()=>$aa71b30d36adb919$exports.default.split([\n        \"0x428a2f98d728ae22\",\n        \"0x7137449123ef65cd\",\n        \"0xb5c0fbcfec4d3b2f\",\n        \"0xe9b5dba58189dbbc\",\n        \"0x3956c25bf348b538\",\n        \"0x59f111f1b605d019\",\n        \"0x923f82a4af194f9b\",\n        \"0xab1c5ed5da6d8118\",\n        \"0xd807aa98a3030242\",\n        \"0x12835b0145706fbe\",\n        \"0x243185be4ee4b28c\",\n        \"0x550c7dc3d5ffb4e2\",\n        \"0x72be5d74f27b896f\",\n        \"0x80deb1fe3b1696b1\",\n        \"0x9bdc06a725c71235\",\n        \"0xc19bf174cf692694\",\n        \"0xe49b69c19ef14ad2\",\n        \"0xefbe4786384f25e3\",\n        \"0x0fc19dc68b8cd5b5\",\n        \"0x240ca1cc77ac9c65\",\n        \"0x2de92c6f592b0275\",\n        \"0x4a7484aa6ea6e483\",\n        \"0x5cb0a9dcbd41fbd4\",\n        \"0x76f988da831153b5\",\n        \"0x983e5152ee66dfab\",\n        \"0xa831c66d2db43210\",\n        \"0xb00327c898fb213f\",\n        \"0xbf597fc7beef0ee4\",\n        \"0xc6e00bf33da88fc2\",\n        \"0xd5a79147930aa725\",\n        \"0x06ca6351e003826f\",\n        \"0x142929670a0e6e70\",\n        \"0x27b70a8546d22ffc\",\n        \"0x2e1b21385c26c926\",\n        \"0x4d2c6dfc5ac42aed\",\n        \"0x53380d139d95b3df\",\n        \"0x650a73548baf63de\",\n        \"0x766a0abb3c77b2a8\",\n        \"0x81c2c92e47edaee6\",\n        \"0x92722c851482353b\",\n        \"0xa2bfe8a14cf10364\",\n        \"0xa81a664bbc423001\",\n        \"0xc24b8b70d0f89791\",\n        \"0xc76c51a30654be30\",\n        \"0xd192e819d6ef5218\",\n        \"0xd69906245565a910\",\n        \"0xf40e35855771202a\",\n        \"0x106aa07032bbd1b8\",\n        \"0x19a4c116b8d2d0c8\",\n        \"0x1e376c085141ab53\",\n        \"0x2748774cdf8eeb99\",\n        \"0x34b0bcb5e19b48a8\",\n        \"0x391c0cb3c5c95a63\",\n        \"0x4ed8aa4ae3418acb\",\n        \"0x5b9cca4f7763e373\",\n        \"0x682e6ff3d6b2b8a3\",\n        \"0x748f82ee5defb2fc\",\n        \"0x78a5636f43172f60\",\n        \"0x84c87814a1f0ab72\",\n        \"0x8cc702081a6439ec\",\n        \"0x90befffa23631e28\",\n        \"0xa4506cebde82bde9\",\n        \"0xbef9a3f7b2c67915\",\n        \"0xc67178f2e372532b\",\n        \"0xca273eceea26619c\",\n        \"0xd186b8c721c0c207\",\n        \"0xeada7dd6cde0eb1e\",\n        \"0xf57d4f7fee6ed178\",\n        \"0x06f067aa72176fba\",\n        \"0x0a637dc5a2c898a6\",\n        \"0x113f9804bef90dae\",\n        \"0x1b710b35131c471b\",\n        \"0x28db77f523047d84\",\n        \"0x32caab7b40c72493\",\n        \"0x3c9ebe0a15c9bebc\",\n        \"0x431d67c49c100d4c\",\n        \"0x4cc5d4becb3e42b6\",\n        \"0x597f299cfc657e2a\",\n        \"0x5fcb6fab3ad6faec\",\n        \"0x6c44198c4a475817\"\n    ].map((n)=>BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst $2579977b4e52adba$var$SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst $2579977b4e52adba$var$SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass $2579977b4e52adba$var$SHA512 extends $bc3a993d7d38a7a0$exports.SHA2 {\n    constructor(){\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 1779033703;\n        this.Al = -205731576;\n        this.Bh = -1150833019;\n        this.Bl = -2067093701;\n        this.Ch = 1013904242;\n        this.Cl = -23791573;\n        this.Dh = -1521486534;\n        this.Dl = 1595750129;\n        this.Eh = 1359893119;\n        this.El = -1377402159;\n        this.Fh = -1694144372;\n        this.Fl = 725511199;\n        this.Gh = 528734635;\n        this.Gl = -79577749;\n        this.Hh = 1541459225;\n        this.Hl = 327033209;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah: Ah, Al: Al, Bh: Bh, Bl: Bl, Ch: Ch, Cl: Cl, Dh: Dh, Dl: Dl, Eh: Eh, El: El, Fh: Fh, Fl: Fl, Gh: Gh, Gl: Gl, Hh: Hh, Hl: Hl } = this;\n        return [\n            Ah,\n            Al,\n            Bh,\n            Bl,\n            Ch,\n            Cl,\n            Dh,\n            Dl,\n            Eh,\n            El,\n            Fh,\n            Fl,\n            Gh,\n            Gl,\n            Hh,\n            Hl\n        ];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4){\n            $2579977b4e52adba$var$SHA512_W_H[i] = view.getUint32(offset);\n            $2579977b4e52adba$var$SHA512_W_L[i] = view.getUint32(offset += 4);\n        }\n        for(let i = 16; i < 80; i++){\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = $2579977b4e52adba$var$SHA512_W_H[i - 15] | 0;\n            const W15l = $2579977b4e52adba$var$SHA512_W_L[i - 15] | 0;\n            const s0h = $aa71b30d36adb919$exports.default.rotrSH(W15h, W15l, 1) ^ $aa71b30d36adb919$exports.default.rotrSH(W15h, W15l, 8) ^ $aa71b30d36adb919$exports.default.shrSH(W15h, W15l, 7);\n            const s0l = $aa71b30d36adb919$exports.default.rotrSL(W15h, W15l, 1) ^ $aa71b30d36adb919$exports.default.rotrSL(W15h, W15l, 8) ^ $aa71b30d36adb919$exports.default.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = $2579977b4e52adba$var$SHA512_W_H[i - 2] | 0;\n            const W2l = $2579977b4e52adba$var$SHA512_W_L[i - 2] | 0;\n            const s1h = $aa71b30d36adb919$exports.default.rotrSH(W2h, W2l, 19) ^ $aa71b30d36adb919$exports.default.rotrBH(W2h, W2l, 61) ^ $aa71b30d36adb919$exports.default.shrSH(W2h, W2l, 6);\n            const s1l = $aa71b30d36adb919$exports.default.rotrSL(W2h, W2l, 19) ^ $aa71b30d36adb919$exports.default.rotrBL(W2h, W2l, 61) ^ $aa71b30d36adb919$exports.default.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = $aa71b30d36adb919$exports.default.add4L(s0l, s1l, $2579977b4e52adba$var$SHA512_W_L[i - 7], $2579977b4e52adba$var$SHA512_W_L[i - 16]);\n            const SUMh = $aa71b30d36adb919$exports.default.add4H(SUMl, s0h, s1h, $2579977b4e52adba$var$SHA512_W_H[i - 7], $2579977b4e52adba$var$SHA512_W_H[i - 16]);\n            $2579977b4e52adba$var$SHA512_W_H[i] = SUMh | 0;\n            $2579977b4e52adba$var$SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah: Ah, Al: Al, Bh: Bh, Bl: Bl, Ch: Ch, Cl: Cl, Dh: Dh, Dl: Dl, Eh: Eh, El: El, Fh: Fh, Fl: Fl, Gh: Gh, Gl: Gl, Hh: Hh, Hl: Hl } = this;\n        // Compression function main loop, 80 rounds\n        for(let i = 0; i < 80; i++){\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = $aa71b30d36adb919$exports.default.rotrSH(Eh, El, 14) ^ $aa71b30d36adb919$exports.default.rotrSH(Eh, El, 18) ^ $aa71b30d36adb919$exports.default.rotrBH(Eh, El, 41);\n            const sigma1l = $aa71b30d36adb919$exports.default.rotrSL(Eh, El, 14) ^ $aa71b30d36adb919$exports.default.rotrSL(Eh, El, 18) ^ $aa71b30d36adb919$exports.default.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = Eh & Fh ^ ~Eh & Gh;\n            const CHIl = El & Fl ^ ~El & Gl;\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = $aa71b30d36adb919$exports.default.add5L(Hl, sigma1l, CHIl, $2579977b4e52adba$var$SHA512_Kl[i], $2579977b4e52adba$var$SHA512_W_L[i]);\n            const T1h = $aa71b30d36adb919$exports.default.add5H(T1ll, Hh, sigma1h, CHIh, $2579977b4e52adba$var$SHA512_Kh[i], $2579977b4e52adba$var$SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = $aa71b30d36adb919$exports.default.rotrSH(Ah, Al, 28) ^ $aa71b30d36adb919$exports.default.rotrBH(Ah, Al, 34) ^ $aa71b30d36adb919$exports.default.rotrBH(Ah, Al, 39);\n            const sigma0l = $aa71b30d36adb919$exports.default.rotrSL(Ah, Al, 28) ^ $aa71b30d36adb919$exports.default.rotrBL(Ah, Al, 34) ^ $aa71b30d36adb919$exports.default.rotrBL(Ah, Al, 39);\n            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;\n            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = $aa71b30d36adb919$exports.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = $aa71b30d36adb919$exports.default.add3L(T1l, sigma0l, MAJl);\n            Ah = $aa71b30d36adb919$exports.default.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = $aa71b30d36adb919$exports.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = $aa71b30d36adb919$exports.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = $aa71b30d36adb919$exports.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = $aa71b30d36adb919$exports.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = $aa71b30d36adb919$exports.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = $aa71b30d36adb919$exports.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = $aa71b30d36adb919$exports.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = $aa71b30d36adb919$exports.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        $2579977b4e52adba$var$SHA512_W_H.fill(0);\n        $2579977b4e52adba$var$SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n$2579977b4e52adba$exports.SHA512 = $2579977b4e52adba$var$SHA512;\nclass $2579977b4e52adba$var$SHA512_224 extends $2579977b4e52adba$var$SHA512 {\n    constructor(){\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = -1942145080;\n        this.Al = 424955298;\n        this.Bh = 1944164710;\n        this.Bl = -1982016298;\n        this.Ch = 502970286;\n        this.Cl = 855612546;\n        this.Dh = 1738396948;\n        this.Dl = 1479516111;\n        this.Eh = 258812777;\n        this.El = 2077511080;\n        this.Fh = 2011393907;\n        this.Fl = 79989058;\n        this.Gh = 1067287976;\n        this.Gl = 1780299464;\n        this.Hh = 286451373;\n        this.Hl = -1848208735;\n        this.outputLen = 28;\n    }\n}\nclass $2579977b4e52adba$var$SHA512_256 extends $2579977b4e52adba$var$SHA512 {\n    constructor(){\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 573645204;\n        this.Al = -64227540;\n        this.Bh = -1621794909;\n        this.Bl = -934517566;\n        this.Ch = 596883563;\n        this.Cl = 1867755857;\n        this.Dh = -1774684391;\n        this.Dl = 1497426621;\n        this.Eh = -1775747358;\n        this.El = -1467023389;\n        this.Fh = -1101128155;\n        this.Fl = 1401305490;\n        this.Gh = 721525244;\n        this.Gl = 746961066;\n        this.Hh = 246885852;\n        this.Hl = -2117784414;\n        this.outputLen = 32;\n    }\n}\nclass $2579977b4e52adba$var$SHA384 extends $2579977b4e52adba$var$SHA512 {\n    constructor(){\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = -876896931;\n        this.Al = -1056596264;\n        this.Bh = 1654270250;\n        this.Bl = 914150663;\n        this.Ch = -1856437926;\n        this.Cl = 812702999;\n        this.Dh = 355462360;\n        this.Dl = -150054599;\n        this.Eh = 1731405415;\n        this.El = -4191439;\n        this.Fh = -1900787065;\n        this.Fl = 1750603025;\n        this.Gh = -619958771;\n        this.Gl = 1694076839;\n        this.Hh = 1203062813;\n        this.Hl = -1090891868;\n        this.outputLen = 48;\n    }\n}\n$2579977b4e52adba$exports.sha512 = (0, $29ee4d3171d9809b$exports.wrapConstructor)(()=>new $2579977b4e52adba$var$SHA512());\n$2579977b4e52adba$exports.sha512_224 = (0, $29ee4d3171d9809b$exports.wrapConstructor)(()=>new $2579977b4e52adba$var$SHA512_224());\n$2579977b4e52adba$exports.sha512_256 = (0, $29ee4d3171d9809b$exports.wrapConstructor)(()=>new $2579977b4e52adba$var$SHA512_256());\n$2579977b4e52adba$exports.sha384 = (0, $29ee4d3171d9809b$exports.wrapConstructor)(()=>new $2579977b4e52adba$var$SHA384());\n\n\nvar $510ad3657d73a9d2$exports = {};\n\"use strict\";\nObject.defineProperty($510ad3657d73a9d2$exports, \"__esModule\", {\n    value: true\n});\n$510ad3657d73a9d2$exports.sha224 = $510ad3657d73a9d2$exports.sha256 = void 0;\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst $510ad3657d73a9d2$var$Chi = (a, b, c)=>a & b ^ ~a & c;\n// Majority function, true if any two inpust is true\nconst $510ad3657d73a9d2$var$Maj = (a, b, c)=>a & b ^ a & c ^ b & c;\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst $510ad3657d73a9d2$var$SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst $510ad3657d73a9d2$var$IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst $510ad3657d73a9d2$var$SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass $510ad3657d73a9d2$var$SHA256 extends $bc3a993d7d38a7a0$exports.SHA2 {\n    constructor(){\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = $510ad3657d73a9d2$var$IV[0] | 0;\n        this.B = $510ad3657d73a9d2$var$IV[1] | 0;\n        this.C = $510ad3657d73a9d2$var$IV[2] | 0;\n        this.D = $510ad3657d73a9d2$var$IV[3] | 0;\n        this.E = $510ad3657d73a9d2$var$IV[4] | 0;\n        this.F = $510ad3657d73a9d2$var$IV[5] | 0;\n        this.G = $510ad3657d73a9d2$var$IV[6] | 0;\n        this.H = $510ad3657d73a9d2$var$IV[7] | 0;\n    }\n    get() {\n        const { A: A, B: B, C: C, D: D, E: E, F: F, G: G, H: H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)$510ad3657d73a9d2$var$SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = $510ad3657d73a9d2$var$SHA256_W[i - 15];\n            const W2 = $510ad3657d73a9d2$var$SHA256_W[i - 2];\n            const s0 = (0, $29ee4d3171d9809b$exports.rotr)(W15, 7) ^ (0, $29ee4d3171d9809b$exports.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0, $29ee4d3171d9809b$exports.rotr)(W2, 17) ^ (0, $29ee4d3171d9809b$exports.rotr)(W2, 19) ^ W2 >>> 10;\n            $510ad3657d73a9d2$var$SHA256_W[i] = s1 + $510ad3657d73a9d2$var$SHA256_W[i - 7] + s0 + $510ad3657d73a9d2$var$SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A: A, B: B, C: C, D: D, E: E, F: F, G: G, H: H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0, $29ee4d3171d9809b$exports.rotr)(E, 6) ^ (0, $29ee4d3171d9809b$exports.rotr)(E, 11) ^ (0, $29ee4d3171d9809b$exports.rotr)(E, 25);\n            const T1 = H + sigma1 + $510ad3657d73a9d2$var$Chi(E, F, G) + $510ad3657d73a9d2$var$SHA256_K[i] + $510ad3657d73a9d2$var$SHA256_W[i] | 0;\n            const sigma0 = (0, $29ee4d3171d9809b$exports.rotr)(A, 2) ^ (0, $29ee4d3171d9809b$exports.rotr)(A, 13) ^ (0, $29ee4d3171d9809b$exports.rotr)(A, 22);\n            const T2 = sigma0 + $510ad3657d73a9d2$var$Maj(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        $510ad3657d73a9d2$var$SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass $510ad3657d73a9d2$var$SHA224 extends $510ad3657d73a9d2$var$SHA256 {\n    constructor(){\n        super();\n        this.A = -1056596264;\n        this.B = 914150663;\n        this.C = 812702999;\n        this.D = -150054599;\n        this.E = -4191439;\n        this.F = 1750603025;\n        this.G = 1694076839;\n        this.H = -1090891868;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */ $510ad3657d73a9d2$exports.sha256 = (0, $29ee4d3171d9809b$exports.wrapConstructor)(()=>new $510ad3657d73a9d2$var$SHA256());\n$510ad3657d73a9d2$exports.sha224 = (0, $29ee4d3171d9809b$exports.wrapConstructor)(()=>new $510ad3657d73a9d2$var$SHA224());\n\n\n/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ const $09057b02a7b5c89d$var$P = 2n ** 255n - 19n; // ed25519 is twisted edwards curve\nconst $09057b02a7b5c89d$var$N = 2n ** 252n + 27742317777372353535851937790883648493n; // curve's (group) order\nconst $09057b02a7b5c89d$var$Gx = 0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an; // base point x\nconst $09057b02a7b5c89d$var$Gy = 0x6666666666666666666666666666666666666666666666666666666666666658n; // base point y\nconst $09057b02a7b5c89d$export$8ff8607b70325343 = {\n    a: -1n,\n    d: 37095705934669439343138083508754565189542113879843219016388785533085940283555n,\n    p: $09057b02a7b5c89d$var$P,\n    n: $09057b02a7b5c89d$var$N,\n    h: 8,\n    Gx: $09057b02a7b5c89d$var$Gx,\n    Gy: $09057b02a7b5c89d$var$Gy // field prime, curve (group) order, cofactor\n};\nconst $09057b02a7b5c89d$var$err = (m = \"\")=>{\n    throw new Error(m);\n}; // error helper, messes-up stack trace\nconst $09057b02a7b5c89d$var$str = (s)=>typeof s === \"string\"; // is string\nconst $09057b02a7b5c89d$var$au8 = (a, l)=>!(a instanceof Uint8Array) || typeof l === \"number\" && l > 0 && a.length !== l ? $09057b02a7b5c89d$var$err(\"Uint8Array expected\") : a;\nconst $09057b02a7b5c89d$var$u8n = (data)=>new Uint8Array(data); // creates Uint8Array\nconst $09057b02a7b5c89d$var$toU8 = (a, len)=>$09057b02a7b5c89d$var$au8($09057b02a7b5c89d$var$str(a) ? $09057b02a7b5c89d$var$h2b(a) : $09057b02a7b5c89d$var$u8n(a), len); // norm(hex/u8a) to u8a\nconst $09057b02a7b5c89d$var$mod = (a, b = $09057b02a7b5c89d$var$P)=>{\n    let r = a % b;\n    return r >= 0n ? r : b + r;\n}; // mod division\nconst $09057b02a7b5c89d$var$isPoint = (p)=>p instanceof $09057b02a7b5c89d$export$c82dbe8d384844da ? p : $09057b02a7b5c89d$var$err(\"Point expected\"); // is xyzt point\nlet $09057b02a7b5c89d$var$Gpows = undefined; // precomputes for base point G\nclass $09057b02a7b5c89d$export$c82dbe8d384844da {\n    constructor(ex, ey, ez, et){\n        this.ex = ex;\n        this.ey = ey;\n        this.ez = ez;\n        this.et = et;\n    }\n    static fromAffine(p) {\n        return new $09057b02a7b5c89d$export$c82dbe8d384844da(p.x, p.y, 1n, $09057b02a7b5c89d$var$mod(p.x * p.y));\n    }\n    static fromHex(hex, strict = true) {\n        const { d: d } = $09057b02a7b5c89d$export$8ff8607b70325343;\n        hex = $09057b02a7b5c89d$var$toU8(hex, 32);\n        const normed = hex.slice(); // copy the array to not mess it up\n        normed[31] = hex[31] & -129; // adjust first LE byte = last BE byte\n        const y = $09057b02a7b5c89d$var$b2n_LE(normed); // decode as little-endian, convert to num\n        if (y === 0n) ;\n        else {\n            if (strict && !(0n < y && y < $09057b02a7b5c89d$var$P)) $09057b02a7b5c89d$var$err(\"bad y coord 1\"); // strict=true [1..P-1]\n            if (!strict && !(0n < y && y < 2n ** 256n)) $09057b02a7b5c89d$var$err(\"bad y coord 2\"); // strict=false [1..2^256-1]\n        }\n        const y2 = $09057b02a7b5c89d$var$mod(y * y); // y²\n        const u = $09057b02a7b5c89d$var$mod(y2 - 1n); // u=y²-1\n        const v = $09057b02a7b5c89d$var$mod(d * y2 + 1n); // v=dy²+1\n        let { isValid: isValid, value: x } = $09057b02a7b5c89d$var$uvRatio(u, v); // (uv³)(uv⁷)^(p-5)/8; square root\n        if (!isValid) $09057b02a7b5c89d$var$err(\"bad y coordinate 3\"); // not square root: bad point\n        const isXOdd = (x & 1n) === 1n; // adjust sign of x coordinate\n        const isHeadOdd = (hex[31] & 0x80) !== 0;\n        if (isHeadOdd !== isXOdd) x = $09057b02a7b5c89d$var$mod(-x);\n        return new $09057b02a7b5c89d$export$c82dbe8d384844da(x, y, 1n, $09057b02a7b5c89d$var$mod(x * y)); // Z=1, T=xy\n    }\n    get x() {\n        return this.toAffine().x;\n    }\n    get y() {\n        return this.toAffine().y;\n    }\n    equals(other) {\n        const { ex: X1, ey: Y1, ez: Z1 } = this;\n        const { ex: X2, ey: Y2, ez: Z2 } = $09057b02a7b5c89d$var$isPoint(other); // isPoint() checks class equality\n        const X1Z2 = $09057b02a7b5c89d$var$mod(X1 * Z2), X2Z1 = $09057b02a7b5c89d$var$mod(X2 * Z1);\n        const Y1Z2 = $09057b02a7b5c89d$var$mod(Y1 * Z2), Y2Z1 = $09057b02a7b5c89d$var$mod(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    is0() {\n        return this.equals($09057b02a7b5c89d$var$I);\n    }\n    negate() {\n        return new $09057b02a7b5c89d$export$c82dbe8d384844da($09057b02a7b5c89d$var$mod(-this.ex), this.ey, this.ez, $09057b02a7b5c89d$var$mod(-this.et));\n    }\n    double() {\n        const { ex: X1, ey: Y1, ez: Z1 } = this; // Cost: 4M + 4S + 1*a + 6add + 1*2\n        const { a: a } = $09057b02a7b5c89d$export$8ff8607b70325343; // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        const A = $09057b02a7b5c89d$var$mod(X1 * X1);\n        const B = $09057b02a7b5c89d$var$mod(Y1 * Y1);\n        const C = $09057b02a7b5c89d$var$mod(2n * $09057b02a7b5c89d$var$mod(Z1 * Z1));\n        const D = $09057b02a7b5c89d$var$mod(a * A);\n        const x1y1 = X1 + Y1;\n        const E = $09057b02a7b5c89d$var$mod($09057b02a7b5c89d$var$mod(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = $09057b02a7b5c89d$var$mod(E * F);\n        const Y3 = $09057b02a7b5c89d$var$mod(G * H);\n        const T3 = $09057b02a7b5c89d$var$mod(E * H);\n        const Z3 = $09057b02a7b5c89d$var$mod(F * G);\n        return new $09057b02a7b5c89d$export$c82dbe8d384844da(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this; // Cost: 8M + 1*k + 8add + 1*2.\n        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = $09057b02a7b5c89d$var$isPoint(other); // doesn't check if other on-curve\n        const { a: a, d: d } = $09057b02a7b5c89d$export$8ff8607b70325343; // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3\n        const A = $09057b02a7b5c89d$var$mod(X1 * X2);\n        const B = $09057b02a7b5c89d$var$mod(Y1 * Y2);\n        const C = $09057b02a7b5c89d$var$mod(T1 * d * T2);\n        const D = $09057b02a7b5c89d$var$mod(Z1 * Z2);\n        const E = $09057b02a7b5c89d$var$mod((X1 + Y1) * (X2 + Y2) - A - B);\n        const F = $09057b02a7b5c89d$var$mod(D - C);\n        const G = $09057b02a7b5c89d$var$mod(D + C);\n        const H = $09057b02a7b5c89d$var$mod(B - a * A);\n        const X3 = $09057b02a7b5c89d$var$mod(E * F);\n        const Y3 = $09057b02a7b5c89d$var$mod(G * H);\n        const T3 = $09057b02a7b5c89d$var$mod(E * H);\n        const Z3 = $09057b02a7b5c89d$var$mod(F * G);\n        return new $09057b02a7b5c89d$export$c82dbe8d384844da(X3, Y3, Z3, T3);\n    }\n    mul(n, safe = true) {\n        if (n === 0n) return safe === true ? $09057b02a7b5c89d$var$err(\"cannot multiply by 0\") : $09057b02a7b5c89d$var$I;\n        if (!(typeof n === \"bigint\" && 0n < n && n < $09057b02a7b5c89d$var$N)) $09057b02a7b5c89d$var$err(\"invalid scalar, must be < L\");\n        if (!safe && this.is0() || n === 1n) return this; // safe=true bans 0. safe=false allows 0.\n        if (this.equals($09057b02a7b5c89d$var$G)) return $09057b02a7b5c89d$var$wNAF(n).p; // use wNAF precomputes for base points\n        let p = $09057b02a7b5c89d$var$I, f = $09057b02a7b5c89d$var$G; // init result point & fake point\n        for(let d = this; n > 0n; d = d.double(), n >>= 1n){\n            if (n & 1n) p = p.add(d); // if bit is present, add to point\n            else if (safe) f = f.add(d); // if not, add to fake for timing safety\n        }\n        return p;\n    }\n    multiply(scalar) {\n        return this.mul(scalar);\n    }\n    clearCofactor() {\n        return this.mul(BigInt($09057b02a7b5c89d$export$8ff8607b70325343.h), false);\n    }\n    isSmallOrder() {\n        return this.clearCofactor().is0();\n    }\n    isTorsionFree() {\n        let p = this.mul($09057b02a7b5c89d$var$N / 2n, false).double(); // ensures the point is not \"bad\".\n        if ($09057b02a7b5c89d$var$N % 2n) p = p.add(this); // P^(N+1)             // P*N == (P*(N/2))*2+P\n        return p.is0();\n    }\n    toAffine() {\n        const { ex: x, ey: y, ez: z } = this; // (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy)\n        if (this.is0()) return {\n            x: 0n,\n            y: 0n\n        }; // fast-path for zero point\n        const iz = $09057b02a7b5c89d$var$invert(z); // z^-1: invert z\n        if ($09057b02a7b5c89d$var$mod(z * iz) !== 1n) $09057b02a7b5c89d$var$err(\"invalid inverse\"); // (z * z^-1) must be 1, otherwise bad math\n        return {\n            x: $09057b02a7b5c89d$var$mod(x * iz),\n            y: $09057b02a7b5c89d$var$mod(y * iz)\n        }; // x = x*z^-1; y = y*z^-1\n    }\n    toRawBytes() {\n        const { x: x, y: y } = this.toAffine(); // convert to affine 2d point\n        const b = $09057b02a7b5c89d$var$n2b_32LE(y); // encode number to 32 bytes\n        b[31] |= x & 1n ? 0x80 : 0; // store sign in first LE byte\n        return b;\n    }\n    toHex() {\n        return $09057b02a7b5c89d$var$b2h(this.toRawBytes());\n    }\n}\n$09057b02a7b5c89d$export$c82dbe8d384844da.BASE = new $09057b02a7b5c89d$export$c82dbe8d384844da($09057b02a7b5c89d$var$Gx, $09057b02a7b5c89d$var$Gy, 1n, $09057b02a7b5c89d$var$mod($09057b02a7b5c89d$var$Gx * $09057b02a7b5c89d$var$Gy)); // Generator / Base point\n$09057b02a7b5c89d$export$c82dbe8d384844da.ZERO = new $09057b02a7b5c89d$export$c82dbe8d384844da(0n, 1n, 1n, 0n); // Identity / Zero point\nconst { BASE: $09057b02a7b5c89d$var$G, ZERO: $09057b02a7b5c89d$var$I } = $09057b02a7b5c89d$export$c82dbe8d384844da; // Generator, identity points\nconst $09057b02a7b5c89d$var$padh = (num, pad)=>num.toString(16).padStart(pad, \"0\");\nconst $09057b02a7b5c89d$var$b2h = (b)=>Array.from(b).map((e)=>$09057b02a7b5c89d$var$padh(e, 2)).join(\"\"); // bytes to hex\nconst $09057b02a7b5c89d$var$h2b = (hex)=>{\n    const l = hex.length; // error if not string,\n    if (!$09057b02a7b5c89d$var$str(hex) || l % 2) $09057b02a7b5c89d$var$err(\"hex invalid 1\"); // or has odd length like 3, 5.\n    const arr = $09057b02a7b5c89d$var$u8n(l / 2); // create result array\n    for(let i = 0; i < arr.length; i++){\n        const j = i * 2;\n        const h = hex.slice(j, j + 2); // hexByte. slice is faster than substr\n        const b = Number.parseInt(h, 16); // byte, created from string part\n        if (Number.isNaN(b) || b < 0) $09057b02a7b5c89d$var$err(\"hex invalid 2\"); // byte must be valid 0 <= byte < 256\n        arr[i] = b;\n    }\n    return arr;\n};\nconst $09057b02a7b5c89d$var$n2b_32LE = (num)=>$09057b02a7b5c89d$var$h2b($09057b02a7b5c89d$var$padh(num, 64)).reverse(); // number to bytes LE\nconst $09057b02a7b5c89d$var$b2n_LE = (b)=>BigInt(\"0x\" + $09057b02a7b5c89d$var$b2h($09057b02a7b5c89d$var$u8n($09057b02a7b5c89d$var$au8(b)).reverse())); // bytes LE to num\nconst $09057b02a7b5c89d$var$concatB = (...arrs)=>{\n    const r = $09057b02a7b5c89d$var$u8n(arrs.reduce((sum, a)=>sum + $09057b02a7b5c89d$var$au8(a).length, 0)); // create u8a of summed length\n    let pad = 0; // walk through each array,\n    arrs.forEach((a)=>{\n        r.set(a, pad);\n        pad += a.length;\n    }); // ensure they have proper type\n    return r;\n};\nconst $09057b02a7b5c89d$var$invert = (num, md = $09057b02a7b5c89d$var$P)=>{\n    if (num === 0n || md <= 0n) $09057b02a7b5c89d$var$err(\"no inverse n=\" + num + \" mod=\" + md); // no neg exponent for now\n    let a = $09057b02a7b5c89d$var$mod(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;\n    while(a !== 0n){\n        const q = b / a, r = b % a; // not constant-time\n        const m = x - u * q, n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    return b === 1n ? $09057b02a7b5c89d$var$mod(x, md) : $09057b02a7b5c89d$var$err(\"no inverse\"); // b is gcd at this point\n};\nconst $09057b02a7b5c89d$var$pow2 = (x, power)=>{\n    let r = x;\n    while(power-- > 0n){\n        r *= r;\n        r %= $09057b02a7b5c89d$var$P;\n    }\n    return r;\n};\nconst $09057b02a7b5c89d$var$pow_2_252_3 = (x)=>{\n    const x2 = x * x % $09057b02a7b5c89d$var$P; // x^2,       bits 1\n    const b2 = x2 * x % $09057b02a7b5c89d$var$P; // x^3,       bits 11\n    const b4 = $09057b02a7b5c89d$var$pow2(b2, 2n) * b2 % $09057b02a7b5c89d$var$P; // x^(2^4-1), bits 1111\n    const b5 = $09057b02a7b5c89d$var$pow2(b4, 1n) * x % $09057b02a7b5c89d$var$P; // x^(2^5-1), bits 11111\n    const b10 = $09057b02a7b5c89d$var$pow2(b5, 5n) * b5 % $09057b02a7b5c89d$var$P; // x^(2^10)\n    const b20 = $09057b02a7b5c89d$var$pow2(b10, 10n) * b10 % $09057b02a7b5c89d$var$P; // x^(2^20)\n    const b40 = $09057b02a7b5c89d$var$pow2(b20, 20n) * b20 % $09057b02a7b5c89d$var$P; // x^(2^40)\n    const b80 = $09057b02a7b5c89d$var$pow2(b40, 40n) * b40 % $09057b02a7b5c89d$var$P; // x^(2^80)\n    const b160 = $09057b02a7b5c89d$var$pow2(b80, 80n) * b80 % $09057b02a7b5c89d$var$P; // x^(2^160)\n    const b240 = $09057b02a7b5c89d$var$pow2(b160, 80n) * b80 % $09057b02a7b5c89d$var$P; // x^(2^240)\n    const b250 = $09057b02a7b5c89d$var$pow2(b240, 10n) * b10 % $09057b02a7b5c89d$var$P; // x^(2^250)\n    const pow_p_5_8 = $09057b02a7b5c89d$var$pow2(b250, 2n) * x % $09057b02a7b5c89d$var$P; // < To pow to (p+3)/8, multiply it by x.\n    return {\n        pow_p_5_8: pow_p_5_8,\n        b2: b2\n    };\n};\nconst $09057b02a7b5c89d$var$RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n; // √-1\nconst $09057b02a7b5c89d$var$uvRatio = (u, v)=>{\n    const v3 = $09057b02a7b5c89d$var$mod(v * v * v); // v³\n    const v7 = $09057b02a7b5c89d$var$mod(v3 * v3 * v); // v⁷\n    const pow = $09057b02a7b5c89d$var$pow_2_252_3(u * v7).pow_p_5_8; // (uv⁷)^(p-5)/8\n    let x = $09057b02a7b5c89d$var$mod(u * v3 * pow); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = $09057b02a7b5c89d$var$mod(v * x * x); // vx²\n    const root1 = x; // First root candidate\n    const root2 = $09057b02a7b5c89d$var$mod(x * $09057b02a7b5c89d$var$RM1); // Second root candidate; RM1 is √-1\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === $09057b02a7b5c89d$var$mod(-u); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === $09057b02a7b5c89d$var$mod(-u * $09057b02a7b5c89d$var$RM1); // There is no valid root, vx² = -u√-1\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if (($09057b02a7b5c89d$var$mod(x) & 1n) === 1n) x = $09057b02a7b5c89d$var$mod(-x); // edIsNegative\n    return {\n        isValid: useRoot1 || useRoot2,\n        value: x\n    };\n};\nconst $09057b02a7b5c89d$var$modL_LE = (hash)=>$09057b02a7b5c89d$var$mod($09057b02a7b5c89d$var$b2n_LE(hash), $09057b02a7b5c89d$var$N); // modulo L; but little-endian\nlet $09057b02a7b5c89d$var$_shaS;\nconst $09057b02a7b5c89d$var$sha512a = (...m)=>$09057b02a7b5c89d$export$ec2163bf2d3efdc.sha512Async(...m); // Async SHA512\nconst $09057b02a7b5c89d$var$sha512s = (...m)=>typeof $09057b02a7b5c89d$var$_shaS === \"function\" ? $09057b02a7b5c89d$var$_shaS(...m) : $09057b02a7b5c89d$var$err(\"etc.sha512Sync not set\");\nconst $09057b02a7b5c89d$var$hash2extK = (hashed)=>{\n    const head = hashed.slice(0, 32); // slice creates a copy, unlike subarray\n    head[0] &= 248; // Clamp bits: 0b1111_1000,\n    head[31] &= 127; // 0b0111_1111,\n    head[31] |= 64; // 0b0100_0000\n    const prefix = hashed.slice(32, 64); // private key \"prefix\"\n    const scalar = $09057b02a7b5c89d$var$modL_LE(head); // modular division over curve order\n    const point = $09057b02a7b5c89d$var$G.mul(scalar); // public key point\n    const pointBytes = point.toRawBytes(); // point serialized to Uint8Array\n    return {\n        head: head,\n        prefix: prefix,\n        scalar: scalar,\n        point: point,\n        pointBytes: pointBytes\n    };\n};\n// RFC8032 5.1.5; getPublicKey async, sync. Hash priv key and extract point.\nconst $09057b02a7b5c89d$var$getExtendedPublicKeyAsync = (priv)=>$09057b02a7b5c89d$var$sha512a($09057b02a7b5c89d$var$toU8(priv, 32)).then($09057b02a7b5c89d$var$hash2extK);\nconst $09057b02a7b5c89d$var$getExtendedPublicKey = (priv)=>$09057b02a7b5c89d$var$hash2extK($09057b02a7b5c89d$var$sha512s($09057b02a7b5c89d$var$toU8(priv, 32)));\nconst $09057b02a7b5c89d$export$709eb998bda2edb9 = (priv)=>$09057b02a7b5c89d$var$getExtendedPublicKeyAsync(priv).then((p)=>p.pointBytes);\nconst $09057b02a7b5c89d$export$889def73691f9837 = (priv)=>$09057b02a7b5c89d$var$getExtendedPublicKey(priv).pointBytes;\nfunction $09057b02a7b5c89d$var$hashFinish(asynchronous, res) {\n    if (asynchronous) return $09057b02a7b5c89d$var$sha512a(res.hashable).then(res.finish);\n    return res.finish($09057b02a7b5c89d$var$sha512s(res.hashable));\n}\nconst $09057b02a7b5c89d$var$_sign = (e, rBytes, msg)=>{\n    const { pointBytes: P, scalar: s } = e;\n    const r = $09057b02a7b5c89d$var$modL_LE(rBytes); // r was created outside, reduce it modulo L\n    const R = $09057b02a7b5c89d$var$G.mul(r).toRawBytes(); // R = [r]B\n    const hashable = $09057b02a7b5c89d$var$concatB(R, P, msg); // dom2(F, C) || R || A || PH(M)\n    const finish = (hashed)=>{\n        const S = $09057b02a7b5c89d$var$mod(r + $09057b02a7b5c89d$var$modL_LE(hashed) * s, $09057b02a7b5c89d$var$N); // S = (r + k * s) mod L; 0 <= s < l\n        return $09057b02a7b5c89d$var$au8($09057b02a7b5c89d$var$concatB(R, $09057b02a7b5c89d$var$n2b_32LE(S)), 64); // 64-byte sig: 32b R.x + 32b LE(S)\n    };\n    return {\n        hashable: hashable,\n        finish: finish\n    };\n};\nconst $09057b02a7b5c89d$export$6f6e70c01b95dccd = async (msg, privKey)=>{\n    const m = $09057b02a7b5c89d$var$toU8(msg); // RFC8032 5.1.6: sign msg with key async\n    const e = await $09057b02a7b5c89d$var$getExtendedPublicKeyAsync(privKey); // pub,prfx\n    const rBytes = await $09057b02a7b5c89d$var$sha512a(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return $09057b02a7b5c89d$var$hashFinish(true, $09057b02a7b5c89d$var$_sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\nconst $09057b02a7b5c89d$export$c5552dfdbc7cec71 = (msg, privKey)=>{\n    const m = $09057b02a7b5c89d$var$toU8(msg); // RFC8032 5.1.6: sign msg with key sync\n    const e = $09057b02a7b5c89d$var$getExtendedPublicKey(privKey); // pub,prfx\n    const rBytes = $09057b02a7b5c89d$var$sha512s(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return $09057b02a7b5c89d$var$hashFinish(false, $09057b02a7b5c89d$var$_sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\nconst $09057b02a7b5c89d$var$_verify = (sig, msg, pub)=>{\n    msg = $09057b02a7b5c89d$var$toU8(msg); // Message hex str/Bytes\n    sig = $09057b02a7b5c89d$var$toU8(sig, 64); // Signature hex str/Bytes, must be 64 bytes\n    const A = $09057b02a7b5c89d$export$c82dbe8d384844da.fromHex(pub, false); // public key A decoded\n    const R = $09057b02a7b5c89d$export$c82dbe8d384844da.fromHex(sig.slice(0, 32), false); // 0 <= R < 2^256: ZIP215 R can be >= P\n    const s = $09057b02a7b5c89d$var$b2n_LE(sig.slice(32, 64)); // Decode second half as an integer S\n    const SB = $09057b02a7b5c89d$var$G.mul(s, false); // in the range 0 <= s < L\n    const hashable = $09057b02a7b5c89d$var$concatB(R.toRawBytes(), A.toRawBytes(), msg); // dom2(F, C) || R || A || PH(M)\n    const finish = (hashed)=>{\n        const k = $09057b02a7b5c89d$var$modL_LE(hashed); // decode in little-endian, modulo L\n        const RkA = R.add(A.mul(k, false)); // [8]R + [8][k]A'\n        return RkA.add(SB.negate()).clearCofactor().is0(); // [8][S]B = [8]R + [8][k]A'\n    };\n    return {\n        hashable: hashable,\n        finish: finish\n    };\n};\n// RFC8032 5.1.7: verification async, sync\nconst $09057b02a7b5c89d$export$ba8750a015876b60 = async (s, m, p)=>$09057b02a7b5c89d$var$hashFinish(true, $09057b02a7b5c89d$var$_verify(s, m, p));\nconst $09057b02a7b5c89d$export$532244b5b8b0b4b6 = (s, m, p)=>$09057b02a7b5c89d$var$hashFinish(false, $09057b02a7b5c89d$var$_verify(s, m, p));\nconst $09057b02a7b5c89d$var$cr = ()=>typeof globalThis === \"object\" && \"crypto\" in globalThis ? globalThis.crypto : undefined;\nconst $09057b02a7b5c89d$export$ec2163bf2d3efdc = {\n    bytesToHex: $09057b02a7b5c89d$var$b2h,\n    hexToBytes: $09057b02a7b5c89d$var$h2b,\n    concatBytes: $09057b02a7b5c89d$var$concatB,\n    mod: $09057b02a7b5c89d$var$mod,\n    invert: $09057b02a7b5c89d$var$invert,\n    randomBytes: (len)=>{\n        const crypto = $09057b02a7b5c89d$var$cr(); // Can be shimmed in node.js <= 18 to prevent error:\n        // import { webcrypto } from 'node:crypto';\n        // if (!globalThis.crypto) globalThis.crypto = webcrypto;\n        if (!crypto) $09057b02a7b5c89d$var$err(\"crypto.getRandomValues must be defined\");\n        return crypto.getRandomValues($09057b02a7b5c89d$var$u8n(len));\n    },\n    sha512Async: async (...messages)=>{\n        const crypto = $09057b02a7b5c89d$var$cr();\n        if (!crypto) $09057b02a7b5c89d$var$err(\"crypto.subtle or etc.sha512Async must be defined\");\n        const m = $09057b02a7b5c89d$var$concatB(...messages);\n        return $09057b02a7b5c89d$var$u8n(await crypto.subtle.digest(\"SHA-512\", m.buffer));\n    },\n    sha512Sync: undefined\n};\nObject.defineProperties($09057b02a7b5c89d$export$ec2163bf2d3efdc, {\n    sha512Sync: {\n        configurable: false,\n        get () {\n            return $09057b02a7b5c89d$var$_shaS;\n        },\n        set (f) {\n            if (!$09057b02a7b5c89d$var$_shaS) $09057b02a7b5c89d$var$_shaS = f;\n        }\n    }\n});\nconst $09057b02a7b5c89d$export$eab97d15b1788b8d = {\n    getExtendedPublicKeyAsync: $09057b02a7b5c89d$var$getExtendedPublicKeyAsync,\n    getExtendedPublicKey: $09057b02a7b5c89d$var$getExtendedPublicKey,\n    randomPrivateKey: ()=>$09057b02a7b5c89d$export$ec2163bf2d3efdc.randomBytes(32),\n    precompute (w = 8, p = $09057b02a7b5c89d$var$G) {\n        p.multiply(3n);\n        return p;\n    }\n};\nconst $09057b02a7b5c89d$var$W = 8; // Precomputes-related code. W = window size\nconst $09057b02a7b5c89d$var$precompute = ()=>{\n    const points = []; // 10x sign(), 2x verify(). To achieve this,\n    const windows = 256 / $09057b02a7b5c89d$var$W + 1; // app needs to spend 40ms+ to calculate\n    let p = $09057b02a7b5c89d$var$G, b = p; // a lot of points related to base point G.\n    for(let w = 0; w < windows; w++){\n        b = p; // any time Gx multiplication is done.\n        points.push(b); // They consume 16-32 MiB of RAM.\n        for(let i = 1; i < 2 ** ($09057b02a7b5c89d$var$W - 1); i++){\n            b = b.add(p);\n            points.push(b);\n        }\n        p = b.double(); // Precomputes don't speed-up getSharedKey,\n    } // which multiplies user point by scalar,\n    return points; // when precomputes are using base point\n};\nconst $09057b02a7b5c89d$var$wNAF = (n)=>{\n    // Compared to other point mult methods,\n    const comp = $09057b02a7b5c89d$var$Gpows || ($09057b02a7b5c89d$var$Gpows = $09057b02a7b5c89d$var$precompute()); // stores 2x less points using subtraction\n    const neg = (cnd, p)=>{\n        let n = p.negate();\n        return cnd ? n : p;\n    }; // negate\n    let p = $09057b02a7b5c89d$var$I, f = $09057b02a7b5c89d$var$G; // f must be G, or could become I in the end\n    const windows = 1 + 256 / $09057b02a7b5c89d$var$W; // W=8 17 windows\n    const wsize = 2 ** ($09057b02a7b5c89d$var$W - 1); // W=8 128 window size\n    const mask = BigInt(2 ** $09057b02a7b5c89d$var$W - 1); // W=8 will create mask 0b11111111\n    const maxNum = 2 ** $09057b02a7b5c89d$var$W; // W=8 256\n    const shiftBy = BigInt($09057b02a7b5c89d$var$W); // W=8 8\n    for(let w = 0; w < windows; w++){\n        const off = w * wsize;\n        let wbits = Number(n & mask); // extract W bits.\n        n >>= shiftBy; // shift number by W bits.\n        if (wbits > wsize) {\n            wbits -= maxNum;\n            n += 1n;\n        } // split if bits > max: +224 => 256-32\n        const off1 = off, off2 = off + Math.abs(wbits) - 1; // offsets, evaluate both\n        const cnd1 = w % 2 !== 0, cnd2 = wbits < 0; // conditions, evaluate both\n        if (wbits === 0) f = f.add(neg(cnd1, comp[off1])); // bits are 0: add garbage to fake point\n        else p = p.add(neg(cnd2, comp[off2])); // bits are 1: add to result point\n    }\n    return {\n        p: p,\n        f: f\n    }; // return both real and fake points for JIT\n}; // !! you can disable precomputes by commenting-out call of the wNAF() inside Point#mul()\n // envs like browser console\n\n\n$09057b02a7b5c89d$export$ec2163bf2d3efdc.sha512Sync = (...m)=>(0, $2579977b4e52adba$exports.sha512)($09057b02a7b5c89d$export$ec2163bf2d3efdc.concatBytes(...m));\nfunction $e445fbc70464835e$var$encodeVarint(value) {\n    if (value < 0 || value > 127) throw new Error(\"This implementation supports values between 0 and 127.\");\n    return new Uint8Array([\n        value\n    ]);\n}\nconst $e445fbc70464835e$export$bac36060836195f9 = async (data)=>{\n    const hash = (0, $510ad3657d73a9d2$exports.sha256)(data);\n    //  const hash = createHash(\"sha256\").update(data).digest();\n    const hashCode = $e445fbc70464835e$var$encodeVarint(0x12);\n    const hashLength = $e445fbc70464835e$var$encodeVarint(hash.length);\n    const multihash = new Uint8Array([\n        ...hashCode,\n        ...hashLength,\n        ...hash\n    ]);\n    return Array.from(multihash).map((b)=>b.toString(16).padStart(2, \"0\")).join(\"\");\n};\nconst $e445fbc70464835e$export$66041b2c45c82689 = async (data)=>{\n    return $e445fbc70464835e$export$bac36060836195f9(data);\n};\nconst $e445fbc70464835e$export$20dc3b6680c7edd7 = async (text)=>{\n    const encoded = new TextEncoder().encode(text);\n    return $e445fbc70464835e$export$66041b2c45c82689(encoded);\n};\nconst $e445fbc70464835e$export$c4948c4499ef2797 = async ()=>{\n    const privateKey = $09057b02a7b5c89d$export$eab97d15b1788b8d.randomPrivateKey(); // Assuming this is how your library generates a random private key\n    const publicKey = await $09057b02a7b5c89d$export$709eb998bda2edb9(privateKey); // Assuming this is how your library gets the public key from the private key\n    return {\n        privateKey: privateKey,\n        publicKey: publicKey\n    };\n};\n\n\n\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */ /* eslint-disable no-proto */ var $51861dfc7ca9d588$export$a143d493d941bafc;\nvar $51861dfc7ca9d588$export$e4cf37d7f6fb9e0a;\nvar $51861dfc7ca9d588$export$f99ded8fe4b79145;\nvar $51861dfc7ca9d588$export$599f31c3813fae4d;\n\"use strict\";\nvar $eeb0961446aae8e3$export$a48f0734ac7c2329;\nvar $eeb0961446aae8e3$export$d622b2ad8d90c771;\nvar $eeb0961446aae8e3$export$6100ba28696e12de;\n\"use strict\";\n$eeb0961446aae8e3$export$a48f0734ac7c2329 = $eeb0961446aae8e3$var$byteLength;\n$eeb0961446aae8e3$export$d622b2ad8d90c771 = $eeb0961446aae8e3$var$toByteArray;\n$eeb0961446aae8e3$export$6100ba28696e12de = $eeb0961446aae8e3$var$fromByteArray;\nvar $eeb0961446aae8e3$var$lookup = [];\nvar $eeb0961446aae8e3$var$revLookup = [];\nvar $eeb0961446aae8e3$var$Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\nvar $eeb0961446aae8e3$var$code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nfor(var $eeb0961446aae8e3$var$i = 0, $eeb0961446aae8e3$var$len = $eeb0961446aae8e3$var$code.length; $eeb0961446aae8e3$var$i < $eeb0961446aae8e3$var$len; ++$eeb0961446aae8e3$var$i){\n    $eeb0961446aae8e3$var$lookup[$eeb0961446aae8e3$var$i] = $eeb0961446aae8e3$var$code[$eeb0961446aae8e3$var$i];\n    $eeb0961446aae8e3$var$revLookup[$eeb0961446aae8e3$var$code.charCodeAt($eeb0961446aae8e3$var$i)] = $eeb0961446aae8e3$var$i;\n}\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n$eeb0961446aae8e3$var$revLookup[\"-\".charCodeAt(0)] = 62;\n$eeb0961446aae8e3$var$revLookup[\"_\".charCodeAt(0)] = 63;\nfunction $eeb0961446aae8e3$var$getLens(b64) {\n    var len = b64.length;\n    if (len % 4 > 0) throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    // Trim off extra bytes after placeholder bytes are found\n    // See: https://github.com/beatgammit/base64-js/issues/42\n    var validLen = b64.indexOf(\"=\");\n    if (validLen === -1) validLen = len;\n    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n    return [\n        validLen,\n        placeHoldersLen\n    ];\n}\n// base64 is 4/3 + up to two characters of the original data\nfunction $eeb0961446aae8e3$var$byteLength(b64) {\n    var lens = $eeb0961446aae8e3$var$getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction $eeb0961446aae8e3$var$_byteLength(b64, validLen, placeHoldersLen) {\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction $eeb0961446aae8e3$var$toByteArray(b64) {\n    var tmp;\n    var lens = $eeb0961446aae8e3$var$getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    var arr = new $eeb0961446aae8e3$var$Arr($eeb0961446aae8e3$var$_byteLength(b64, validLen, placeHoldersLen));\n    var curByte = 0;\n    // if there are placeholders, only get up to the last complete 4 chars\n    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n    var i;\n    for(i = 0; i < len; i += 4){\n        tmp = $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i)] << 18 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 1)] << 12 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 2)] << 6 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 3)];\n        arr[curByte++] = tmp >> 16 & 0xFF;\n        arr[curByte++] = tmp >> 8 & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 2) {\n        tmp = $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i)] << 2 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 1) {\n        tmp = $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i)] << 10 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 1)] << 4 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    return arr;\n}\nfunction $eeb0961446aae8e3$var$tripletToBase64(num) {\n    return $eeb0961446aae8e3$var$lookup[num >> 18 & 0x3F] + $eeb0961446aae8e3$var$lookup[num >> 12 & 0x3F] + $eeb0961446aae8e3$var$lookup[num >> 6 & 0x3F] + $eeb0961446aae8e3$var$lookup[num & 0x3F];\n}\nfunction $eeb0961446aae8e3$var$encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for(var i = start; i < end; i += 3){\n        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n        output.push($eeb0961446aae8e3$var$tripletToBase64(tmp));\n    }\n    return output.join(\"\");\n}\nfunction $eeb0961446aae8e3$var$fromByteArray(uint8) {\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n    ;\n    var parts = [];\n    var maxChunkLength = 16383 // must be multiple of 3\n    ;\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push($eeb0961446aae8e3$var$encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        parts.push($eeb0961446aae8e3$var$lookup[tmp >> 2] + $eeb0961446aae8e3$var$lookup[tmp << 4 & 0x3F] + \"==\");\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        parts.push($eeb0961446aae8e3$var$lookup[tmp >> 10] + $eeb0961446aae8e3$var$lookup[tmp >> 4 & 0x3F] + $eeb0961446aae8e3$var$lookup[tmp << 2 & 0x3F] + \"=\");\n    }\n    return parts.join(\"\");\n}\n\n\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ var $7221566bd4d49f44$export$aafa59e2e03f2942;\nvar $7221566bd4d49f44$export$68d8715fc104d294;\n$7221566bd4d49f44$export$aafa59e2e03f2942 = function(buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? nBytes - 1 : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & (1 << -nBits) - 1;\n    s >>= -nBits;\n    nBits += eLen;\n    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n    m = e & (1 << -nBits) - 1;\n    e >>= -nBits;\n    nBits += mLen;\n    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n    if (e === 0) e = 1 - eBias;\n    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;\n    else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n$7221566bd4d49f44$export$68d8715fc104d294 = function(buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    var i = isLE ? 0 : nBytes - 1;\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n    value = Math.abs(value);\n    if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n    } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n        }\n        if (e + eBias >= 1) value += rt / c;\n        else value += rt * Math.pow(2, 1 - eBias);\n        if (value * c >= 2) {\n            e++;\n            c /= 2;\n        }\n        if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n        } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n        } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n        }\n    }\n    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n    e = e << mLen | m;\n    eLen += mLen;\n    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n    buffer[offset + i - d] |= s * 128;\n};\n\n\nconst $51861dfc7ca9d588$var$customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" // eslint-disable-line dot-notation\n ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") // eslint-disable-line dot-notation\n : null;\n$51861dfc7ca9d588$export$a143d493d941bafc = $51861dfc7ca9d588$var$Buffer;\n$51861dfc7ca9d588$export$e4cf37d7f6fb9e0a = $51861dfc7ca9d588$var$SlowBuffer;\n$51861dfc7ca9d588$export$f99ded8fe4b79145 = 50;\nconst $51861dfc7ca9d588$var$K_MAX_LENGTH = 0x7fffffff;\n$51861dfc7ca9d588$export$599f31c3813fae4d = $51861dfc7ca9d588$var$K_MAX_LENGTH;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */ $51861dfc7ca9d588$var$Buffer.TYPED_ARRAY_SUPPORT = $51861dfc7ca9d588$var$typedArraySupport();\nif (!$51861dfc7ca9d588$var$Buffer.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\nfunction $51861dfc7ca9d588$var$typedArraySupport() {\n    // Can typed array instances can be augmented?\n    try {\n        const arr = new Uint8Array(1);\n        const proto = {\n            foo: function() {\n                return 42;\n            }\n        };\n        Object.setPrototypeOf(proto, Uint8Array.prototype);\n        Object.setPrototypeOf(arr, proto);\n        return arr.foo() === 42;\n    } catch (e) {\n        return false;\n    }\n}\nObject.defineProperty($51861dfc7ca9d588$var$Buffer.prototype, \"parent\", {\n    enumerable: true,\n    get: function() {\n        if (!$51861dfc7ca9d588$var$Buffer.isBuffer(this)) return undefined;\n        return this.buffer;\n    }\n});\nObject.defineProperty($51861dfc7ca9d588$var$Buffer.prototype, \"offset\", {\n    enumerable: true,\n    get: function() {\n        if (!$51861dfc7ca9d588$var$Buffer.isBuffer(this)) return undefined;\n        return this.byteOffset;\n    }\n});\nfunction $51861dfc7ca9d588$var$createBuffer(length) {\n    if (length > $51861dfc7ca9d588$var$K_MAX_LENGTH) throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n    // Return an augmented `Uint8Array` instance\n    const buf = new Uint8Array(length);\n    Object.setPrototypeOf(buf, $51861dfc7ca9d588$var$Buffer.prototype);\n    return buf;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */ function $51861dfc7ca9d588$var$Buffer(arg, encodingOrOffset, length) {\n    // Common case.\n    if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") throw new TypeError('The \"string\" argument must be of type string. Received type number');\n        return $51861dfc7ca9d588$var$allocUnsafe(arg);\n    }\n    return $51861dfc7ca9d588$var$from(arg, encodingOrOffset, length);\n}\n$51861dfc7ca9d588$var$Buffer.poolSize = 8192 // not used by this implementation\n;\nfunction $51861dfc7ca9d588$var$from(value, encodingOrOffset, length) {\n    if (typeof value === \"string\") return $51861dfc7ca9d588$var$fromString(value, encodingOrOffset);\n    if (ArrayBuffer.isView(value)) return $51861dfc7ca9d588$var$fromArrayView(value);\n    if (value == null) throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n    if ($51861dfc7ca9d588$var$isInstance(value, ArrayBuffer) || value && $51861dfc7ca9d588$var$isInstance(value.buffer, ArrayBuffer)) return $51861dfc7ca9d588$var$fromArrayBuffer(value, encodingOrOffset, length);\n    if (typeof SharedArrayBuffer !== \"undefined\" && ($51861dfc7ca9d588$var$isInstance(value, SharedArrayBuffer) || value && $51861dfc7ca9d588$var$isInstance(value.buffer, SharedArrayBuffer))) return $51861dfc7ca9d588$var$fromArrayBuffer(value, encodingOrOffset, length);\n    if (typeof value === \"number\") throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null && valueOf !== value) return $51861dfc7ca9d588$var$Buffer.from(valueOf, encodingOrOffset, length);\n    const b = $51861dfc7ca9d588$var$fromObject(value);\n    if (b) return b;\n    if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") return $51861dfc7ca9d588$var$Buffer.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/ $51861dfc7ca9d588$var$Buffer.from = function(value, encodingOrOffset, length) {\n    return $51861dfc7ca9d588$var$from(value, encodingOrOffset, length);\n};\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf($51861dfc7ca9d588$var$Buffer.prototype, Uint8Array.prototype);\nObject.setPrototypeOf($51861dfc7ca9d588$var$Buffer, Uint8Array);\nfunction $51861dfc7ca9d588$var$assertSize(size) {\n    if (typeof size !== \"number\") throw new TypeError('\"size\" argument must be of type number');\n    else if (size < 0) throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n}\nfunction $51861dfc7ca9d588$var$alloc(size, fill, encoding) {\n    $51861dfc7ca9d588$var$assertSize(size);\n    if (size <= 0) return $51861dfc7ca9d588$var$createBuffer(size);\n    if (fill !== undefined) // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === \"string\" ? $51861dfc7ca9d588$var$createBuffer(size).fill(fill, encoding) : $51861dfc7ca9d588$var$createBuffer(size).fill(fill);\n    return $51861dfc7ca9d588$var$createBuffer(size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/ $51861dfc7ca9d588$var$Buffer.alloc = function(size, fill, encoding) {\n    return $51861dfc7ca9d588$var$alloc(size, fill, encoding);\n};\nfunction $51861dfc7ca9d588$var$allocUnsafe(size) {\n    $51861dfc7ca9d588$var$assertSize(size);\n    return $51861dfc7ca9d588$var$createBuffer(size < 0 ? 0 : $51861dfc7ca9d588$var$checked(size) | 0);\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */ $51861dfc7ca9d588$var$Buffer.allocUnsafe = function(size) {\n    return $51861dfc7ca9d588$var$allocUnsafe(size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */ $51861dfc7ca9d588$var$Buffer.allocUnsafeSlow = function(size) {\n    return $51861dfc7ca9d588$var$allocUnsafe(size);\n};\nfunction $51861dfc7ca9d588$var$fromString(string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") encoding = \"utf8\";\n    if (!$51861dfc7ca9d588$var$Buffer.isEncoding(encoding)) throw new TypeError(\"Unknown encoding: \" + encoding);\n    const length = $51861dfc7ca9d588$var$byteLength(string, encoding) | 0;\n    let buf = $51861dfc7ca9d588$var$createBuffer(length);\n    const actual = buf.write(string, encoding);\n    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual);\n    return buf;\n}\nfunction $51861dfc7ca9d588$var$fromArrayLike(array) {\n    const length = array.length < 0 ? 0 : $51861dfc7ca9d588$var$checked(array.length) | 0;\n    const buf = $51861dfc7ca9d588$var$createBuffer(length);\n    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;\n    return buf;\n}\nfunction $51861dfc7ca9d588$var$fromArrayView(arrayView) {\n    if ($51861dfc7ca9d588$var$isInstance(arrayView, Uint8Array)) {\n        const copy = new Uint8Array(arrayView);\n        return $51861dfc7ca9d588$var$fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n    }\n    return $51861dfc7ca9d588$var$fromArrayLike(arrayView);\n}\nfunction $51861dfc7ca9d588$var$fromArrayBuffer(array, byteOffset, length) {\n    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('\"offset\" is outside of buffer bounds');\n    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('\"length\" is outside of buffer bounds');\n    let buf;\n    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);\n    else if (length === undefined) buf = new Uint8Array(array, byteOffset);\n    else buf = new Uint8Array(array, byteOffset, length);\n    // Return an augmented `Uint8Array` instance\n    Object.setPrototypeOf(buf, $51861dfc7ca9d588$var$Buffer.prototype);\n    return buf;\n}\nfunction $51861dfc7ca9d588$var$fromObject(obj) {\n    if ($51861dfc7ca9d588$var$Buffer.isBuffer(obj)) {\n        const len = $51861dfc7ca9d588$var$checked(obj.length) | 0;\n        const buf = $51861dfc7ca9d588$var$createBuffer(len);\n        if (buf.length === 0) return buf;\n        obj.copy(buf, 0, 0, len);\n        return buf;\n    }\n    if (obj.length !== undefined) {\n        if (typeof obj.length !== \"number\" || $51861dfc7ca9d588$var$numberIsNaN(obj.length)) return $51861dfc7ca9d588$var$createBuffer(0);\n        return $51861dfc7ca9d588$var$fromArrayLike(obj);\n    }\n    if (obj.type === \"Buffer\" && Array.isArray(obj.data)) return $51861dfc7ca9d588$var$fromArrayLike(obj.data);\n}\nfunction $51861dfc7ca9d588$var$checked(length) {\n    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= $51861dfc7ca9d588$var$K_MAX_LENGTH) throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + $51861dfc7ca9d588$var$K_MAX_LENGTH.toString(16) + \" bytes\");\n    return length | 0;\n}\nfunction $51861dfc7ca9d588$var$SlowBuffer(length) {\n    if (+length != length) length = 0;\n    return $51861dfc7ca9d588$var$Buffer.alloc(+length);\n}\n$51861dfc7ca9d588$var$Buffer.isBuffer = function isBuffer(b) {\n    return b != null && b._isBuffer === true && b !== $51861dfc7ca9d588$var$Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n    ;\n};\n$51861dfc7ca9d588$var$Buffer.compare = function compare(a, b) {\n    if ($51861dfc7ca9d588$var$isInstance(a, Uint8Array)) a = $51861dfc7ca9d588$var$Buffer.from(a, a.offset, a.byteLength);\n    if ($51861dfc7ca9d588$var$isInstance(b, Uint8Array)) b = $51861dfc7ca9d588$var$Buffer.from(b, b.offset, b.byteLength);\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(a) || !$51861dfc7ca9d588$var$Buffer.isBuffer(b)) throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n    if (a === b) return 0;\n    let x = a.length;\n    let y = b.length;\n    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {\n        x = a[i];\n        y = b[i];\n        break;\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n$51861dfc7ca9d588$var$Buffer.isEncoding = function isEncoding(encoding) {\n    switch(String(encoding).toLowerCase()){\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return true;\n        default:\n            return false;\n    }\n};\n$51861dfc7ca9d588$var$Buffer.concat = function concat(list, length) {\n    if (!Array.isArray(list)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n    if (list.length === 0) return $51861dfc7ca9d588$var$Buffer.alloc(0);\n    let i;\n    if (length === undefined) {\n        length = 0;\n        for(i = 0; i < list.length; ++i)length += list[i].length;\n    }\n    const buffer = $51861dfc7ca9d588$var$Buffer.allocUnsafe(length);\n    let pos = 0;\n    for(i = 0; i < list.length; ++i){\n        let buf = list[i];\n        if ($51861dfc7ca9d588$var$isInstance(buf, Uint8Array)) {\n            if (pos + buf.length > buffer.length) {\n                if (!$51861dfc7ca9d588$var$Buffer.isBuffer(buf)) buf = $51861dfc7ca9d588$var$Buffer.from(buf);\n                buf.copy(buffer, pos);\n            } else Uint8Array.prototype.set.call(buffer, buf, pos);\n        } else if (!$51861dfc7ca9d588$var$Buffer.isBuffer(buf)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n        else buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\nfunction $51861dfc7ca9d588$var$byteLength(string, encoding) {\n    if ($51861dfc7ca9d588$var$Buffer.isBuffer(string)) return string.length;\n    if (ArrayBuffer.isView(string) || $51861dfc7ca9d588$var$isInstance(string, ArrayBuffer)) return string.byteLength;\n    if (typeof string !== \"string\") throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);\n    const len = string.length;\n    const mustMatch = arguments.length > 2 && arguments[2] === true;\n    if (!mustMatch && len === 0) return 0;\n    // Use a for loop to avoid recursion\n    let loweredCase = false;\n    for(;;)switch(encoding){\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n            return len;\n        case \"utf8\":\n        case \"utf-8\":\n            return $51861dfc7ca9d588$var$utf8ToBytes(string).length;\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return len * 2;\n        case \"hex\":\n            return len >>> 1;\n        case \"base64\":\n            return $51861dfc7ca9d588$var$base64ToBytes(string).length;\n        default:\n            if (loweredCase) return mustMatch ? -1 : $51861dfc7ca9d588$var$utf8ToBytes(string).length // assume utf8\n            ;\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n    }\n}\n$51861dfc7ca9d588$var$Buffer.byteLength = $51861dfc7ca9d588$var$byteLength;\nfunction $51861dfc7ca9d588$var$slowToString(encoding, start, end) {\n    let loweredCase = false;\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) start = 0;\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) return \"\";\n    if (end === undefined || end > this.length) end = this.length;\n    if (end <= 0) return \"\";\n    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) return \"\";\n    if (!encoding) encoding = \"utf8\";\n    while(true)switch(encoding){\n        case \"hex\":\n            return $51861dfc7ca9d588$var$hexSlice(this, start, end);\n        case \"utf8\":\n        case \"utf-8\":\n            return $51861dfc7ca9d588$var$utf8Slice(this, start, end);\n        case \"ascii\":\n            return $51861dfc7ca9d588$var$asciiSlice(this, start, end);\n        case \"latin1\":\n        case \"binary\":\n            return $51861dfc7ca9d588$var$latin1Slice(this, start, end);\n        case \"base64\":\n            return $51861dfc7ca9d588$var$base64Slice(this, start, end);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return $51861dfc7ca9d588$var$utf16leSlice(this, start, end);\n        default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (encoding + \"\").toLowerCase();\n            loweredCase = true;\n    }\n}\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\n$51861dfc7ca9d588$var$Buffer.prototype._isBuffer = true;\nfunction $51861dfc7ca9d588$var$swap(b, n, m) {\n    const i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.swap16 = function swap16() {\n    const len = this.length;\n    if (len % 2 !== 0) throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    for(let i = 0; i < len; i += 2)$51861dfc7ca9d588$var$swap(this, i, i + 1);\n    return this;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.swap32 = function swap32() {\n    const len = this.length;\n    if (len % 4 !== 0) throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    for(let i = 0; i < len; i += 4){\n        $51861dfc7ca9d588$var$swap(this, i, i + 3);\n        $51861dfc7ca9d588$var$swap(this, i + 1, i + 2);\n    }\n    return this;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.swap64 = function swap64() {\n    const len = this.length;\n    if (len % 8 !== 0) throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    for(let i = 0; i < len; i += 8){\n        $51861dfc7ca9d588$var$swap(this, i, i + 7);\n        $51861dfc7ca9d588$var$swap(this, i + 1, i + 6);\n        $51861dfc7ca9d588$var$swap(this, i + 2, i + 5);\n        $51861dfc7ca9d588$var$swap(this, i + 3, i + 4);\n    }\n    return this;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.toString = function toString() {\n    const length = this.length;\n    if (length === 0) return \"\";\n    if (arguments.length === 0) return $51861dfc7ca9d588$var$utf8Slice(this, 0, length);\n    return $51861dfc7ca9d588$var$slowToString.apply(this, arguments);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.toLocaleString = $51861dfc7ca9d588$var$Buffer.prototype.toString;\n$51861dfc7ca9d588$var$Buffer.prototype.equals = function equals(b) {\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(b)) throw new TypeError(\"Argument must be a Buffer\");\n    if (this === b) return true;\n    return $51861dfc7ca9d588$var$Buffer.compare(this, b) === 0;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.inspect = function inspect() {\n    let str = \"\";\n    const max = $51861dfc7ca9d588$export$f99ded8fe4b79145;\n    str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n    if (this.length > max) str += \" ... \";\n    return \"<Buffer \" + str + \">\";\n};\nif ($51861dfc7ca9d588$var$customInspectSymbol) $51861dfc7ca9d588$var$Buffer.prototype[$51861dfc7ca9d588$var$customInspectSymbol] = $51861dfc7ca9d588$var$Buffer.prototype.inspect;\n$51861dfc7ca9d588$var$Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if ($51861dfc7ca9d588$var$isInstance(target, Uint8Array)) target = $51861dfc7ca9d588$var$Buffer.from(target, target.offset, target.byteLength);\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(target)) throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);\n    if (start === undefined) start = 0;\n    if (end === undefined) end = target ? target.length : 0;\n    if (thisStart === undefined) thisStart = 0;\n    if (thisEnd === undefined) thisEnd = this.length;\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError(\"out of range index\");\n    if (thisStart >= thisEnd && start >= end) return 0;\n    if (thisStart >= thisEnd) return -1;\n    if (start >= end) return 1;\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target) return 0;\n    let x = thisEnd - thisStart;\n    let y = end - start;\n    const len = Math.min(x, y);\n    const thisCopy = this.slice(thisStart, thisEnd);\n    const targetCopy = target.slice(start, end);\n    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {\n        x = thisCopy[i];\n        y = targetCopy[i];\n        break;\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction $51861dfc7ca9d588$var$bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1;\n    // Normalize byteOffset\n    if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;\n    else if (byteOffset < -2147483648) byteOffset = -2147483648;\n    byteOffset = +byteOffset // Coerce to Number.\n    ;\n    if ($51861dfc7ca9d588$var$numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : buffer.length - 1;\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1;\n        else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;\n        else return -1;\n    }\n    // Normalize val\n    if (typeof val === \"string\") val = $51861dfc7ca9d588$var$Buffer.from(val, encoding);\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if ($51861dfc7ca9d588$var$Buffer.isBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) return -1;\n        return $51861dfc7ca9d588$var$arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n        val = val & 0xFF // Search for a byte value [0-255]\n        ;\n        if (typeof Uint8Array.prototype.indexOf === \"function\") {\n            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n        }\n        return $51861dfc7ca9d588$var$arrayIndexOf(buffer, [\n            val\n        ], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n}\nfunction $51861dfc7ca9d588$var$arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    let indexSize = 1;\n    let arrLength = arr.length;\n    let valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) return -1;\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) return buf[i];\n        else return buf.readUInt16BE(i * indexSize);\n    }\n    let i;\n    if (dir) {\n        let foundIndex = -1;\n        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n            if (foundIndex === -1) foundIndex = i;\n            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n        } else {\n            if (foundIndex !== -1) i -= i - foundIndex;\n            foundIndex = -1;\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for(i = byteOffset; i >= 0; i--){\n            let found = true;\n            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return $51861dfc7ca9d588$var$bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return $51861dfc7ca9d588$var$bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\nfunction $51861dfc7ca9d588$var$hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    const remaining = buf.length - offset;\n    if (!length) length = remaining;\n    else {\n        length = Number(length);\n        if (length > remaining) length = remaining;\n    }\n    const strLen = string.length;\n    if (length > strLen / 2) length = strLen / 2;\n    let i;\n    for(i = 0; i < length; ++i){\n        const parsed = parseInt(string.substr(i * 2, 2), 16);\n        if ($51861dfc7ca9d588$var$numberIsNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}\nfunction $51861dfc7ca9d588$var$utf8Write(buf, string, offset, length) {\n    return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction $51861dfc7ca9d588$var$asciiWrite(buf, string, offset, length) {\n    return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$asciiToBytes(string), buf, offset, length);\n}\nfunction $51861dfc7ca9d588$var$base64Write(buf, string, offset, length) {\n    return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$base64ToBytes(string), buf, offset, length);\n}\nfunction $51861dfc7ca9d588$var$ucs2Write(buf, string, offset, length) {\n    return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\n$51861dfc7ca9d588$var$Buffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n        offset = offset >>> 0;\n        if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === undefined) encoding = \"utf8\";\n        } else {\n            encoding = length;\n            length = undefined;\n        }\n    } else throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    const remaining = this.length - offset;\n    if (length === undefined || length > remaining) length = remaining;\n    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError(\"Attempt to write outside buffer bounds\");\n    if (!encoding) encoding = \"utf8\";\n    let loweredCase = false;\n    for(;;)switch(encoding){\n        case \"hex\":\n            return $51861dfc7ca9d588$var$hexWrite(this, string, offset, length);\n        case \"utf8\":\n        case \"utf-8\":\n            return $51861dfc7ca9d588$var$utf8Write(this, string, offset, length);\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n            return $51861dfc7ca9d588$var$asciiWrite(this, string, offset, length);\n        case \"base64\":\n            // Warning: maxLength not taken into account in base64Write\n            return $51861dfc7ca9d588$var$base64Write(this, string, offset, length);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return $51861dfc7ca9d588$var$ucs2Write(this, string, offset, length);\n        default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n    }\n};\n$51861dfc7ca9d588$var$Buffer.prototype.toJSON = function toJSON() {\n    return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n};\nfunction $51861dfc7ca9d588$var$base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) return $eeb0961446aae8e3$export$6100ba28696e12de(buf);\n    else return $eeb0961446aae8e3$export$6100ba28696e12de(buf.slice(start, end));\n}\nfunction $51861dfc7ca9d588$var$utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    const res = [];\n    let i = start;\n    while(i < end){\n        const firstByte = buf[i];\n        let codePoint = null;\n        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch(bytesPerSequence){\n                case 1:\n                    if (firstByte < 0x80) codePoint = firstByte;\n                    break;\n                case 2:\n                    secondByte = buf[i + 1];\n                    if ((secondByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;\n                    }\n                    break;\n                case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;\n                    }\n                    break;\n                case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;\n                    }\n            }\n        }\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n        } else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return $51861dfc7ca9d588$var$decodeCodePointsArray(res);\n}\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst $51861dfc7ca9d588$var$MAX_ARGUMENTS_LENGTH = 0x1000;\nfunction $51861dfc7ca9d588$var$decodeCodePointsArray(codePoints) {\n    const len = codePoints.length;\n    if (len <= $51861dfc7ca9d588$var$MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n    ;\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    let res = \"\";\n    let i = 0;\n    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += $51861dfc7ca9d588$var$MAX_ARGUMENTS_LENGTH));\n    return res;\n}\nfunction $51861dfc7ca9d588$var$asciiSlice(buf, start, end) {\n    let ret = \"\";\n    end = Math.min(buf.length, end);\n    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);\n    return ret;\n}\nfunction $51861dfc7ca9d588$var$latin1Slice(buf, start, end) {\n    let ret = \"\";\n    end = Math.min(buf.length, end);\n    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);\n    return ret;\n}\nfunction $51861dfc7ca9d588$var$hexSlice(buf, start, end) {\n    const len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    let out = \"\";\n    for(let i = start; i < end; ++i)out += $51861dfc7ca9d588$var$hexSliceLookupTable[buf[i]];\n    return out;\n}\nfunction $51861dfc7ca9d588$var$utf16leSlice(buf, start, end) {\n    const bytes = buf.slice(start, end);\n    let res = \"\";\n    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    return res;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.slice = function slice(start, end) {\n    const len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n    } else if (start > len) start = len;\n    if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n    } else if (end > len) end = len;\n    if (end < start) end = start;\n    const newBuf = this.subarray(start, end);\n    // Return an augmented `Uint8Array` instance\n    Object.setPrototypeOf(newBuf, $51861dfc7ca9d588$var$Buffer.prototype);\n    return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */ function $51861dfc7ca9d588$var$checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0) throw new RangeError(\"offset is not uint\");\n    if (offset + ext > length) throw new RangeError(\"Trying to access beyond buffer length\");\n}\n$51861dfc7ca9d588$var$Buffer.prototype.readUintLE = $51861dfc7ca9d588$var$Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;\n    return val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUintBE = $51861dfc7ca9d588$var$Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset + --byteLength];\n    let mul = 1;\n    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;\n    return val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint8 = $51861dfc7ca9d588$var$Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 1, this.length);\n    return this[offset];\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint16LE = $51861dfc7ca9d588$var$Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint16BE = $51861dfc7ca9d588$var$Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint32LE = $51861dfc7ca9d588$var$Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint32BE = $51861dfc7ca9d588$var$Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readBigUInt64LE = $51861dfc7ca9d588$var$defineBigIntMethod(function readBigUInt64LE(offset) {\n    offset = offset >>> 0;\n    $51861dfc7ca9d588$var$validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $51861dfc7ca9d588$var$boundsError(offset, this.length - 8);\n    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n    return BigInt(lo) + (BigInt(hi) << BigInt(32));\n});\n$51861dfc7ca9d588$var$Buffer.prototype.readBigUInt64BE = $51861dfc7ca9d588$var$defineBigIntMethod(function readBigUInt64BE(offset) {\n    offset = offset >>> 0;\n    $51861dfc7ca9d588$var$validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $51861dfc7ca9d588$var$boundsError(offset, this.length - 8);\n    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];\n    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;\n    return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n});\n$51861dfc7ca9d588$var$Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, byteLength, this.length);\n    let i = byteLength;\n    let mul = 1;\n    let val = this[offset + --i];\n    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 0x80)) return this[offset];\n    return (0xff - this[offset] + 1) * -1;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 2, this.length);\n    const val = this[offset] | this[offset + 1] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 2, this.length);\n    const val = this[offset + 1] | this[offset] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readBigInt64LE = $51861dfc7ca9d588$var$defineBigIntMethod(function readBigInt64LE(offset) {\n    offset = offset >>> 0;\n    $51861dfc7ca9d588$var$validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $51861dfc7ca9d588$var$boundsError(offset, this.length - 8);\n    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow\n    );\n    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n});\n$51861dfc7ca9d588$var$Buffer.prototype.readBigInt64BE = $51861dfc7ca9d588$var$defineBigIntMethod(function readBigInt64BE(offset) {\n    offset = offset >>> 0;\n    $51861dfc7ca9d588$var$validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $51861dfc7ca9d588$var$boundsError(offset, this.length - 8);\n    const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];\n    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);\n});\n$51861dfc7ca9d588$var$Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return $7221566bd4d49f44$export$aafa59e2e03f2942(this, offset, true, 23, 4);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return $7221566bd4d49f44$export$aafa59e2e03f2942(this, offset, false, 23, 4);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 8, this.length);\n    return $7221566bd4d49f44$export$aafa59e2e03f2942(this, offset, true, 52, 8);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 8, this.length);\n    return $7221566bd4d49f44$export$aafa59e2e03f2942(this, offset, false, 52, 8);\n};\nfunction $51861dfc7ca9d588$var$checkInt(buf, value, offset, ext, max, min) {\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n}\n$51861dfc7ca9d588$var$Buffer.prototype.writeUintLE = $51861dfc7ca9d588$var$Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        $51861dfc7ca9d588$var$checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    let mul = 1;\n    let i = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;\n    return offset + byteLength;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUintBE = $51861dfc7ca9d588$var$Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        $51861dfc7ca9d588$var$checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    let i = byteLength - 1;\n    let mul = 1;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;\n    return offset + byteLength;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint8 = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 1, 0xff, 0);\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint16LE = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 2, 0xffff, 0);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint16BE = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 2, 0xffff, 0);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n    return offset + 2;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint32LE = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 4, 0xffffffff, 0);\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 0xff;\n    return offset + 4;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint32BE = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 4, 0xffffffff, 0);\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n    return offset + 4;\n};\nfunction $51861dfc7ca9d588$var$wrtBigUInt64LE(buf, value, offset, min, max) {\n    $51861dfc7ca9d588$var$checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(0xffffffff));\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    return offset;\n}\nfunction $51861dfc7ca9d588$var$wrtBigUInt64BE(buf, value, offset, min, max) {\n    $51861dfc7ca9d588$var$checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(0xffffffff));\n    buf[offset + 7] = lo;\n    lo = lo >> 8;\n    buf[offset + 6] = lo;\n    lo = lo >> 8;\n    buf[offset + 5] = lo;\n    lo = lo >> 8;\n    buf[offset + 4] = lo;\n    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n    buf[offset + 3] = hi;\n    hi = hi >> 8;\n    buf[offset + 2] = hi;\n    hi = hi >> 8;\n    buf[offset + 1] = hi;\n    hi = hi >> 8;\n    buf[offset] = hi;\n    return offset + 8;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.writeBigUInt64LE = $51861dfc7ca9d588$var$defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n    return $51861dfc7ca9d588$var$wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n});\n$51861dfc7ca9d588$var$Buffer.prototype.writeBigUInt64BE = $51861dfc7ca9d588$var$defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n    return $51861dfc7ca9d588$var$wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n});\n$51861dfc7ca9d588$var$Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength - 1);\n        $51861dfc7ca9d588$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    let i = 0;\n    let mul = 1;\n    let sub = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength - 1);\n        $51861dfc7ca9d588$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    let i = byteLength - 1;\n    let mul = 1;\n    let sub = 0;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 1, 0x7f, -128);\n    if (value < 0) value = 0xff + value + 1;\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 2, 0x7fff, -32768);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 2, 0x7fff, -32768);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n    return offset + 2;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n    return offset + 4;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);\n    if (value < 0) value = 0xffffffff + value + 1;\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n    return offset + 4;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeBigInt64LE = $51861dfc7ca9d588$var$defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n    return $51861dfc7ca9d588$var$wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n});\n$51861dfc7ca9d588$var$Buffer.prototype.writeBigInt64BE = $51861dfc7ca9d588$var$defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n    return $51861dfc7ca9d588$var$wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n});\nfunction $51861dfc7ca9d588$var$checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n    if (offset < 0) throw new RangeError(\"Index out of range\");\n}\nfunction $51861dfc7ca9d588$var$writeFloat(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);\n    $7221566bd4d49f44$export$68d8715fc104d294(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return $51861dfc7ca9d588$var$writeFloat(this, value, offset, true, noAssert);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return $51861dfc7ca9d588$var$writeFloat(this, value, offset, false, noAssert);\n};\nfunction $51861dfc7ca9d588$var$writeDouble(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);\n    $7221566bd4d49f44$export$68d8715fc104d294(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return $51861dfc7ca9d588$var$writeDouble(this, value, offset, true, noAssert);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return $51861dfc7ca9d588$var$writeDouble(this, value, offset, false, noAssert);\n};\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n$51861dfc7ca9d588$var$Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(target)) throw new TypeError(\"argument should be a Buffer\");\n    if (!start) start = 0;\n    if (!end && end !== 0) end = this.length;\n    if (targetStart >= target.length) targetStart = target.length;\n    if (!targetStart) targetStart = 0;\n    if (end > 0 && end < start) end = start;\n    // Copy 0 bytes; we're done\n    if (end === start) return 0;\n    if (target.length === 0 || this.length === 0) return 0;\n    // Fatal error conditions\n    if (targetStart < 0) throw new RangeError(\"targetStart out of bounds\");\n    if (start < 0 || start >= this.length) throw new RangeError(\"Index out of range\");\n    if (end < 0) throw new RangeError(\"sourceEnd out of bounds\");\n    // Are we oob?\n    if (end > this.length) end = this.length;\n    if (target.length - targetStart < end - start) end = target.length - targetStart + start;\n    const len = end - start;\n    if (this === target && typeof Uint8Array.prototype.copyWithin === \"function\") // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end);\n    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n    return len;\n};\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\n$51861dfc7ca9d588$var$Buffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n        } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n        }\n        if (encoding !== undefined && typeof encoding !== \"string\") throw new TypeError(\"encoding must be a string\");\n        if (typeof encoding === \"string\" && !$51861dfc7ca9d588$var$Buffer.isEncoding(encoding)) throw new TypeError(\"Unknown encoding: \" + encoding);\n        if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") // Fast path: If `val` fits into a single byte, use that numeric value.\n            val = code;\n        }\n    } else if (typeof val === \"number\") val = val & 255;\n    else if (typeof val === \"boolean\") val = Number(val);\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) throw new RangeError(\"Out of range index\");\n    if (end <= start) return this;\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val) val = 0;\n    let i;\n    if (typeof val === \"number\") for(i = start; i < end; ++i)this[i] = val;\n    else {\n        const bytes = $51861dfc7ca9d588$var$Buffer.isBuffer(val) ? val : $51861dfc7ca9d588$var$Buffer.from(val, encoding);\n        const len = bytes.length;\n        if (len === 0) throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];\n    }\n    return this;\n};\n// CUSTOM ERRORS\n// =============\n// Simplified versions from Node, changed for Buffer-only usage\nconst $51861dfc7ca9d588$var$errors = {};\nfunction $51861dfc7ca9d588$var$E(sym, getMessage, Base) {\n    $51861dfc7ca9d588$var$errors[sym] = class NodeError extends Base {\n        constructor(){\n            super();\n            Object.defineProperty(this, \"message\", {\n                value: getMessage.apply(this, arguments),\n                writable: true,\n                configurable: true\n            });\n            // Add the error code to the name to include it in the stack trace.\n            this.name = `${this.name} [${sym}]`;\n            // Access the stack to generate the error message including the error code\n            // from the name.\n            this.stack // eslint-disable-line no-unused-expressions\n            ;\n            // Reset the name to the actual name.\n            delete this.name;\n        }\n        get code() {\n            return sym;\n        }\n        set code(value) {\n            Object.defineProperty(this, \"code\", {\n                configurable: true,\n                enumerable: true,\n                value: value,\n                writable: true\n            });\n        }\n        toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n        }\n    };\n}\n$51861dfc7ca9d588$var$E(\"ERR_BUFFER_OUT_OF_BOUNDS\", function(name) {\n    if (name) return `${name} is outside of buffer bounds`;\n    return \"Attempt to access memory outside buffer bounds\";\n}, RangeError);\n$51861dfc7ca9d588$var$E(\"ERR_INVALID_ARG_TYPE\", function(name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n}, TypeError);\n$51861dfc7ca9d588$var$E(\"ERR_OUT_OF_RANGE\", function(str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`;\n    let received = input;\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = $51861dfc7ca9d588$var$addNumericalSeparator(String(input));\n    else if (typeof input === \"bigint\") {\n        received = String(input);\n        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = $51861dfc7ca9d588$var$addNumericalSeparator(received);\n        received += \"n\";\n    }\n    msg += ` It must be ${range}. Received ${received}`;\n    return msg;\n}, RangeError);\nfunction $51861dfc7ca9d588$var$addNumericalSeparator(val) {\n    let res = \"\";\n    let i = val.length;\n    const start = val[0] === \"-\" ? 1 : 0;\n    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;\n    return `${val.slice(0, i)}${res}`;\n}\n// CHECK FUNCTIONS\n// ===============\nfunction $51861dfc7ca9d588$var$checkBounds(buf, offset, byteLength) {\n    $51861dfc7ca9d588$var$validateNumber(offset, \"offset\");\n    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) $51861dfc7ca9d588$var$boundsError(offset, buf.length - (byteLength + 1));\n}\nfunction $51861dfc7ca9d588$var$checkIntBI(value, min, max, buf, offset, byteLength) {\n    if (value > max || value < min) {\n        const n = typeof min === \"bigint\" ? \"n\" : \"\";\n        let range;\n        if (byteLength > 3) {\n            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;\n        } else range = `>= ${min}${n} and <= ${max}${n}`;\n        throw new $51861dfc7ca9d588$var$errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n    }\n    $51861dfc7ca9d588$var$checkBounds(buf, offset, byteLength);\n}\nfunction $51861dfc7ca9d588$var$validateNumber(value, name) {\n    if (typeof value !== \"number\") throw new $51861dfc7ca9d588$var$errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n}\nfunction $51861dfc7ca9d588$var$boundsError(value, length, type) {\n    if (Math.floor(value) !== value) {\n        $51861dfc7ca9d588$var$validateNumber(value, type);\n        throw new $51861dfc7ca9d588$var$errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n    }\n    if (length < 0) throw new $51861dfc7ca9d588$var$errors.ERR_BUFFER_OUT_OF_BOUNDS();\n    throw new $51861dfc7ca9d588$var$errors.ERR_OUT_OF_RANGE(type || \"offset\", `>= ${type ? 1 : 0} and <= ${length}`, value);\n}\n// HELPER FUNCTIONS\n// ================\nconst $51861dfc7ca9d588$var$INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\nfunction $51861dfc7ca9d588$var$base64clean(str) {\n    // Node takes equal signs as end of the Base64 encoding\n    str = str.split(\"=\")[0];\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = str.trim().replace($51861dfc7ca9d588$var$INVALID_BASE64_RE, \"\");\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2) return \"\";\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while(str.length % 4 !== 0)str = str + \"=\";\n    return str;\n}\nfunction $51861dfc7ca9d588$var$utf8ToBytes(string, units) {\n    units = units || Infinity;\n    let codePoint;\n    const length = string.length;\n    let leadSurrogate = null;\n    const bytes = [];\n    for(let i = 0; i < length; ++i){\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        } else if (leadSurrogate) // valid bmp char, but last char was a lead\n        {\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else throw new Error(\"Invalid code point\");\n    }\n    return bytes;\n}\nfunction $51861dfc7ca9d588$var$asciiToBytes(str) {\n    const byteArray = [];\n    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n    return byteArray;\n}\nfunction $51861dfc7ca9d588$var$utf16leToBytes(str, units) {\n    let c, hi, lo;\n    const byteArray = [];\n    for(let i = 0; i < str.length; ++i){\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}\nfunction $51861dfc7ca9d588$var$base64ToBytes(str) {\n    return $eeb0961446aae8e3$export$d622b2ad8d90c771($51861dfc7ca9d588$var$base64clean(str));\n}\nfunction $51861dfc7ca9d588$var$blitBuffer(src, dst, offset, length) {\n    let i;\n    for(i = 0; i < length; ++i){\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction $51861dfc7ca9d588$var$isInstance(obj, type) {\n    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n}\nfunction $51861dfc7ca9d588$var$numberIsNaN(obj) {\n    // For IE11 support\n    return obj !== obj // eslint-disable-line no-self-compare\n    ;\n}\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst $51861dfc7ca9d588$var$hexSliceLookupTable = function() {\n    const alphabet = \"0123456789abcdef\";\n    const table = new Array(256);\n    for(let i = 0; i < 16; ++i){\n        const i16 = i * 16;\n        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];\n    }\n    return table;\n}();\n// Return not function with Error if BigInt not supported\nfunction $51861dfc7ca9d588$var$defineBigIntMethod(fn) {\n    return typeof BigInt === \"undefined\" ? $51861dfc7ca9d588$var$BufferBigIntNotDefined : fn;\n}\nfunction $51861dfc7ca9d588$var$BufferBigIntNotDefined() {\n    throw new Error(\"BigInt not supported\");\n}\n\n\nvar $d1b6fbf03b2f6cd0$require$Buffer = $51861dfc7ca9d588$export$a143d493d941bafc;\n$09057b02a7b5c89d$export$ec2163bf2d3efdc.sha512Sync = (...m)=>(0, $2579977b4e52adba$exports.sha512)($09057b02a7b5c89d$export$ec2163bf2d3efdc.concatBytes(...m));\nclass $d1b6fbf03b2f6cd0$export$eb2cfd5dac35d0c7 {\n    constructor(privKey){\n        this.privKey = privKey;\n    }\n    generateProof(metadata) {\n        const rawMessage = JSON.stringify(metadata);\n        const message = $d1b6fbf03b2f6cd0$require$Buffer.from(rawMessage, \"utf-8\");\n        const signature = $09057b02a7b5c89d$export$c5552dfdbc7cec71(message, this.privKey);\n        return {\n            type: \"Ed25519Signature2018\",\n            created: new Date().toISOString(),\n            proofValue: $d1b6fbf03b2f6cd0$require$Buffer.from(signature).toString(\"base64\"),\n            verificationMethod: `did:example:123#key1`\n        };\n    }\n    signProfile(profile) {\n        const metadata = profile.metadata;\n        const proof = this.generateProof(metadata);\n        return {\n            metadata: metadata,\n            proof: proof\n        };\n    }\n}\nconst $d1b6fbf03b2f6cd0$export$d127222f519deaa1 = (proof, metadata, publicKey)=>{\n    const rawMessage = JSON.stringify(metadata);\n    const sigH = Uint8Array.from($d1b6fbf03b2f6cd0$require$Buffer.from(proof.proofValue, \"base64\"));\n    const msgk = Uint8Array.from($d1b6fbf03b2f6cd0$require$Buffer.from(rawMessage, \"utf8\"));\n    const isValid = $09057b02a7b5c89d$export$532244b5b8b0b4b6(sigH, msgk, publicKey);\n    return isValid;\n};\n\n\nconst $7ffc1f94643dc7e4$var$randomUUID = typeof crypto !== \"undefined\" && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nvar $7ffc1f94643dc7e4$export$2e2bcd8739ae039 = {\n    randomUUID: $7ffc1f94643dc7e4$var$randomUUID\n};\n\n\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet $568f4ee4022ba00e$var$getRandomValues;\nconst $568f4ee4022ba00e$var$rnds8 = new Uint8Array(16);\nfunction $568f4ee4022ba00e$export$2e2bcd8739ae039() {\n    // lazy load so that environments that need to polyfill have a chance to do so\n    if (!$568f4ee4022ba00e$var$getRandomValues) {\n        // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n        $568f4ee4022ba00e$var$getRandomValues = typeof crypto !== \"undefined\" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n        if (!$568f4ee4022ba00e$var$getRandomValues) throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n    }\n    return $568f4ee4022ba00e$var$getRandomValues($568f4ee4022ba00e$var$rnds8);\n}\n\n\nvar $32c496bfb6c27b56$export$2e2bcd8739ae039 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\n\n\nfunction $46d323206dcbf256$var$validate(uuid) {\n    return typeof uuid === \"string\" && (0, $32c496bfb6c27b56$export$2e2bcd8739ae039).test(uuid);\n}\nvar $46d323206dcbf256$export$2e2bcd8739ae039 = $46d323206dcbf256$var$validate;\n\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */ const $1d0137947e8554ce$var$byteToHex = [];\nfor(let i = 0; i < 256; ++i)$1d0137947e8554ce$var$byteToHex.push((i + 0x100).toString(16).slice(1));\nfunction $1d0137947e8554ce$export$8fb373d660548968(arr, offset = 0) {\n    // Note: Be careful editing this code!  It's been tuned for performance\n    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n    return $1d0137947e8554ce$var$byteToHex[arr[offset + 0]] + $1d0137947e8554ce$var$byteToHex[arr[offset + 1]] + $1d0137947e8554ce$var$byteToHex[arr[offset + 2]] + $1d0137947e8554ce$var$byteToHex[arr[offset + 3]] + \"-\" + $1d0137947e8554ce$var$byteToHex[arr[offset + 4]] + $1d0137947e8554ce$var$byteToHex[arr[offset + 5]] + \"-\" + $1d0137947e8554ce$var$byteToHex[arr[offset + 6]] + $1d0137947e8554ce$var$byteToHex[arr[offset + 7]] + \"-\" + $1d0137947e8554ce$var$byteToHex[arr[offset + 8]] + $1d0137947e8554ce$var$byteToHex[arr[offset + 9]] + \"-\" + $1d0137947e8554ce$var$byteToHex[arr[offset + 10]] + $1d0137947e8554ce$var$byteToHex[arr[offset + 11]] + $1d0137947e8554ce$var$byteToHex[arr[offset + 12]] + $1d0137947e8554ce$var$byteToHex[arr[offset + 13]] + $1d0137947e8554ce$var$byteToHex[arr[offset + 14]] + $1d0137947e8554ce$var$byteToHex[arr[offset + 15]];\n}\nfunction $1d0137947e8554ce$var$stringify(arr, offset = 0) {\n    const uuid = $1d0137947e8554ce$export$8fb373d660548968(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n    // of the following:\n    // - One or more input array values don't map to a hex octet (leading to\n    // \"undefined\" in the uuid)\n    // - Invalid input values for the RFC `version` or `variant` fields\n    if (!(0, $46d323206dcbf256$export$2e2bcd8739ae039)(uuid)) throw TypeError(\"Stringified UUID is invalid\");\n    return uuid;\n}\nvar $1d0137947e8554ce$export$2e2bcd8739ae039 = $1d0137947e8554ce$var$stringify;\n\n\nfunction $3fa3ae484854b431$var$v4(options, buf, offset) {\n    if ((0, $7ffc1f94643dc7e4$export$2e2bcd8739ae039).randomUUID && !buf && !options) return (0, $7ffc1f94643dc7e4$export$2e2bcd8739ae039).randomUUID();\n    options = options || {};\n    const rnds = options.random || (options.rng || (0, $568f4ee4022ba00e$export$2e2bcd8739ae039))(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = rnds[6] & 0x0f | 0x40;\n    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n    if (buf) {\n        offset = offset || 0;\n        for(let i = 0; i < 16; ++i)buf[offset + i] = rnds[i];\n        return buf;\n    }\n    return (0, $1d0137947e8554ce$export$8fb373d660548968)(rnds);\n}\nvar $3fa3ae484854b431$export$2e2bcd8739ae039 = $3fa3ae484854b431$var$v4;\n\n\n\nvar $2fa42e15b9a85232$require$Buffer = $51861dfc7ca9d588$export$a143d493d941bafc;\nclass $2fa42e15b9a85232$var$ProfileAPI {\n    constructor(baseUrl){\n        this.baseUrl = baseUrl;\n    }\n    async getProfile(id) {\n        const response = await fetch(`${this.baseUrl}/profiles/${id}`);\n        if (!response.ok) throw new Error(\"Failed to get profile\");\n        return response.json();\n    }\n    async validateProfile(profile) {\n        const resp = await fetch(`${this.baseUrl}/validate/profile`, {\n            method: \"POST\",\n            body: JSON.stringify(profile),\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        return resp.json();\n    }\n    async resolveDID(did) {\n        const response = await fetch(`${this.baseUrl}/resolve?did=${did}`);\n        if (!response.ok) throw new Error(\"Failed to resolve DID\");\n        return response.json();\n    }\n    async referenceProfile(url) {\n        const response = await fetch(`${this.baseUrl}/reference?url=${url}`);\n        if (!response.ok) throw new Error(\"Failed to reference profile\");\n        return response.json();\n    }\n    async storeProfile(profile) {\n        const response = await fetch(`${this.baseUrl}/profiles`, {\n            method: \"POST\",\n            body: JSON.stringify(profile),\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        if (!response.ok) throw new Error(\"Failed to store profile\");\n        return response.json();\n    }\n    async getProfiles() {\n        const response = await fetch(`${this.baseUrl}/profiles`);\n        if (!response.ok) throw new Error(\"Failed to get profiles\");\n        return response.json();\n    }\n}\nconst $2fa42e15b9a85232$var$profileAPI = new $2fa42e15b9a85232$var$ProfileAPI(\"https://service-profile-api.andor.us/api\");\nconst $2fa42e15b9a85232$var$validate = ()=>{\n    console.log(\"DOM content loaded\");\n    try {\n        if (!document) throw new Error(\"Document not found\");\n        const validateButton = document.getElementById(\"validateButton\");\n        if (!validateButton) throw new Error(\"Validate button not found\");\n        validateButton.addEventListener(\"click\", async ()=>{\n            console.log(\"validating\");\n            const profileData = document.getElementById(\"profileData\");\n            if (!profileData) document.getElementById(\"validationResult\").textContent = \"Profile data not found\";\n            // @ts-ignore\n            const profileDataText = profileData.value;\n            try {\n                const profileData = JSON.parse(profileDataText);\n                const isValid = (0, $151113e9b29588b6$export$5ea2dbb44eae89d6).validate(profileData);\n                if (isValid) document.getElementById(\"validationResult\").textContent = \"Profile is valid\";\n                else document.getElementById(\"validationResult\").textContent = \"Profile is not valid\";\n            } catch (error) {\n                document.getElementById(\"validationResult\").textContent = \"Error parsing profile data: \" + error;\n            }\n        });\n    } catch (error) {\n        alert(\"Error: \" + error);\n    }\n};\nlet $2fa42e15b9a85232$var$privateKey;\nconst $2fa42e15b9a85232$var$generateKeys = async ()=>{\n    const ppk = await (0, $e445fbc70464835e$export$c4948c4499ef2797)();\n    $2fa42e15b9a85232$var$privateKey = ppk.privateKey;\n    console.log(\"generated key: \", $2fa42e15b9a85232$var$privateKey);\n};\nconst $2fa42e15b9a85232$var$resolvers = ()=>{\n    console.log(\"adding resolvers\");\n    document.getElementById(\"resolveDID\")?.addEventListener(\"click\", async ()=>{\n        const resolvedDIDResult = document.getElementById(\"resolvedDIDResult\");\n        if (!resolvedDIDResult) alert(\"DOM Element not found for resolvedDIDResult\");\n        try {\n            const didInput = document.getElementById(\"didInput\");\n            if (!didInput) resolvedDIDResult.textContent = \"DID input not found\";\n            // @ts-ignore\n            const did = didInput.value;\n            const doc = await (0, $afbb33d5df9729d3$export$bb95c122214a8b29)(did);\n            if (!doc || !doc.service || doc.service.length === 0) resolvedDIDResult.textContent = \"DID not resolved\";\n            const profile = await (0, $443fec48b5d8e69c$export$b35af804a0ff5bd0)(doc.service[0].serviceEndpoint.profile);\n            resolvedDIDResult.textContent = JSON.stringify(profile, null, 2);\n        //const resolved = await profileAPI.resolveDID(did);\n        } catch (error) {\n            if (!resolvedDIDResult) alert(\"Error: \" + error);\n            resolvedDIDResult.textContent = \"Error resolving DID: \" + error;\n        }\n    });\n};\nconst $2fa42e15b9a85232$var$reference = ()=>{\n    console.log(\"adding resolvers\");\n    document.getElementById(\"referenceProfile\")?.addEventListener(\"click\", async ()=>{\n        const resolvedProfileResult = document.getElementById(\"referenceProfileResult\");\n        try {\n            const urlInput = document.getElementById(\"referenceProfileInput\");\n            if (!urlInput) {\n                resolvedProfileResult.textContent = \"URL input not found\";\n                return;\n            }\n            console.log(urlInput);\n            // @ts-ignore\n            const url = urlInput.value;\n            const response = await fetch(url, {\n                method: \"GET\"\n            });\n            if (!response.ok) {\n                resolvedProfileResult.textContent = \"Network response was not ok.\";\n                return;\n            }\n            const text = await response.text();\n            const buffer = $2fa42e15b9a85232$require$Buffer.from(text);\n            const integrity = await (0, $e445fbc70464835e$export$bac36060836195f9)(buffer);\n            const reference = {\n                integrity: integrity,\n                profile: url,\n                uri: \"<insert service uri here>\"\n            };\n            console.log(JSON.stringify(reference, null, 2));\n            //       const resolved = await profileAPI.referenceProfile(url);\n            if (!resolvedProfileResult) alert(\"Resolved DID: \" + JSON.stringify(reference, null, 2));\n            resolvedProfileResult.textContent = JSON.stringify(reference, null, 2);\n        } catch (error) {\n            if (!resolvedProfileResult) alert(\"Error: \" + error);\n            resolvedProfileResult.textContent = \"Error resolving DID: \" + error;\n        }\n    });\n};\nconst $2fa42e15b9a85232$var$downloadKeyListener = ()=>{\n    const downloadKeyButton = document.getElementById(\"downloadPrivateKey\");\n    if (!downloadKeyButton) throw new Error(\"Download key button not found\");\n    downloadKeyButton.addEventListener(\"click\", async ()=>{\n        const blob = new Blob([\n            $2fa42e15b9a85232$var$privateKey\n        ], {\n            type: \"text/plain\"\n        });\n        const url = window.URL.createObjectURL(blob);\n        const a = document.createElement(\"a\");\n        a.href = url;\n        a.download = \"privateKey.txt\";\n        a.click();\n    });\n};\nconst $2fa42e15b9a85232$var$generateProfile = ()=>{\n    console.log(\"adding generateProfile\");\n    const form = document.getElementById(\"generateProfileForm\");\n    if (!form) throw new Error(\"Form not found\");\n    const profileResult = document.getElementById(\"generatedProfileResult\");\n    form.addEventListener(\"submit\", async (event)=>{\n        event.preventDefault();\n        const form = event.target;\n        const formData = new FormData(form);\n        let meta = {};\n        formData.forEach((value, key)=>{\n            const metadataKey = key;\n            if (key === \"supported_protocols\" || key === \"tags\") // @ts-ignore\n            meta[metadataKey] = value.toString().split(\",\").map((tag)=>tag.trim());\n            else // @ts-ignore\n            meta[metadataKey] = value.toString();\n        });\n        meta.created = new Date().toISOString();\n        meta.id = (0, $3fa3ae484854b431$export$2e2bcd8739ae039)();\n        const signer = new (0, $d1b6fbf03b2f6cd0$export$eb2cfd5dac35d0c7)($2fa42e15b9a85232$var$privateKey);\n        const signedProfile = signer.signProfile({\n            metadata: meta\n        });\n        profileResult.textContent = JSON.stringify(signedProfile, null, 2);\n    });\n};\nconst $2fa42e15b9a85232$var$getProfiles = async ()=>{\n    const profiles = await $2fa42e15b9a85232$var$profileAPI.getProfiles();\n    const selectElement = document.getElementById(\"profileSelect\");\n    if (!selectElement) throw new Error(\"Profile select not found\");\n    profiles.forEach((profile)=>{\n        const option = document.createElement(\"option\");\n        option.value = profile.id;\n        option.text = profile.name;\n        selectElement.appendChild(option);\n    });\n    selectElement.addEventListener(\"change\", async ()=>{\n        // @ts-ignore\n        const profileId = selectElement.value;\n        console.log(\"Selected profile: \", profileId);\n        const profile = await $2fa42e15b9a85232$var$profileAPI.getProfile(profileId);\n        const profileResult = document.getElementById(\"selectedProfileResult\");\n        if (!profileResult) throw new Error(\"Profile result not found\");\n        profileResult.textContent = JSON.stringify(profile, null, 2);\n    });\n};\nconst $2fa42e15b9a85232$var$storeProfile = ()=>{\n    try {\n        if (!document) throw new Error(\"Document not found\");\n        const storeProfileButton = document.getElementById(\"storeProfileButton\");\n        if (!storeProfileButton) throw new Error(\"Store button not found\");\n        storeProfileButton.addEventListener(\"click\", async ()=>{\n            const storeProfileResult = document.getElementById(\"storeProfileResult\");\n            const profileData = document.getElementById(\"storeProfileData\");\n            if (!profileData) document.getElementById(\"storeProfileResult\").textContent = \"Store Profile Result\";\n            // @ts-ignore\n            const profileDataText = profileData.value;\n            try {\n                console.log(\"Profile data: \", profileDataText);\n                const profileData = JSON.parse(profileDataText);\n                console.log(\"Storing profile: \", profileData);\n                const resp = await $2fa42e15b9a85232$var$profileAPI.storeProfile(profileData);\n                storeProfileResult.textContent = JSON.stringify(resp, null, 2);\n            } catch (error) {\n                storeProfileResult.textContent = \"Error parsing profile data: \" + error;\n            }\n        });\n    } catch (error) {\n        alert(\"Error: \" + error);\n    }\n};\nconst $2fa42e15b9a85232$var$setup = ()=>{\n    $2fa42e15b9a85232$var$generateKeys();\n    $2fa42e15b9a85232$var$validate();\n    $2fa42e15b9a85232$var$resolvers();\n    $2fa42e15b9a85232$var$reference();\n    $2fa42e15b9a85232$var$storeProfile();\n    $2fa42e15b9a85232$var$getProfiles();\n    $2fa42e15b9a85232$var$generateProfile();\n    $2fa42e15b9a85232$var$downloadKeyListener();\n};\ndocument.addEventListener(\"DOMContentLoaded\", ()=>{\n    console.log(\"adding listeners\");\n    $2fa42e15b9a85232$var$setup();\n});\n\n\n//# sourceMappingURL=index.29124767.js.map\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nconst core_1 = require(\"./core\");\nconst draft7_1 = require(\"./vocabularies/draft7\");\nconst discriminator_1 = require(\"./vocabularies/discriminator\");\nconst draft7MetaSchema = require(\"./refs/json-schema-draft-07.json\");\nconst META_SUPPORT_DATA = [\"/properties\"];\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\";\nclass Ajv extends core_1.default {\n    _addVocabularies() {\n        super._addVocabularies();\n        draft7_1.default.forEach((v) => this.addVocabulary(v));\n        if (this.opts.discriminator)\n            this.addKeyword(discriminator_1.default);\n    }\n    _addDefaultMetaSchema() {\n        super._addDefaultMetaSchema();\n        if (!this.opts.meta)\n            return;\n        const metaSchema = this.opts.$data\n            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n            : draft7MetaSchema;\n        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);\n        this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID;\n    }\n    defaultMeta() {\n        return (this.opts.defaultMeta =\n            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));\n    }\n}\nmodule.exports = exports = Ajv;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Ajv;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return codegen_1._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return codegen_1.str; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return codegen_1.stringify; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return codegen_1.nil; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return codegen_1.Name; } });\nObject.defineProperty(exports, \"CodeGen\", { enumerable: true, get: function () { return codegen_1.CodeGen; } });\nvar validation_error_1 = require(\"./runtime/validation_error\");\nObject.defineProperty(exports, \"ValidationError\", { enumerable: true, get: function () { return validation_error_1.default; } });\nvar ref_error_1 = require(\"./compile/ref_error\");\nObject.defineProperty(exports, \"MissingRefError\", { enumerable: true, get: function () { return ref_error_1.default; } });\n//# sourceMappingURL=ajv.js.map","import type {AnySchemaObject} from \"./types\"\nimport AjvCore from \"./core\"\nimport draft7Vocabularies from \"./vocabularies/draft7\"\nimport discriminator from \"./vocabularies/discriminator\"\nimport * as draft7MetaSchema from \"./refs/json-schema-draft-07.json\"\n\nconst META_SUPPORT_DATA = [\"/properties\"]\n\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\"\n\nclass Ajv extends AjvCore {\n  _addVocabularies(): void {\n    super._addVocabularies()\n    draft7Vocabularies.forEach((v) => this.addVocabulary(v))\n    if (this.opts.discriminator) this.addKeyword(discriminator)\n  }\n\n  _addDefaultMetaSchema(): void {\n    super._addDefaultMetaSchema()\n    if (!this.opts.meta) return\n    const metaSchema = this.opts.$data\n      ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n      : draft7MetaSchema\n    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  SchemaValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\nexport {default as ValidationError} from \"./runtime/validation_error\"\nexport {default as MissingRefError} from \"./compile/ref_error\"\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return codegen_1._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return codegen_1.str; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return codegen_1.stringify; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return codegen_1.nil; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return codegen_1.Name; } });\nObject.defineProperty(exports, \"CodeGen\", { enumerable: true, get: function () { return codegen_1.CodeGen; } });\nconst validation_error_1 = require(\"./runtime/validation_error\");\nconst ref_error_1 = require(\"./compile/ref_error\");\nconst rules_1 = require(\"./compile/rules\");\nconst compile_1 = require(\"./compile\");\nconst codegen_2 = require(\"./compile/codegen\");\nconst resolve_1 = require(\"./compile/resolve\");\nconst dataType_1 = require(\"./compile/validate/dataType\");\nconst util_1 = require(\"./compile/util\");\nconst $dataRefSchema = require(\"./refs/data.json\");\nconst uri_1 = require(\"./runtime/uri\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\n    \"validate\",\n    \"serialize\",\n    \"parse\",\n    \"wrapper\",\n    \"root\",\n    \"schema\",\n    \"keyword\",\n    \"pattern\",\n    \"formats\",\n    \"validate$data\",\n    \"func\",\n    \"obj\",\n    \"Error\",\n]);\nconst removedOptions = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\",\n};\nconst deprecatedOptions = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n    const s = o.strict;\n    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n    return {\n        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n        uriResolver: uriResolver,\n    };\n}\nclass Ajv {\n    constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = new Set();\n        this._loading = {};\n        this._cache = new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n        checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n            addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n            addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\")\n            this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n    }\n    _addVocabularies() {\n        this.addKeyword(\"$async\");\n    }\n    _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === \"id\") {\n            _dataRefSchema = { ...$dataRefSchema };\n            _dataRefSchema.id = _dataRefSchema.$id;\n            delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n    defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined);\n    }\n    validate(schemaKeyRef, // key, ref or schema object\n    data // to be validated\n    ) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n            v = this.getSchema(schemaKeyRef);\n            if (!v)\n                throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        }\n        else {\n            v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!(\"$async\" in v))\n            this.errors = v.errors;\n        return valid;\n    }\n    compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") {\n            throw new Error(\"options.loadSchema should be a function\");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n            await loadMetaSchema.call(this, _schema.$schema);\n            const sch = this._addSchema(_schema, _meta);\n            return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n            if ($ref && !this.getSchema($ref)) {\n                await runCompileAsync.call(this, { $ref }, true);\n            }\n        }\n        async function _compileAsync(sch) {\n            try {\n                return this._compileSchemaEnv(sch);\n            }\n            catch (e) {\n                if (!(e instanceof ref_error_1.default))\n                    throw e;\n                checkLoaded.call(this, e);\n                await loadMissingSchema.call(this, e.missingSchema);\n                return _compileAsync.call(this, sch);\n            }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n            if (this.refs[ref]) {\n                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n            }\n        }\n        async function loadMissingSchema(ref) {\n            const _schema = await _loadSchema.call(this, ref);\n            if (!this.refs[ref])\n                await loadMetaSchema.call(this, _schema.$schema);\n            if (!this.refs[ref])\n                this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n            const p = this._loading[ref];\n            if (p)\n                return p;\n            try {\n                return await (this._loading[ref] = loadSchema(ref));\n            }\n            finally {\n                delete this._loading[ref];\n            }\n        }\n    }\n    // Adds schema to the instance\n    addSchema(schema, // If array is passed, `key` will be ignored\n    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    ) {\n        if (Array.isArray(schema)) {\n            for (const sch of schema)\n                this.addSchema(sch, undefined, _meta, _validateSchema);\n            return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n            const { schemaId } = this.opts;\n            id = schema[schemaId];\n            if (id !== undefined && typeof id != \"string\") {\n                throw new Error(`schema ${schemaId} must be string`);\n            }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n    addMetaSchema(schema, key, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    ) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n    }\n    //  Validate schema against its meta-schema\n    validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\")\n            return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== undefined && typeof $schema != \"string\") {\n            throw new Error(\"$schema must be a string\");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n            this.logger.warn(\"meta-schema not available\");\n            this.errors = null;\n            return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n            const message = \"schema is invalid: \" + this.errorsText();\n            if (this.opts.validateSchema === \"log\")\n                this.logger.error(message);\n            else\n                throw new Error(message);\n        }\n        return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n    getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\")\n            keyRef = sch;\n        if (sch === undefined) {\n            const { schemaId } = this.opts;\n            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n            sch = compile_1.resolveSchema.call(this, root, keyRef);\n            if (!sch)\n                return;\n            this.refs[keyRef] = sch;\n        }\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n            this._removeAllSchemas(this.schemas, schemaKeyRef);\n            this._removeAllSchemas(this.refs, schemaKeyRef);\n            return this;\n        }\n        switch (typeof schemaKeyRef) {\n            case \"undefined\":\n                this._removeAllSchemas(this.schemas);\n                this._removeAllSchemas(this.refs);\n                this._cache.clear();\n                return this;\n            case \"string\": {\n                const sch = getSchEnv.call(this, schemaKeyRef);\n                if (typeof sch == \"object\")\n                    this._cache.delete(sch.schema);\n                delete this.schemas[schemaKeyRef];\n                delete this.refs[schemaKeyRef];\n                return this;\n            }\n            case \"object\": {\n                const cacheKey = schemaKeyRef;\n                this._cache.delete(cacheKey);\n                let id = schemaKeyRef[this.opts.schemaId];\n                if (id) {\n                    id = (0, resolve_1.normalizeId)(id);\n                    delete this.schemas[id];\n                    delete this.refs[id];\n                }\n                return this;\n            }\n            default:\n                throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n    }\n    // add \"vocabulary\" - a collection of keywords\n    addVocabulary(definitions) {\n        for (const def of definitions)\n            this.addKeyword(def);\n        return this;\n    }\n    addKeyword(kwdOrDef, def // deprecated\n    ) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n            keyword = kwdOrDef;\n            if (typeof def == \"object\") {\n                this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n                def.keyword = keyword;\n            }\n        }\n        else if (typeof kwdOrDef == \"object\" && def === undefined) {\n            def = kwdOrDef;\n            keyword = def.keyword;\n            if (Array.isArray(keyword) && !keyword.length) {\n                throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n            }\n        }\n        else {\n            throw new Error(\"invalid addKeywords parameters\");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n            return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n            ...def,\n            type: (0, dataType_1.getJSONTypes)(def.type),\n            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0\n            ? (k) => addRule.call(this, k, definition)\n            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n    }\n    getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n    removeKeyword(keyword) {\n        // TODO return type should be Ajv\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n            const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n            if (i >= 0)\n                group.rules.splice(i, 1);\n        }\n        return this;\n    }\n    // Add format\n    addFormat(name, format) {\n        if (typeof format == \"string\")\n            format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n    }\n    errorsText(errors = this.errors, // optional array of validation errors\n    { separator = \", \", dataVar = \"data\" } = {} // optional options with properties `separator` and `dataVar`\n    ) {\n        if (!errors || errors.length === 0)\n            return \"No errors\";\n        return errors\n            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n            .reduce((text, msg) => text + separator + msg);\n    }\n    $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n            const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n            let keywords = metaSchema;\n            for (const seg of segments)\n                keywords = keywords[seg];\n            for (const key in rules) {\n                const rule = rules[key];\n                if (typeof rule != \"object\")\n                    continue;\n                const { $data } = rule.definition;\n                const schema = keywords[key];\n                if ($data && schema)\n                    keywords[key] = schemaOrData(schema);\n            }\n        }\n        return metaSchema;\n    }\n    _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n            const sch = schemas[keyRef];\n            if (!regex || regex.test(keyRef)) {\n                if (typeof sch == \"string\") {\n                    delete schemas[keyRef];\n                }\n                else if (sch && !sch.meta) {\n                    this._cache.delete(sch.schema);\n                    delete schemas[keyRef];\n                }\n            }\n        }\n    }\n    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == \"object\") {\n            id = schema[schemaId];\n        }\n        else {\n            if (this.opts.jtd)\n                throw new Error(\"schema must be object\");\n            else if (typeof schema != \"boolean\")\n                throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== undefined)\n            return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n            if (baseId)\n                this._checkUnique(baseId);\n            this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n            this.validateSchema(schema, true);\n        return sch;\n    }\n    _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n            throw new Error(`schema with key or id \"${id}\" already exists`);\n        }\n    }\n    _compileSchemaEnv(sch) {\n        if (sch.meta)\n            this._compileMetaSchema(sch);\n        else\n            compile_1.compileSchema.call(this, sch);\n        /* istanbul ignore if */\n        if (!sch.validate)\n            throw new Error(\"ajv implementation error\");\n        return sch.validate;\n    }\n    _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n            compile_1.compileSchema.call(this, sch);\n        }\n        finally {\n            this.opts = currentOpts;\n        }\n    }\n}\nexports.default = Ajv;\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n    for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n    }\n}\nfunction getSchEnv(keyRef) {\n    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n    return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n    const optsSchemas = this.opts.schemas;\n    if (!optsSchemas)\n        return;\n    if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n    else\n        for (const key in optsSchemas)\n            this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n    for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n            this.addFormat(name, format);\n    }\n}\nfunction addInitialKeywords(defs) {\n    if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n    }\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n            def.keyword = keyword;\n        this.addKeyword(def);\n    }\n}\nfunction getMetaSchemaOptions() {\n    const metaOpts = { ...this.opts };\n    for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n    return metaOpts;\n}\nconst noLogs = { log() { }, warn() { }, error() { } };\nfunction getLogger(logger) {\n    if (logger === false)\n        return noLogs;\n    if (logger === undefined)\n        return console;\n    if (logger.log && logger.warn && logger.error)\n        return logger;\n    throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n    const { RULES } = this;\n    (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n            throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n            throw new Error(`Keyword ${kwd} has invalid name`);\n    });\n    if (!def)\n        return;\n    if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n        throw new Error('$data keyword must have \"code\" or \"validate\" function');\n    }\n}\nfunction addRule(keyword, definition, dataType) {\n    var _a;\n    const post = definition === null || definition === void 0 ? void 0 : definition.post;\n    if (dataType && post)\n        throw new Error('keyword with \"post\" flag cannot have \"type\"');\n    const { RULES } = this;\n    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n    if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n    }\n    RULES.keywords[keyword] = true;\n    if (!definition)\n        return;\n    const rule = {\n        keyword,\n        definition: {\n            ...definition,\n            type: (0, dataType_1.getJSONTypes)(definition.type),\n            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),\n        },\n    };\n    if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n    else\n        ruleGroup.rules.push(rule);\n    RULES.all[keyword] = rule;\n    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n    if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n    }\n    else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n    }\n}\nfunction keywordMetaschema(def) {\n    let { metaSchema } = def;\n    if (metaSchema === undefined)\n        return;\n    if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n    def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n    $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n};\nfunction schemaOrData(schema) {\n    return { anyOf: [schema, $dataRef] };\n}\n//# sourceMappingURL=core.js.map","export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = require(\"./boolSchema\");\nconst dataType_1 = require(\"./dataType\");\nconst applicability_1 = require(\"./applicability\");\nconst dataType_2 = require(\"./dataType\");\nconst defaults_1 = require(\"./defaults\");\nconst keyword_1 = require(\"./keyword\");\nconst subschema_1 = require(\"./subschema\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst resolve_1 = require(\"../resolve\");\nconst util_1 = require(\"../util\");\nconst errors_1 = require(\"../errors\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            topSchemaObjCode(it);\n            return;\n        }\n    }\n    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n    if (opts.code.es5) {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n            gen.code((0, codegen_1._) `\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n            destructureValCxtES5(gen, opts);\n            gen.code(body);\n        });\n    }\n    else {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n    }\n}\nfunction destructureValCxt(opts) {\n    return (0, codegen_1._) `{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n    gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n    }, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `\"\"`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);\n    });\n}\nfunction topSchemaObjCode(it) {\n    const { schema, opts, gen } = it;\n    validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n            commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n            resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n    });\n    return;\n}\nfunction resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen, validateName } = it;\n    it.evaluated = gen.const(\"evaluated\", (0, codegen_1._) `${validateName}.evaluated`);\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n    const schId = typeof schema == \"object\" && schema[opts.schemaId];\n    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules({ schema, self }) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (self.RULES.all[key])\n            return true;\n    return false;\n}\nfunction isSchemaObj(it) {\n    return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n    const { schema, gen, opts } = it;\n    if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n    updateContext(it);\n    checkAsyncSchema(it);\n    const errsCount = gen.const(\"_errs\", names_1.default.errors);\n    typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n    (0, util_1.checkUnknownRules)(it);\n    checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n    const types = (0, dataType_1.getSchemaTypes)(it.schema);\n    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n    schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n    const { schema, errSchemaPath, opts, self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n        self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n    }\n}\nfunction checkNoDefault(it) {\n    const { schema, opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n        (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n    }\n}\nfunction updateContext(it) {\n    const schId = it.schema[it.opts.schemaId];\n    if (schId)\n        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) {\n        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);\n    }\n    else if (typeof opts.$comment == \"function\") {\n        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction returnResults(it) {\n    const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n    if (schemaEnv.$async) {\n        // TODO assign unevaluated\n        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n            assignEvaluated(it);\n        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);\n    }\n}\nfunction assignEvaluated({ gen, evaluated, props, items }) {\n    if (props instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.props`, props);\n    if (items instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen, schema, data, allErrors, opts, self } = it;\n    const { RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd)\n        checkStrictTypes(it, types);\n    gen.block(() => {\n        for (const group of RULES.rules)\n            groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!(0, applicability_1.shouldUseGroup)(schema, group))\n            return;\n        if (group.type) {\n            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n            iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                (0, dataType_2.reportTypeError)(it);\n            }\n            gen.endIf();\n        }\n        else {\n            iterateKeywords(it, group);\n        }\n        // TODO make it \"ok\" call?\n        if (!allErrors)\n            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction iterateKeywords(it, group) {\n    const { gen, schema, opts: { useDefaults }, } = it;\n    if (useDefaults)\n        (0, defaults_1.assignDefaults)(it, group.type);\n    gen.block(() => {\n        for (const rule of group.rules) {\n            if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n                keywordCode(it, rule.keyword, rule.definition, group.type);\n            }\n        }\n    });\n}\nfunction checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n    checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n    checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n    if (!types.length)\n        return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n            strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n    });\n    narrowSchemaTypes(it, types);\n}\nfunction checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n    }\n}\nfunction checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n            const { type } = rule.definition;\n            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n                strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n            }\n        }\n    }\n}\nfunction hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"));\n}\nfunction includesType(ts, t) {\n    return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"));\n}\nfunction narrowSchemaTypes(it, withTypes) {\n    const ts = [];\n    for (const t of it.dataTypes) {\n        if (includesType(withTypes, t))\n            ts.push(t);\n        else if (withTypes.includes(\"integer\") && t === \"number\")\n            ts.push(\"integer\");\n    }\n    it.dataTypes = ts;\n}\nfunction strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at \"${schemaPath}\" (strictTypes)`;\n    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n    constructor(it, def, keyword) {\n        (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n            this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        }\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n            }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n            this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n    }\n    result(condition, successAction, failAction) {\n        this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n    }\n    failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n            failAction();\n        else\n            this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors)\n                this.gen.endIf();\n        }\n        else {\n            if (this.allErrors)\n                this.gen.endIf();\n            else\n                this.gen.else();\n        }\n    }\n    pass(condition, failAction) {\n        this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors)\n                this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n            this.gen.endIf();\n        else\n            this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data)\n            return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined)\n            throw new Error('add \"trackErrors\" to keyword definition');\n        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors)\n            this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign)\n            Object.assign(this.params, obj);\n        else\n            this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n            return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n            gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== codegen_1.nil)\n                gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */\n                if (!(schemaCode instanceof codegen_1.Name))\n                    throw new Error(\"ajv implementation error\");\n                const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n            }\n            return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema }); // TODO value.code for standalone\n                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;\n            }\n            return codegen_1.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n        (0, subschema_1.extendSubschemaMode)(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n            return;\n        if (it.props !== true && schemaCxt.props !== undefined) {\n            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== undefined) {\n            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n            return true;\n        }\n    }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n    const cxt = new KeywordCxt(it, def, keyword);\n    if (\"code\" in def) {\n        def.code(cxt, ruleType);\n    }\n    else if (cxt.$data && def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n    else if (\"macro\" in def) {\n        (0, keyword_1.macroKeywordCode)(cxt, def);\n    }\n    else if (def.compile || def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, { dataLevel, dataNames, dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === \"\")\n        return names_1.default.rootData;\n    if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n    }\n    else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n            if (up >= dataLevel)\n                throw new Error(errorMsg(\"property/index\", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n            throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n            return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split(\"/\");\n    for (const segment of segments) {\n        if (segment) {\n            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n            expr = (0, codegen_1._) `${expr} && ${data}`;\n        }\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nexports.getData = getData;\n//# sourceMappingURL=index.js.map","import type {\n  AddedKeywordDefinition,\n  AnySchema,\n  AnySchemaObject,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {\n  schemaRefOrVal,\n  schemaHasRulesButRef,\n  checkUnknownRules,\n  checkStrictMode,\n  unescapeJsonPointer,\n  mergeEvaluated,\n} from \"../util\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {\n  ErrorPaths,\n  reportError,\n  reportExtraError,\n  resetErrorsCount,\n  keyword$DataError,\n} from \"../errors\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\n    N.data\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.instancePath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsyncSchema(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  const schId = it.schema[it.opts.schemaId]\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\n}\n\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  narrowSchemaTypes(it, types)\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {\n  const ts: JSONType[] = []\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t)\n    else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\")\n  }\n  it.dataTypes = ts\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.failResult(not(condition), successAction, failAction)\n  }\n\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(condition)\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.failResult(not(condition), undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst boolError = {\n    message: \"boolean schema is false\",\n};\nfunction topBoolOrEmptySchema(it) {\n    const { gen, schema, validateName } = it;\n    if (schema === false) {\n        falseSchemaError(it, false);\n    }\n    else if (typeof schema == \"object\" && schema.$async === true) {\n        gen.return(names_1.default.data);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, null);\n        gen.return(true);\n    }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n    const { gen, schema } = it;\n    if (schema === false) {\n        gen.var(valid, false); // TODO var\n        falseSchemaError(it);\n    }\n    else {\n        gen.var(valid, true); // TODO var\n    }\n}\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n    const { gen, data } = it;\n    // TODO maybe some other interface should be used for non-keyword validation errors...\n    const cxt = {\n        gen,\n        keyword: \"false schema\",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it,\n    };\n    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}\n//# sourceMappingURL=boolSchema.js.map","import type {KeywordErrorDefinition, KeywordErrorCxt} from \"../../types\"\nimport type {SchemaCxt} from \"..\"\nimport {reportError} from \"../errors\"\nimport {_, Name} from \"../codegen\"\nimport N from \"../names\"\n\nconst boolError: KeywordErrorDefinition = {\n  message: \"boolean schema is false\",\n}\n\nexport function topBoolOrEmptySchema(it: SchemaCxt): void {\n  const {gen, schema, validateName} = it\n  if (schema === false) {\n    falseSchemaError(it, false)\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(N.data)\n  } else {\n    gen.assign(_`${validateName}.errors`, null)\n    gen.return(true)\n  }\n}\n\nexport function boolOrEmptySchema(it: SchemaCxt, valid: Name): void {\n  const {gen, schema} = it\n  if (schema === false) {\n    gen.var(valid, false) // TODO var\n    falseSchemaError(it)\n  } else {\n    gen.var(valid, true) // TODO var\n  }\n}\n\nfunction falseSchemaError(it: SchemaCxt, overrideAllErrors?: boolean): void {\n  const {gen, data} = it\n  // TODO maybe some other interface should be used for non-keyword validation errors...\n  const cxt: KeywordErrorCxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it,\n  }\n  reportError(cxt, boolError, undefined, overrideAllErrors)\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst util_1 = require(\"./util\");\nconst names_1 = require(\"./names\");\nexports.keywordError = {\n    message: ({ keyword }) => (0, codegen_1.str) `must pass \"${keyword}\" keyword validation`,\n};\nexports.keyword$DataError = {\n    message: ({ keyword, schemaType }) => schemaType\n        ? (0, codegen_1.str) `\"${keyword}\" keyword must be ${schemaType} ($data)`\n        : (0, codegen_1.str) `\"${keyword}\" keyword is invalid ($data)`,\n};\nfunction reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {\n        addError(gen, errObj);\n    }\n    else {\n        returnErrors(it, (0, codegen_1._) `[${errObj}]`);\n    }\n}\nexports.reportError = reportError;\nfunction reportExtraError(cxt, error = exports.keywordError, errorPaths) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    addError(gen, errObj);\n    if (!(compositeRule || allErrors)) {\n        returnErrors(it, names_1.default.vErrors);\n    }\n}\nexports.reportExtraError = reportExtraError;\nfunction resetErrorsCount(gen, errsCount) {\n    gen.assign(names_1.default.errors, errsCount);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));\n}\nexports.resetErrorsCount = resetErrorsCount;\nfunction extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {\n    /* istanbul ignore if */\n    if (errsCount === undefined)\n        throw new Error(\"ajv implementation error\");\n    const err = gen.name(\"err\");\n    gen.forRange(\"i\", errsCount, names_1.default.errors, (i) => {\n        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);\n        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));\n        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);\n        if (it.opts.verbose) {\n            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);\n            gen.assign((0, codegen_1._) `${err}.data`, data);\n        }\n    });\n}\nexports.extendErrors = extendErrors;\nfunction addError(gen, errObj) {\n    const err = gen.const(\"err\", errObj);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);\n    gen.code((0, codegen_1._) `${names_1.default.errors}++`);\n}\nfunction returnErrors(it, errs) {\n    const { gen, validateName, schemaEnv } = it;\n    if (schemaEnv.$async) {\n        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);\n        gen.return(false);\n    }\n}\nconst E = {\n    keyword: new codegen_1.Name(\"keyword\"),\n    schemaPath: new codegen_1.Name(\"schemaPath\"),\n    params: new codegen_1.Name(\"params\"),\n    propertyName: new codegen_1.Name(\"propertyName\"),\n    message: new codegen_1.Name(\"message\"),\n    schema: new codegen_1.Name(\"schema\"),\n    parentSchema: new codegen_1.Name(\"parentSchema\"),\n};\nfunction errorObjectCode(cxt, error, errorPaths) {\n    const { createErrors } = cxt.it;\n    if (createErrors === false)\n        return (0, codegen_1._) `{}`;\n    return errorObject(cxt, error, errorPaths);\n}\nfunction errorObject(cxt, error, errorPaths = {}) {\n    const { gen, it } = cxt;\n    const keyValues = [\n        errorInstancePath(it, errorPaths),\n        errorSchemaPath(cxt, errorPaths),\n    ];\n    extraErrorProps(cxt, error, keyValues);\n    return gen.object(...keyValues);\n}\nfunction errorInstancePath({ errorPath }, { instancePath }) {\n    const instPath = instancePath\n        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`\n        : errorPath;\n    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];\n}\nfunction errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {\n    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;\n    if (schemaPath) {\n        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;\n    }\n    return [E.schemaPath, schPath];\n}\nfunction extraErrorProps(cxt, { params, message }, keyValues) {\n    const { keyword, data, schemaValue, it } = cxt;\n    const { opts, propertyName, topSchemaRef, schemaPath } = it;\n    keyValues.push([E.keyword, keyword], [E.params, typeof params == \"function\" ? params(cxt) : params || (0, codegen_1._) `{}`]);\n    if (opts.messages) {\n        keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message]);\n    }\n    if (opts.verbose) {\n        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);\n    }\n    if (propertyName)\n        keyValues.push([E.propertyName, propertyName]);\n}\n//# sourceMappingURL=errors.js.map","import type {KeywordErrorCxt, KeywordErrorDefinition} from \"../types\"\nimport type {SchemaCxt} from \"./index\"\nimport {CodeGen, _, str, strConcat, Code, Name} from \"./codegen\"\nimport {SafeExpr} from \"./codegen/code\"\nimport {getErrorPath, Type} from \"./util\"\nimport N from \"./names\"\n\nexport const keywordError: KeywordErrorDefinition = {\n  message: ({keyword}) => str`must pass \"${keyword}\" keyword validation`,\n}\n\nexport const keyword$DataError: KeywordErrorDefinition = {\n  message: ({keyword, schemaType}) =>\n    schemaType\n      ? str`\"${keyword}\" keyword must be ${schemaType} ($data)`\n      : str`\"${keyword}\" keyword is invalid ($data)`,\n}\n\nexport interface ErrorPaths {\n  instancePath?: Code\n  schemaPath?: string\n  parentSchema?: boolean\n}\n\nexport function reportError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths,\n  overrideAllErrors?: boolean\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  if (overrideAllErrors ?? (compositeRule || allErrors)) {\n    addError(gen, errObj)\n  } else {\n    returnErrors(it, _`[${errObj}]`)\n  }\n}\n\nexport function reportExtraError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  addError(gen, errObj)\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, N.vErrors)\n  }\n}\n\nexport function resetErrorsCount(gen: CodeGen, errsCount: Name): void {\n  gen.assign(N.errors, errsCount)\n  gen.if(_`${N.vErrors} !== null`, () =>\n    gen.if(\n      errsCount,\n      () => gen.assign(_`${N.vErrors}.length`, errsCount),\n      () => gen.assign(N.vErrors, null)\n    )\n  )\n}\n\nexport function extendErrors({\n  gen,\n  keyword,\n  schemaValue,\n  data,\n  errsCount,\n  it,\n}: KeywordErrorCxt): void {\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\")\n  const err = gen.name(\"err\")\n  gen.forRange(\"i\", errsCount, N.errors, (i) => {\n    gen.const(err, _`${N.vErrors}[${i}]`)\n    gen.if(_`${err}.instancePath === undefined`, () =>\n      gen.assign(_`${err}.instancePath`, strConcat(N.instancePath, it.errorPath))\n    )\n    gen.assign(_`${err}.schemaPath`, str`${it.errSchemaPath}/${keyword}`)\n    if (it.opts.verbose) {\n      gen.assign(_`${err}.schema`, schemaValue)\n      gen.assign(_`${err}.data`, data)\n    }\n  })\n}\n\nfunction addError(gen: CodeGen, errObj: Code): void {\n  const err = gen.const(\"err\", errObj)\n  gen.if(\n    _`${N.vErrors} === null`,\n    () => gen.assign(N.vErrors, _`[${err}]`),\n    _`${N.vErrors}.push(${err})`\n  )\n  gen.code(_`${N.errors}++`)\n}\n\nfunction returnErrors(it: SchemaCxt, errs: Code): void {\n  const {gen, validateName, schemaEnv} = it\n  if (schemaEnv.$async) {\n    gen.throw(_`new ${it.ValidationError as Name}(${errs})`)\n  } else {\n    gen.assign(_`${validateName}.errors`, errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _`{}`\n  return errorObject(cxt, error, errorPaths)\n}\n\nfunction errorObject(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths: ErrorPaths = {}\n): Code {\n  const {gen, it} = cxt\n  const keyValues: [Name, SafeExpr | string][] = [\n    errorInstancePath(it, errorPaths),\n    errorSchemaPath(cxt, errorPaths),\n  ]\n  extraErrorProps(cxt, error, keyValues)\n  return gen.object(...keyValues)\n}\n\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\n  const instPath = instancePath\n    ? str`${errorPath}${getErrorPath(instancePath, Type.Str)}`\n    : errorPath\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\n}\n\nfunction errorSchemaPath(\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\n  {schemaPath, parentSchema}: ErrorPaths\n): [Name, string | Code] {\n  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath}/${keyword}`\n  if (schemaPath) {\n    schPath = str`${schPath}${getErrorPath(schemaPath, Type.Str)}`\n  }\n  return [E.schemaPath, schPath]\n}\n\nfunction extraErrorProps(\n  cxt: KeywordErrorCxt,\n  {params, message}: KeywordErrorDefinition,\n  keyValues: [Name, SafeExpr | string][]\n): void {\n  const {keyword, data, schemaValue, it} = cxt\n  const {opts, propertyName, topSchemaRef, schemaPath} = it\n  keyValues.push(\n    [E.keyword, keyword],\n    [E.params, typeof params == \"function\" ? params(cxt) : params || _`{}`]\n  )\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message])\n  }\n  if (opts.verbose) {\n    keyValues.push(\n      [E.schema, schemaValue],\n      [E.parentSchema, _`${topSchemaRef}${schemaPath}`],\n      [N.data, data]\n    )\n  }\n  if (propertyName) keyValues.push([E.propertyName, propertyName])\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;\nconst code_1 = require(\"./code\");\nconst scope_1 = require(\"./scope\");\nvar code_2 = require(\"./code\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return code_2._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return code_2.str; } });\nObject.defineProperty(exports, \"strConcat\", { enumerable: true, get: function () { return code_2.strConcat; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return code_2.nil; } });\nObject.defineProperty(exports, \"getProperty\", { enumerable: true, get: function () { return code_2.getProperty; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return code_2.stringify; } });\nObject.defineProperty(exports, \"regexpCode\", { enumerable: true, get: function () { return code_2.regexpCode; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return code_2.Name; } });\nvar scope_2 = require(\"./scope\");\nObject.defineProperty(exports, \"Scope\", { enumerable: true, get: function () { return scope_2.Scope; } });\nObject.defineProperty(exports, \"ValueScope\", { enumerable: true, get: function () { return scope_2.ValueScope; } });\nObject.defineProperty(exports, \"ValueScopeName\", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });\nObject.defineProperty(exports, \"varKinds\", { enumerable: true, get: function () { return scope_2.varKinds; } });\nexports.operators = {\n    GT: new code_1._Code(\">\"),\n    GTE: new code_1._Code(\">=\"),\n    LT: new code_1._Code(\"<\"),\n    LTE: new code_1._Code(\"<=\"),\n    EQ: new code_1._Code(\"===\"),\n    NEQ: new code_1._Code(\"!==\"),\n    NOT: new code_1._Code(\"!\"),\n    OR: new code_1._Code(\"||\"),\n    AND: new code_1._Code(\"&&\"),\n    ADD: new code_1._Code(\"+\"),\n};\nclass Node {\n    optimizeNodes() {\n        return this;\n    }\n    optimizeNames(_names, _constants) {\n        return this;\n    }\n}\nclass Def extends Node {\n    constructor(varKind, name, rhs) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.rhs = rhs;\n    }\n    render({ es5, _n }) {\n        const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n        const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`;\n        return `${varKind} ${this.name}${rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (!names[this.name.str])\n            return;\n        if (this.rhs)\n            this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n    }\n}\nclass Assign extends Node {\n    constructor(lhs, rhs, sideEffects) {\n        super();\n        this.lhs = lhs;\n        this.rhs = rhs;\n        this.sideEffects = sideEffects;\n    }\n    render({ _n }) {\n        return `${this.lhs} = ${this.rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)\n            return;\n        this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };\n        return addExprNames(names, this.rhs);\n    }\n}\nclass AssignOp extends Assign {\n    constructor(lhs, op, rhs, sideEffects) {\n        super(lhs, rhs, sideEffects);\n        this.op = op;\n    }\n    render({ _n }) {\n        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n    }\n}\nclass Label extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        return `${this.label}:` + _n;\n    }\n}\nclass Break extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        const label = this.label ? ` ${this.label}` : \"\";\n        return `break${label};` + _n;\n    }\n}\nclass Throw extends Node {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render({ _n }) {\n        return `throw ${this.error};` + _n;\n    }\n    get names() {\n        return this.error.names;\n    }\n}\nclass AnyCode extends Node {\n    constructor(code) {\n        super();\n        this.code = code;\n    }\n    render({ _n }) {\n        return `${this.code};` + _n;\n    }\n    optimizeNodes() {\n        return `${this.code}` ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        this.code = optimizeExpr(this.code, names, constants);\n        return this;\n    }\n    get names() {\n        return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n    }\n}\nclass ParentNode extends Node {\n    constructor(nodes = []) {\n        super();\n        this.nodes = nodes;\n    }\n    render(opts) {\n        return this.nodes.reduce((code, n) => code + n.render(opts), \"\");\n    }\n    optimizeNodes() {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            const n = nodes[i].optimizeNodes();\n            if (Array.isArray(n))\n                nodes.splice(i, 1, ...n);\n            else if (n)\n                nodes[i] = n;\n            else\n                nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            // iterating backwards improves 1-pass optimization\n            const n = nodes[i];\n            if (n.optimizeNames(names, constants))\n                continue;\n            subtractNames(names, n.names);\n            nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    get names() {\n        return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n    }\n}\nclass BlockNode extends ParentNode {\n    render(opts) {\n        return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n    }\n}\nclass Root extends ParentNode {\n}\nclass Else extends BlockNode {\n}\nElse.kind = \"else\";\nclass If extends BlockNode {\n    constructor(condition, nodes) {\n        super(nodes);\n        this.condition = condition;\n    }\n    render(opts) {\n        let code = `if(${this.condition})` + super.render(opts);\n        if (this.else)\n            code += \"else \" + this.else.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        super.optimizeNodes();\n        const cond = this.condition;\n        if (cond === true)\n            return this.nodes; // else is ignored here\n        let e = this.else;\n        if (e) {\n            const ns = e.optimizeNodes();\n            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n        }\n        if (e) {\n            if (cond === false)\n                return e instanceof If ? e : e.nodes;\n            if (this.nodes.length)\n                return this;\n            return new If(not(cond), e instanceof If ? [e] : e.nodes);\n        }\n        if (cond === false || !this.nodes.length)\n            return undefined;\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a;\n        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        if (!(super.optimizeNames(names, constants) || this.else))\n            return;\n        this.condition = optimizeExpr(this.condition, names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        addExprNames(names, this.condition);\n        if (this.else)\n            addNames(names, this.else.names);\n        return names;\n    }\n}\nIf.kind = \"if\";\nclass For extends BlockNode {\n}\nFor.kind = \"for\";\nclass ForLoop extends For {\n    constructor(iteration) {\n        super();\n        this.iteration = iteration;\n    }\n    render(opts) {\n        return `for(${this.iteration})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iteration = optimizeExpr(this.iteration, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iteration.names);\n    }\n}\nclass ForRange extends For {\n    constructor(varKind, name, from, to) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.from = from;\n        this.to = to;\n    }\n    render(opts) {\n        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n        const { name, from, to } = this;\n        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n    }\n    get names() {\n        const names = addExprNames(super.names, this.from);\n        return addExprNames(names, this.to);\n    }\n}\nclass ForIter extends For {\n    constructor(loop, varKind, name, iterable) {\n        super();\n        this.loop = loop;\n        this.varKind = varKind;\n        this.name = name;\n        this.iterable = iterable;\n    }\n    render(opts) {\n        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iterable = optimizeExpr(this.iterable, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iterable.names);\n    }\n}\nclass Func extends BlockNode {\n    constructor(name, args, async) {\n        super();\n        this.name = name;\n        this.args = args;\n        this.async = async;\n    }\n    render(opts) {\n        const _async = this.async ? \"async \" : \"\";\n        return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n    }\n}\nFunc.kind = \"func\";\nclass Return extends ParentNode {\n    render(opts) {\n        return \"return \" + super.render(opts);\n    }\n}\nReturn.kind = \"return\";\nclass Try extends BlockNode {\n    render(opts) {\n        let code = \"try\" + super.render(opts);\n        if (this.catch)\n            code += this.catch.render(opts);\n        if (this.finally)\n            code += this.finally.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        var _a, _b;\n        super.optimizeNodes();\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a, _b;\n        super.optimizeNames(names, constants);\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        if (this.catch)\n            addNames(names, this.catch.names);\n        if (this.finally)\n            addNames(names, this.finally.names);\n        return names;\n    }\n}\nclass Catch extends BlockNode {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render(opts) {\n        return `catch(${this.error})` + super.render(opts);\n    }\n}\nCatch.kind = \"catch\";\nclass Finally extends BlockNode {\n    render(opts) {\n        return \"finally\" + super.render(opts);\n    }\n}\nFinally.kind = \"finally\";\nclass CodeGen {\n    constructor(extScope, opts = {}) {\n        this._values = {};\n        this._blockStarts = [];\n        this._constants = {};\n        this.opts = { ...opts, _n: opts.lines ? \"\\n\" : \"\" };\n        this._extScope = extScope;\n        this._scope = new scope_1.Scope({ parent: extScope });\n        this._nodes = [new Root()];\n    }\n    toString() {\n        return this._root.render(this.opts);\n    }\n    // returns unique name in the internal scope\n    name(prefix) {\n        return this._scope.name(prefix);\n    }\n    // reserves unique name in the external scope\n    scopeName(prefix) {\n        return this._extScope.name(prefix);\n    }\n    // reserves unique name in the external scope and assigns value to it\n    scopeValue(prefixOrName, value) {\n        const name = this._extScope.value(prefixOrName, value);\n        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());\n        vs.add(name);\n        return name;\n    }\n    getScopeValue(prefix, keyOrRef) {\n        return this._extScope.getValue(prefix, keyOrRef);\n    }\n    // return code that assigns values in the external scope to the names that are used internally\n    // (same names that were returned by gen.scopeName or gen.scopeValue)\n    scopeRefs(scopeName) {\n        return this._extScope.scopeRefs(scopeName, this._values);\n    }\n    scopeCode() {\n        return this._extScope.scopeCode(this._values);\n    }\n    _def(varKind, nameOrPrefix, rhs, constant) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (rhs !== undefined && constant)\n            this._constants[name.str] = rhs;\n        this._leafNode(new Def(varKind, name, rhs));\n        return name;\n    }\n    // `const` declaration (`var` in es5 mode)\n    const(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n    }\n    // `let` declaration with optional assignment (`var` in es5 mode)\n    let(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n    }\n    // `var` declaration with optional assignment\n    var(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n    }\n    // assignment code\n    assign(lhs, rhs, sideEffects) {\n        return this._leafNode(new Assign(lhs, rhs, sideEffects));\n    }\n    // `+=` code\n    add(lhs, rhs) {\n        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));\n    }\n    // appends passed SafeExpr to code or executes Block\n    code(c) {\n        if (typeof c == \"function\")\n            c();\n        else if (c !== code_1.nil)\n            this._leafNode(new AnyCode(c));\n        return this;\n    }\n    // returns code for object literal for the passed argument list of key-value pairs\n    object(...keyValues) {\n        const code = [\"{\"];\n        for (const [key, value] of keyValues) {\n            if (code.length > 1)\n                code.push(\",\");\n            code.push(key);\n            if (key !== value || this.opts.es5) {\n                code.push(\":\");\n                (0, code_1.addCodeArg)(code, value);\n            }\n        }\n        code.push(\"}\");\n        return new code_1._Code(code);\n    }\n    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n    if(condition, thenBody, elseBody) {\n        this._blockNode(new If(condition));\n        if (thenBody && elseBody) {\n            this.code(thenBody).else().code(elseBody).endIf();\n        }\n        else if (thenBody) {\n            this.code(thenBody).endIf();\n        }\n        else if (elseBody) {\n            throw new Error('CodeGen: \"else\" body without \"then\" body');\n        }\n        return this;\n    }\n    // `else if` clause - invalid without `if` or after `else` clauses\n    elseIf(condition) {\n        return this._elseNode(new If(condition));\n    }\n    // `else` clause - only valid after `if` or `else if` clauses\n    else() {\n        return this._elseNode(new Else());\n    }\n    // end `if` statement (needed if gen.if was used only with condition)\n    endIf() {\n        return this._endBlockNode(If, Else);\n    }\n    _for(node, forBody) {\n        this._blockNode(node);\n        if (forBody)\n            this.code(forBody).endFor();\n        return this;\n    }\n    // a generic `for` clause (or statement if `forBody` is passed)\n    for(iteration, forBody) {\n        return this._for(new ForLoop(iteration), forBody);\n    }\n    // `for` statement for a range of values\n    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n    }\n    // `for-of` statement (in es5 mode replace with a normal for loop)\n    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (this.opts.es5) {\n            const arr = iterable instanceof code_1.Name ? iterable : this.var(\"_arr\", iterable);\n            return this.forRange(\"_i\", 0, (0, code_1._) `${arr}.length`, (i) => {\n                this.var(name, (0, code_1._) `${arr}[${i}]`);\n                forBody(name);\n            });\n        }\n        return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name));\n    }\n    // `for-in` statement.\n    // With option `ownProperties` replaced with a `for-of` loop for object keys\n    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {\n        if (this.opts.ownProperties) {\n            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);\n        }\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name));\n    }\n    // end `for` loop\n    endFor() {\n        return this._endBlockNode(For);\n    }\n    // `label` statement\n    label(label) {\n        return this._leafNode(new Label(label));\n    }\n    // `break` statement\n    break(label) {\n        return this._leafNode(new Break(label));\n    }\n    // `return` statement\n    return(value) {\n        const node = new Return();\n        this._blockNode(node);\n        this.code(value);\n        if (node.nodes.length !== 1)\n            throw new Error('CodeGen: \"return\" should have one node');\n        return this._endBlockNode(Return);\n    }\n    // `try` statement\n    try(tryBody, catchCode, finallyCode) {\n        if (!catchCode && !finallyCode)\n            throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n        const node = new Try();\n        this._blockNode(node);\n        this.code(tryBody);\n        if (catchCode) {\n            const error = this.name(\"e\");\n            this._currNode = node.catch = new Catch(error);\n            catchCode(error);\n        }\n        if (finallyCode) {\n            this._currNode = node.finally = new Finally();\n            this.code(finallyCode);\n        }\n        return this._endBlockNode(Catch, Finally);\n    }\n    // `throw` statement\n    throw(error) {\n        return this._leafNode(new Throw(error));\n    }\n    // start self-balancing block\n    block(body, nodeCount) {\n        this._blockStarts.push(this._nodes.length);\n        if (body)\n            this.code(body).endBlock(nodeCount);\n        return this;\n    }\n    // end the current self-balancing block\n    endBlock(nodeCount) {\n        const len = this._blockStarts.pop();\n        if (len === undefined)\n            throw new Error(\"CodeGen: not in self-balancing block\");\n        const toClose = this._nodes.length - len;\n        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n        }\n        this._nodes.length = len;\n        return this;\n    }\n    // `function` heading (or definition if funcBody is passed)\n    func(name, args = code_1.nil, async, funcBody) {\n        this._blockNode(new Func(name, args, async));\n        if (funcBody)\n            this.code(funcBody).endFunc();\n        return this;\n    }\n    // end function definition\n    endFunc() {\n        return this._endBlockNode(Func);\n    }\n    optimize(n = 1) {\n        while (n-- > 0) {\n            this._root.optimizeNodes();\n            this._root.optimizeNames(this._root.names, this._constants);\n        }\n    }\n    _leafNode(node) {\n        this._currNode.nodes.push(node);\n        return this;\n    }\n    _blockNode(node) {\n        this._currNode.nodes.push(node);\n        this._nodes.push(node);\n    }\n    _endBlockNode(N1, N2) {\n        const n = this._currNode;\n        if (n instanceof N1 || (N2 && n instanceof N2)) {\n            this._nodes.pop();\n            return this;\n        }\n        throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`);\n    }\n    _elseNode(node) {\n        const n = this._currNode;\n        if (!(n instanceof If)) {\n            throw new Error('CodeGen: \"else\" without \"if\"');\n        }\n        this._currNode = n.else = node;\n        return this;\n    }\n    get _root() {\n        return this._nodes[0];\n    }\n    get _currNode() {\n        const ns = this._nodes;\n        return ns[ns.length - 1];\n    }\n    set _currNode(node) {\n        const ns = this._nodes;\n        ns[ns.length - 1] = node;\n    }\n}\nexports.CodeGen = CodeGen;\nfunction addNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) + (from[n] || 0);\n    return names;\n}\nfunction addExprNames(names, from) {\n    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n}\nfunction optimizeExpr(expr, names, constants) {\n    if (expr instanceof code_1.Name)\n        return replaceName(expr);\n    if (!canOptimize(expr))\n        return expr;\n    return new code_1._Code(expr._items.reduce((items, c) => {\n        if (c instanceof code_1.Name)\n            c = replaceName(c);\n        if (c instanceof code_1._Code)\n            items.push(...c._items);\n        else\n            items.push(c);\n        return items;\n    }, []));\n    function replaceName(n) {\n        const c = constants[n.str];\n        if (c === undefined || names[n.str] !== 1)\n            return n;\n        delete names[n.str];\n        return c;\n    }\n    function canOptimize(e) {\n        return (e instanceof code_1._Code &&\n            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));\n    }\n}\nfunction subtractNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) - (from[n] || 0);\n}\nfunction not(x) {\n    return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : (0, code_1._) `!${par(x)}`;\n}\nexports.not = not;\nconst andCode = mappend(exports.operators.AND);\n// boolean AND (&&) expression with the passed arguments\nfunction and(...args) {\n    return args.reduce(andCode);\n}\nexports.and = and;\nconst orCode = mappend(exports.operators.OR);\n// boolean OR (||) expression with the passed arguments\nfunction or(...args) {\n    return args.reduce(orCode);\n}\nexports.or = or;\nfunction mappend(op) {\n    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);\n}\nfunction par(x) {\n    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;\n}\n//# sourceMappingURL=index.js.map","import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(private readonly varKind: Name, private readonly name: Name, private rhs?: SafeExpr) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(readonly lhs: Code, public rhs: SafeExpr, private readonly sideEffects?: boolean) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(lhs: Code, private readonly op: Code, rhs: SafeExpr, sideEffects?: boolean) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(private condition: Code | boolean, nodes?: ChildNode[]) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(public name: Name, public args: Code, public async?: boolean) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;\nclass _CodeOrName {\n}\nexports._CodeOrName = _CodeOrName;\nexports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nclass Name extends _CodeOrName {\n    constructor(s) {\n        super();\n        if (!exports.IDENTIFIER.test(s))\n            throw new Error(\"CodeGen: name must be a valid identifier\");\n        this.str = s;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        return false;\n    }\n    get names() {\n        return { [this.str]: 1 };\n    }\n}\nexports.Name = Name;\nclass _Code extends _CodeOrName {\n    constructor(code) {\n        super();\n        this._items = typeof code === \"string\" ? [code] : code;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        if (this._items.length > 1)\n            return false;\n        const item = this._items[0];\n        return item === \"\" || item === '\"\"';\n    }\n    get str() {\n        var _a;\n        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, \"\")));\n    }\n    get names() {\n        var _a;\n        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {\n            if (c instanceof Name)\n                names[c.str] = (names[c.str] || 0) + 1;\n            return names;\n        }, {})));\n    }\n}\nexports._Code = _Code;\nexports.nil = new _Code(\"\");\nfunction _(strs, ...args) {\n    const code = [strs[0]];\n    let i = 0;\n    while (i < args.length) {\n        addCodeArg(code, args[i]);\n        code.push(strs[++i]);\n    }\n    return new _Code(code);\n}\nexports._ = _;\nconst plus = new _Code(\"+\");\nfunction str(strs, ...args) {\n    const expr = [safeStringify(strs[0])];\n    let i = 0;\n    while (i < args.length) {\n        expr.push(plus);\n        addCodeArg(expr, args[i]);\n        expr.push(plus, safeStringify(strs[++i]));\n    }\n    optimize(expr);\n    return new _Code(expr);\n}\nexports.str = str;\nfunction addCodeArg(code, arg) {\n    if (arg instanceof _Code)\n        code.push(...arg._items);\n    else if (arg instanceof Name)\n        code.push(arg);\n    else\n        code.push(interpolate(arg));\n}\nexports.addCodeArg = addCodeArg;\nfunction optimize(expr) {\n    let i = 1;\n    while (i < expr.length - 1) {\n        if (expr[i] === plus) {\n            const res = mergeExprItems(expr[i - 1], expr[i + 1]);\n            if (res !== undefined) {\n                expr.splice(i - 1, 3, res);\n                continue;\n            }\n            expr[i++] = \"+\";\n        }\n        i++;\n    }\n}\nfunction mergeExprItems(a, b) {\n    if (b === '\"\"')\n        return a;\n    if (a === '\"\"')\n        return b;\n    if (typeof a == \"string\") {\n        if (b instanceof Name || a[a.length - 1] !== '\"')\n            return;\n        if (typeof b != \"string\")\n            return `${a.slice(0, -1)}${b}\"`;\n        if (b[0] === '\"')\n            return a.slice(0, -1) + b.slice(1);\n        return;\n    }\n    if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name))\n        return `\"${a}${b.slice(1)}`;\n    return;\n}\nfunction strConcat(c1, c2) {\n    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;\n}\nexports.strConcat = strConcat;\n// TODO do not allow arrays here\nfunction interpolate(x) {\n    return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n        ? x\n        : safeStringify(Array.isArray(x) ? x.join(\",\") : x);\n}\nfunction stringify(x) {\n    return new _Code(safeStringify(x));\n}\nexports.stringify = stringify;\nfunction safeStringify(x) {\n    return JSON.stringify(x)\n        .replace(/\\u2028/g, \"\\\\u2028\")\n        .replace(/\\u2029/g, \"\\\\u2029\");\n}\nexports.safeStringify = safeStringify;\nfunction getProperty(key) {\n    return typeof key == \"string\" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;\n}\nexports.getProperty = getProperty;\n//Does best effort to format the name properly\nfunction getEsmExportName(key) {\n    if (typeof key == \"string\" && exports.IDENTIFIER.test(key)) {\n        return new _Code(`${key}`);\n    }\n    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);\n}\nexports.getEsmExportName = getEsmExportName;\nfunction regexpCode(rx) {\n    return new _Code(rx.toString());\n}\nexports.regexpCode = regexpCode;\n//# sourceMappingURL=code.js.map","export abstract class _CodeOrName {\n  abstract readonly str: string\n  abstract readonly names: UsedNames\n  abstract toString(): string\n  abstract emptyStr(): boolean\n}\n\nexport const IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i\n\nexport class Name extends _CodeOrName {\n  readonly str: string\n  constructor(s: string) {\n    super()\n    if (!IDENTIFIER.test(s)) throw new Error(\"CodeGen: name must be a valid identifier\")\n    this.str = s\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    return false\n  }\n\n  get names(): UsedNames {\n    return {[this.str]: 1}\n  }\n}\n\nexport class _Code extends _CodeOrName {\n  readonly _items: readonly CodeItem[]\n  private _str?: string\n  private _names?: UsedNames\n\n  constructor(code: string | readonly CodeItem[]) {\n    super()\n    this._items = typeof code === \"string\" ? [code] : code\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    if (this._items.length > 1) return false\n    const item = this._items[0]\n    return item === \"\" || item === '\"\"'\n  }\n\n  get str(): string {\n    return (this._str ??= this._items.reduce((s: string, c: CodeItem) => `${s}${c}`, \"\"))\n  }\n\n  get names(): UsedNames {\n    return (this._names ??= this._items.reduce((names: UsedNames, c) => {\n      if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1\n      return names\n    }, {}))\n  }\n}\n\nexport type CodeItem = Name | string | number | boolean | null\n\nexport type UsedNames = Record<string, number | undefined>\n\nexport type Code = _Code | Name\n\nexport type SafeExpr = Code | number | boolean | null\n\nexport const nil = new _Code(\"\")\n\ntype CodeArg = SafeExpr | string | undefined\n\nexport function _(strs: TemplateStringsArray, ...args: CodeArg[]): _Code {\n  const code: CodeItem[] = [strs[0]]\n  let i = 0\n  while (i < args.length) {\n    addCodeArg(code, args[i])\n    code.push(strs[++i])\n  }\n  return new _Code(code)\n}\n\nconst plus = new _Code(\"+\")\n\nexport function str(strs: TemplateStringsArray, ...args: (CodeArg | string[])[]): _Code {\n  const expr: CodeItem[] = [safeStringify(strs[0])]\n  let i = 0\n  while (i < args.length) {\n    expr.push(plus)\n    addCodeArg(expr, args[i])\n    expr.push(plus, safeStringify(strs[++i]))\n  }\n  optimize(expr)\n  return new _Code(expr)\n}\n\nexport function addCodeArg(code: CodeItem[], arg: CodeArg | string[]): void {\n  if (arg instanceof _Code) code.push(...arg._items)\n  else if (arg instanceof Name) code.push(arg)\n  else code.push(interpolate(arg))\n}\n\nfunction optimize(expr: CodeItem[]): void {\n  let i = 1\n  while (i < expr.length - 1) {\n    if (expr[i] === plus) {\n      const res = mergeExprItems(expr[i - 1], expr[i + 1])\n      if (res !== undefined) {\n        expr.splice(i - 1, 3, res)\n        continue\n      }\n      expr[i++] = \"+\"\n    }\n    i++\n  }\n}\n\nfunction mergeExprItems(a: CodeItem, b: CodeItem): CodeItem | undefined {\n  if (b === '\"\"') return a\n  if (a === '\"\"') return b\n  if (typeof a == \"string\") {\n    if (b instanceof Name || a[a.length - 1] !== '\"') return\n    if (typeof b != \"string\") return `${a.slice(0, -1)}${b}\"`\n    if (b[0] === '\"') return a.slice(0, -1) + b.slice(1)\n    return\n  }\n  if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name)) return `\"${a}${b.slice(1)}`\n  return\n}\n\nexport function strConcat(c1: Code, c2: Code): Code {\n  return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`\n}\n\n// TODO do not allow arrays here\nfunction interpolate(x?: string | string[] | number | boolean | null): SafeExpr | string {\n  return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n    ? x\n    : safeStringify(Array.isArray(x) ? x.join(\",\") : x)\n}\n\nexport function stringify(x: unknown): Code {\n  return new _Code(safeStringify(x))\n}\n\nexport function safeStringify(x: unknown): string {\n  return JSON.stringify(x)\n    .replace(/\\u2028/g, \"\\\\u2028\")\n    .replace(/\\u2029/g, \"\\\\u2029\")\n}\n\nexport function getProperty(key: Code | string | number): Code {\n  return typeof key == \"string\" && IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`\n}\n\n//Does best effort to format the name properly\nexport function getEsmExportName(key: Code | string | number): Code {\n  if (typeof key == \"string\" && IDENTIFIER.test(key)) {\n    return new _Code(`${key}`)\n  }\n  throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`)\n}\n\nexport function regexpCode(rx: RegExp): Code {\n  return new _Code(rx.toString())\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\nconst code_1 = require(\"./code\");\nclass ValueError extends Error {\n    constructor(name) {\n        super(`CodeGen: \"code\" for ${name} not defined`);\n        this.value = name.value;\n    }\n}\nvar UsedValueState;\n(function (UsedValueState) {\n    UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n    UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));\nexports.varKinds = {\n    const: new code_1.Name(\"const\"),\n    let: new code_1.Name(\"let\"),\n    var: new code_1.Name(\"var\"),\n};\nclass Scope {\n    constructor({ prefixes, parent } = {}) {\n        this._names = {};\n        this._prefixes = prefixes;\n        this._parent = parent;\n    }\n    toName(nameOrPrefix) {\n        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n    }\n    name(prefix) {\n        return new code_1.Name(this._newName(prefix));\n    }\n    _newName(prefix) {\n        const ng = this._names[prefix] || this._nameGroup(prefix);\n        return `${prefix}${ng.index++}`;\n    }\n    _nameGroup(prefix) {\n        var _a, _b;\n        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {\n            throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n        }\n        return (this._names[prefix] = { prefix, index: 0 });\n    }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends code_1.Name {\n    constructor(prefix, nameStr) {\n        super(nameStr);\n        this.prefix = prefix;\n    }\n    setValue(value, { property, itemIndex }) {\n        this.value = value;\n        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;\n    }\n}\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._) `\\n`;\nclass ValueScope extends Scope {\n    constructor(opts) {\n        super(opts);\n        this._values = {};\n        this._scope = opts.scope;\n        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };\n    }\n    get() {\n        return this._scope;\n    }\n    name(prefix) {\n        return new ValueScopeName(prefix, this._newName(prefix));\n    }\n    value(nameOrPrefix, value) {\n        var _a;\n        if (value.ref === undefined)\n            throw new Error(\"CodeGen: ref must be passed in value\");\n        const name = this.toName(nameOrPrefix);\n        const { prefix } = name;\n        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n        let vs = this._values[prefix];\n        if (vs) {\n            const _name = vs.get(valueKey);\n            if (_name)\n                return _name;\n        }\n        else {\n            vs = this._values[prefix] = new Map();\n        }\n        vs.set(valueKey, name);\n        const s = this._scope[prefix] || (this._scope[prefix] = []);\n        const itemIndex = s.length;\n        s[itemIndex] = value.ref;\n        name.setValue(value, { property: prefix, itemIndex });\n        return name;\n    }\n    getValue(prefix, keyOrRef) {\n        const vs = this._values[prefix];\n        if (!vs)\n            return;\n        return vs.get(keyOrRef);\n    }\n    scopeRefs(scopeName, values = this._values) {\n        return this._reduceValues(values, (name) => {\n            if (name.scopePath === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return (0, code_1._) `${scopeName}${name.scopePath}`;\n        });\n    }\n    scopeCode(values = this._values, usedValues, getCode) {\n        return this._reduceValues(values, (name) => {\n            if (name.value === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return name.value.code;\n        }, usedValues, getCode);\n    }\n    _reduceValues(values, valueCode, usedValues = {}, getCode) {\n        let code = code_1.nil;\n        for (const prefix in values) {\n            const vs = values[prefix];\n            if (!vs)\n                continue;\n            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());\n            vs.forEach((name) => {\n                if (nameSet.has(name))\n                    return;\n                nameSet.set(name, UsedValueState.Started);\n                let c = valueCode(name);\n                if (c) {\n                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;\n                }\n                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {\n                    code = (0, code_1._) `${code}${c}${this.opts._n}`;\n                }\n                else {\n                    throw new ValueError(name);\n                }\n                nameSet.set(name, UsedValueState.Completed);\n            });\n        }\n        return code;\n    }\n}\nexports.ValueScope = ValueScope;\n//# sourceMappingURL=scope.js.map","import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst code_1 = require(\"./codegen/code\");\n// TODO refactor to use Set\nfunction toHash(arr) {\n    const hash = {};\n    for (const item of arr)\n        hash[item] = true;\n    return hash;\n}\nexports.toHash = toHash;\nfunction alwaysValidSchema(it, schema) {\n    if (typeof schema == \"boolean\")\n        return schema;\n    if (Object.keys(schema).length === 0)\n        return true;\n    checkUnknownRules(it, schema);\n    return !schemaHasRules(schema, it.self.RULES.all);\n}\nexports.alwaysValidSchema = alwaysValidSchema;\nfunction checkUnknownRules(it, schema = it.schema) {\n    const { opts, self } = it;\n    if (!opts.strictSchema)\n        return;\n    if (typeof schema === \"boolean\")\n        return;\n    const rules = self.RULES.keywords;\n    for (const key in schema) {\n        if (!rules[key])\n            checkStrictMode(it, `unknown keyword: \"${key}\"`);\n    }\n}\nexports.checkUnknownRules = checkUnknownRules;\nfunction schemaHasRules(schema, rules) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (rules[key])\n            return true;\n    return false;\n}\nexports.schemaHasRules = schemaHasRules;\nfunction schemaHasRulesButRef(schema, RULES) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (key !== \"$ref\" && RULES.all[key])\n            return true;\n    return false;\n}\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\nfunction schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {\n    if (!$data) {\n        if (typeof schema == \"number\" || typeof schema == \"boolean\")\n            return schema;\n        if (typeof schema == \"string\")\n            return (0, codegen_1._) `${schema}`;\n    }\n    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n}\nexports.schemaRefOrVal = schemaRefOrVal;\nfunction unescapeFragment(str) {\n    return unescapeJsonPointer(decodeURIComponent(str));\n}\nexports.unescapeFragment = unescapeFragment;\nfunction escapeFragment(str) {\n    return encodeURIComponent(escapeJsonPointer(str));\n}\nexports.escapeFragment = escapeFragment;\nfunction escapeJsonPointer(str) {\n    if (typeof str == \"number\")\n        return `${str}`;\n    return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nexports.escapeJsonPointer = escapeJsonPointer;\nfunction unescapeJsonPointer(str) {\n    return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nexports.unescapeJsonPointer = unescapeJsonPointer;\nfunction eachItem(xs, f) {\n    if (Array.isArray(xs)) {\n        for (const x of xs)\n            f(x);\n    }\n    else {\n        f(xs);\n    }\n}\nexports.eachItem = eachItem;\nfunction makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {\n    return (gen, from, to, toName) => {\n        const res = to === undefined\n            ? from\n            : to instanceof codegen_1.Name\n                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n                : from instanceof codegen_1.Name\n                    ? (mergeToName(gen, to, from), from)\n                    : mergeValues(from, to);\n        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n    };\n}\nexports.mergeEvaluated = {\n    props: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {\n            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));\n        }),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {\n            if (from === true) {\n                gen.assign(to, true);\n            }\n            else {\n                gen.assign(to, (0, codegen_1._) `${to} || {}`);\n                setEvaluated(gen, to, from);\n            }\n        }),\n        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),\n        resultToName: evaluatedPropsToName,\n    }),\n    items: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),\n        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n        resultToName: (gen, items) => gen.var(\"items\", items),\n    }),\n};\nfunction evaluatedPropsToName(gen, ps) {\n    if (ps === true)\n        return gen.var(\"props\", true);\n    const props = gen.var(\"props\", (0, codegen_1._) `{}`);\n    if (ps !== undefined)\n        setEvaluated(gen, props, ps);\n    return props;\n}\nexports.evaluatedPropsToName = evaluatedPropsToName;\nfunction setEvaluated(gen, props, ps) {\n    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));\n}\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\nfunction useFunc(gen, f) {\n    return gen.scopeValue(\"func\", {\n        ref: f,\n        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),\n    });\n}\nexports.useFunc = useFunc;\nvar Type;\n(function (Type) {\n    Type[Type[\"Num\"] = 0] = \"Num\";\n    Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type = exports.Type || (exports.Type = {}));\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n    // let path\n    if (dataProp instanceof codegen_1.Name) {\n        const isNumber = dataPropType === Type.Num;\n        return jsPropertySyntax\n            ? isNumber\n                ? (0, codegen_1._) `\"[\" + ${dataProp} + \"]\"`\n                : (0, codegen_1._) `\"['\" + ${dataProp} + \"']\"`\n            : isNumber\n                ? (0, codegen_1._) `\"/\" + ${dataProp}`\n                : (0, codegen_1._) `\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n    }\n    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\nexports.getErrorPath = getErrorPath;\nfunction checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n    if (!mode)\n        return;\n    msg = `strict mode: ${msg}`;\n    if (mode === true)\n        throw new Error(msg);\n    it.self.logger.warn(msg);\n}\nexports.checkStrictMode = checkStrictMode;\n//# sourceMappingURL=util.js.map","import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\nimport {_Code} from \"./codegen/code\"\nimport type {Rule, ValidationRules} from \"./rules\"\n\n// TODO refactor to use Set\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\n  const hash: {[K in T]?: true} = {}\n  for (const item of arr) hash[item] = true\n  return hash\n}\n\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\n  if (typeof schema == \"boolean\") return schema\n  if (Object.keys(schema).length === 0) return true\n  checkUnknownRules(it, schema)\n  return !schemaHasRules(schema, it.self.RULES.all)\n}\n\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\n  const {opts, self} = it\n  if (!opts.strictSchema) return\n  if (typeof schema === \"boolean\") return\n  const rules = self.RULES.keywords\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\n  }\n}\n\nexport function schemaHasRules(\n  schema: AnySchema,\n  rules: {[Key in string]?: boolean | Rule}\n): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (rules[key]) return true\n  return false\n}\n\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\n  return false\n}\n\nexport function schemaRefOrVal(\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\n  schema: unknown,\n  keyword: string,\n  $data?: string | false\n): Code | number | boolean {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\n    if (typeof schema == \"string\") return _`${schema}`\n  }\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\n}\n\nexport function unescapeFragment(str: string): string {\n  return unescapeJsonPointer(decodeURIComponent(str))\n}\n\nexport function escapeFragment(str: string | number): string {\n  return encodeURIComponent(escapeJsonPointer(str))\n}\n\nexport function escapeJsonPointer(str: string | number): string {\n  if (typeof str == \"number\") return `${str}`\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\n}\n\nexport function unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x)\n  } else {\n    f(xs)\n  }\n}\n\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\n\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\n  gen: CodeGen,\n  from: Name | T,\n  to: Name | Exclude<T, true> | undefined,\n  toName?: typeof Name\n) => Name | T\n\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\n  mergeValues: (from: T, to: Exclude<T, true>) => T\n  resultToName: (gen: CodeGen, res?: T) => Name\n}\n\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName,\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\n  return (gen, from, to, toName) => {\n    const res =\n      to === undefined\n        ? from\n        : to instanceof Name\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n        : from instanceof Name\n        ? (mergeToName(gen, to, from), from)\n        : mergeValues(from, to)\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\n  }\n}\n\ninterface MergeEvaluated {\n  props: MergeEvaluatedFunc<EvaluatedProperties>\n  items: MergeEvaluatedFunc<EvaluatedItems>\n}\n\nexport const mergeEvaluated: MergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\n        gen.if(\n          _`${from} === true`,\n          () => gen.assign(to, true),\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\n        )\n      }),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () => {\n        if (from === true) {\n          gen.assign(to, true)\n        } else {\n          gen.assign(to, _`${to} || {}`)\n          setEvaluated(gen, to, from)\n        }\n      }),\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\n    resultToName: evaluatedPropsToName,\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () =>\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n    resultToName: (gen, items) => gen.var(\"items\", items),\n  }),\n}\n\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\n  if (ps === true) return gen.var(\"props\", true)\n  const props = gen.var(\"props\", _`{}`)\n  if (ps !== undefined) setEvaluated(gen, props, ps)\n  return props\n}\n\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\n}\n\nconst snippets: {[S in string]?: _Code} = {}\n\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\n  })\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport function getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n\nexport function checkStrictMode(\n  it: SchemaCxt,\n  msg: string,\n  mode: boolean | \"log\" = it.opts.strictSchema\n): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"./codegen\");\nconst names = {\n    // validation function arguments\n    data: new codegen_1.Name(\"data\"),\n    // args passed from referencing schema\n    valCxt: new codegen_1.Name(\"valCxt\"),\n    instancePath: new codegen_1.Name(\"instancePath\"),\n    parentData: new codegen_1.Name(\"parentData\"),\n    parentDataProperty: new codegen_1.Name(\"parentDataProperty\"),\n    rootData: new codegen_1.Name(\"rootData\"),\n    dynamicAnchors: new codegen_1.Name(\"dynamicAnchors\"),\n    // function scoped variables\n    vErrors: new codegen_1.Name(\"vErrors\"),\n    errors: new codegen_1.Name(\"errors\"),\n    this: new codegen_1.Name(\"this\"),\n    // \"globals\"\n    self: new codegen_1.Name(\"self\"),\n    scope: new codegen_1.Name(\"scope\"),\n    // JTD serialize/parse name for JSON string and position\n    json: new codegen_1.Name(\"json\"),\n    jsonPos: new codegen_1.Name(\"jsonPos\"),\n    jsonLen: new codegen_1.Name(\"jsonLen\"),\n    jsonPart: new codegen_1.Name(\"jsonPart\"),\n};\nexports.default = names;\n//# sourceMappingURL=names.js.map","import {Name} from \"./codegen\"\n\nconst names = {\n  // validation function arguments\n  data: new Name(\"data\"), // data passed to validation function\n  // args passed from referencing schema\n  valCxt: new Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n  instancePath: new Name(\"instancePath\"),\n  parentData: new Name(\"parentData\"),\n  parentDataProperty: new Name(\"parentDataProperty\"),\n  rootData: new Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n  dynamicAnchors: new Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n  // function scoped variables\n  vErrors: new Name(\"vErrors\"), // null or array of validation errors\n  errors: new Name(\"errors\"), // counter of validation errors\n  this: new Name(\"this\"),\n  // \"globals\"\n  self: new Name(\"self\"),\n  scope: new Name(\"scope\"),\n  // JTD serialize/parse name for JSON string and position\n  json: new Name(\"json\"),\n  jsonPos: new Name(\"jsonPos\"),\n  jsonLen: new Name(\"jsonLen\"),\n  jsonPart: new Name(\"jsonPart\"),\n}\n\nexport default names\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nconst rules_1 = require(\"../rules\");\nconst applicability_1 = require(\"./applicability\");\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n    DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType = exports.DataType || (exports.DataType = {}));\nfunction getSchemaTypes(schema) {\n    const types = getJSONTypes(schema.type);\n    const hasNull = types.includes(\"null\");\n    if (hasNull) {\n        if (schema.nullable === false)\n            throw new Error(\"type: null contradicts nullable: false\");\n    }\n    else {\n        if (!types.length && schema.nullable !== undefined) {\n            throw new Error('\"nullable\" cannot be used without \"type\"');\n        }\n        if (schema.nullable === true)\n            types.push(\"null\");\n    }\n    return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\nfunction getJSONTypes(ts) {\n    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n    if (types.every(rules_1.isJSONType))\n        return types;\n    throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n    const { gen, data, opts } = it;\n    const coerceTo = coerceToTypes(types, opts.coerceTypes);\n    const checkTypes = types.length > 0 &&\n        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n    if (checkTypes) {\n        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n        gen.if(wrongType, () => {\n            if (coerceTo.length)\n                coerceData(it, types, coerceTo);\n            else\n                reportTypeError(it);\n        });\n    }\n    return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction coerceToTypes(types, coerceTypes) {\n    return coerceTypes\n        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n        : [];\n}\nfunction coerceData(it, types, coerceTo) {\n    const { gen, data, opts } = it;\n    const dataType = gen.let(\"dataType\", (0, codegen_1._) `typeof ${data}`);\n    const coerced = gen.let(\"coerced\", (0, codegen_1._) `undefined`);\n    if (opts.coerceTypes === \"array\") {\n        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen\n            .assign(data, (0, codegen_1._) `${data}[0]`)\n            .assign(dataType, (0, codegen_1._) `typeof ${data}`)\n            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n    }\n    gen.if((0, codegen_1._) `${coerced} !== undefined`);\n    for (const t of coerceTo) {\n        if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n            coerceSpecificType(t);\n        }\n    }\n    gen.else();\n    reportTypeError(it);\n    gen.endIf();\n    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {\n        gen.assign(data, coerced);\n        assignParentData(it, coerced);\n    });\n    function coerceSpecificType(t) {\n        switch (t) {\n            case \"string\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n                    .assign(coerced, (0, codegen_1._) `\"\" + ${data}`)\n                    .elseIf((0, codegen_1._) `${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `\"\"`);\n                return;\n            case \"number\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"integer\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"boolean\":\n                gen\n                    .elseIf((0, codegen_1._) `${data} === \"false\" || ${data} === 0 || ${data} === null`)\n                    .assign(coerced, false)\n                    .elseIf((0, codegen_1._) `${data} === \"true\" || ${data} === 1`)\n                    .assign(coerced, true);\n                return;\n            case \"null\":\n                gen.elseIf((0, codegen_1._) `${data} === \"\" || ${data} === 0 || ${data} === false`);\n                gen.assign(coerced, null);\n                return;\n            case \"array\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `[${data}]`);\n        }\n    }\n}\nfunction assignParentData({ gen, parentData, parentDataProperty }, expr) {\n    // TODO use gen.property\n    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));\n}\nfunction checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n    let cond;\n    switch (dataType) {\n        case \"null\":\n            return (0, codegen_1._) `${data} ${EQ} null`;\n        case \"array\":\n            cond = (0, codegen_1._) `Array.isArray(${data})`;\n            break;\n        case \"object\":\n            cond = (0, codegen_1._) `${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n            break;\n        case \"integer\":\n            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);\n            break;\n        case \"number\":\n            cond = numCond();\n            break;\n        default:\n            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;\n    }\n    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n    function numCond(_cond = codegen_1.nil) {\n        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);\n    }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n    if (dataTypes.length === 1) {\n        return checkDataType(dataTypes[0], data, strictNums, correct);\n    }\n    let cond;\n    const types = (0, util_1.toHash)(dataTypes);\n    if (types.array && types.object) {\n        const notObj = (0, codegen_1._) `typeof ${data} != \"object\"`;\n        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;\n        delete types.null;\n        delete types.array;\n        delete types.object;\n    }\n    else {\n        cond = codegen_1.nil;\n    }\n    if (types.number)\n        delete types.integer;\n    for (const t in types)\n        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n    return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n    message: ({ schema }) => `must be ${schema}`,\n    params: ({ schema, schemaValue }) => typeof schema == \"string\" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,\n};\nfunction reportTypeError(it) {\n    const cxt = getTypeErrorContext(it);\n    (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n    const { gen, data, schema } = it;\n    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n    return {\n        gen,\n        keyword: \"type\",\n        data,\n        schema: schema.type,\n        schemaCode,\n        schemaValue: schemaCode,\n        parentSchema: schema,\n        params: {},\n        it,\n    };\n}\n//# sourceMappingURL=dataType.js.map","import type {\n  KeywordErrorDefinition,\n  KeywordErrorCxt,\n  ErrorObject,\n  AnySchemaObject,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {isJSONType, JSONType} from \"../rules\"\nimport {schemaHasRulesForType} from \"./applicability\"\nimport {reportError} from \"../errors\"\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\nimport {toHash, schemaRefOrVal} from \"../util\"\n\nexport enum DataType {\n  Correct,\n  Wrong,\n}\n\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\n  const types = getJSONTypes(schema.type)\n  const hasNull = types.includes(\"null\")\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"')\n    }\n    if (schema.nullable === true) types.push(\"null\")\n  }\n  return types\n}\n\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\n  if (types.every(isJSONType)) return types\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\n}\n\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\n  const {gen, data, opts} = it\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\n  const checkTypes =\n    types.length > 0 &&\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo)\n      else reportTypeError(it)\n    })\n  }\n  return checkTypes\n}\n\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\n  return coerceTypes\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n    : []\n}\n\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\n  const {gen, data, opts} = it\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\n  const coerced = gen.let(\"coerced\", _`undefined`)\n  if (opts.coerceTypes === \"array\") {\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\n      gen\n        .assign(data, _`${data}[0]`)\n        .assign(dataType, _`typeof ${data}`)\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\n    )\n  }\n  gen.if(_`${coerced} !== undefined`)\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n      coerceSpecificType(t)\n    }\n  }\n  gen.else()\n  reportTypeError(it)\n  gen.endIf()\n\n  gen.if(_`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced)\n    assignParentData(it, coerced)\n  })\n\n  function coerceSpecificType(t: string): void {\n    switch (t) {\n      case \"string\":\n        gen\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n          .assign(coerced, _`\"\" + ${data}`)\n          .elseIf(_`${data} === null`)\n          .assign(coerced, _`\"\"`)\n        return\n      case \"number\":\n        gen\n          .elseIf(\n            _`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"integer\":\n        gen\n          .elseIf(\n            _`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"boolean\":\n        gen\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\n          .assign(coerced, false)\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\n          .assign(coerced, true)\n        return\n      case \"null\":\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\n        gen.assign(coerced, null)\n        return\n\n      case \"array\":\n        gen\n          .elseIf(\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`\n          )\n          .assign(coerced, _`[${data}]`)\n    }\n  }\n}\n\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\n  // TODO use gen.property\n  gen.if(_`${parentData} !== undefined`, () =>\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\n  )\n}\n\nexport function checkDataType(\n  dataType: JSONType,\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct = DataType.Correct\n): Code {\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\n  let cond: Code\n  switch (dataType) {\n    case \"null\":\n      return _`${data} ${EQ} null`\n    case \"array\":\n      cond = _`Array.isArray(${data})`\n      break\n    case \"object\":\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\n      break\n    case \"integer\":\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\n      break\n    case \"number\":\n      cond = numCond()\n      break\n    default:\n      return _`typeof ${data} ${EQ} ${dataType}`\n  }\n  return correct === DataType.Correct ? cond : not(cond)\n\n  function numCond(_cond: Code = nil): Code {\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\n  }\n}\n\nexport function checkDataTypes(\n  dataTypes: JSONType[],\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct?: DataType\n): Code {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct)\n  }\n  let cond: Code\n  const types = toHash(dataTypes)\n  if (types.array && types.object) {\n    const notObj = _`typeof ${data} != \"object\"`\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\n    delete types.null\n    delete types.array\n    delete types.object\n  } else {\n    cond = nil\n  }\n  if (types.number) delete types.integer\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\n  return cond\n}\n\nexport type TypeError = ErrorObject<\"type\", {type: string}>\n\nconst typeError: KeywordErrorDefinition = {\n  message: ({schema}) => `must be ${schema}`,\n  params: ({schema, schemaValue}) =>\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\n}\n\nexport function reportTypeError(it: SchemaObjCxt): void {\n  const cxt = getTypeErrorContext(it)\n  reportError(cxt, typeError)\n}\n\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\n  const {gen, data, schema} = it\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it,\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getRules = exports.isJSONType = void 0;\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"];\nconst jsonTypes = new Set(_jsonTypes);\nfunction isJSONType(x) {\n    return typeof x == \"string\" && jsonTypes.has(x);\n}\nexports.isJSONType = isJSONType;\nfunction getRules() {\n    const groups = {\n        number: { type: \"number\", rules: [] },\n        string: { type: \"string\", rules: [] },\n        array: { type: \"array\", rules: [] },\n        object: { type: \"object\", rules: [] },\n    };\n    return {\n        types: { ...groups, integer: true, boolean: true, null: true },\n        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],\n        post: { rules: [] },\n        all: {},\n        keywords: {},\n    };\n}\nexports.getRules = getRules;\n//# sourceMappingURL=rules.js.map","import type {AddedKeywordDefinition} from \"../types\"\n\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"] as const\n\nexport type JSONType = typeof _jsonTypes[number]\n\nconst jsonTypes: Set<string> = new Set(_jsonTypes)\n\nexport function isJSONType(x: unknown): x is JSONType {\n  return typeof x == \"string\" && jsonTypes.has(x)\n}\n\ntype ValidationTypes = {\n  [K in JSONType]: boolean | RuleGroup | undefined\n}\n\nexport interface ValidationRules {\n  rules: RuleGroup[]\n  post: RuleGroup\n  all: {[Key in string]?: boolean | Rule} // rules that have to be validated\n  keywords: {[Key in string]?: boolean} // all known keywords (superset of \"all\")\n  types: ValidationTypes\n}\n\nexport interface RuleGroup {\n  type?: JSONType\n  rules: Rule[]\n}\n\n// This interface wraps KeywordDefinition because definition can have multiple keywords\nexport interface Rule {\n  keyword: string\n  definition: AddedKeywordDefinition\n}\n\nexport function getRules(): ValidationRules {\n  const groups: Record<\"number\" | \"string\" | \"array\" | \"object\", RuleGroup> = {\n    number: {type: \"number\", rules: []},\n    string: {type: \"string\", rules: []},\n    array: {type: \"array\", rules: []},\n    object: {type: \"object\", rules: []},\n  }\n  return {\n    types: {...groups, integer: true, boolean: true, null: true},\n    rules: [{rules: []}, groups.number, groups.string, groups.array, groups.object],\n    post: {rules: []},\n    all: {},\n    keywords: {},\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;\nfunction schemaHasRulesForType({ schema, self }, type) {\n    const group = self.RULES.types[type];\n    return group && group !== true && shouldUseGroup(schema, group);\n}\nexports.schemaHasRulesForType = schemaHasRulesForType;\nfunction shouldUseGroup(schema, group) {\n    return group.rules.some((rule) => shouldUseRule(schema, rule));\n}\nexports.shouldUseGroup = shouldUseGroup;\nfunction shouldUseRule(schema, rule) {\n    var _a;\n    return (schema[rule.keyword] !== undefined ||\n        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));\n}\nexports.shouldUseRule = shouldUseRule;\n//# sourceMappingURL=applicability.js.map","import type {AnySchemaObject} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport type {JSONType, RuleGroup, Rule} from \"../rules\"\n\nexport function schemaHasRulesForType(\n  {schema, self}: SchemaObjCxt,\n  type: JSONType\n): boolean | undefined {\n  const group = self.RULES.types[type]\n  return group && group !== true && shouldUseGroup(schema, group)\n}\n\nexport function shouldUseGroup(schema: AnySchemaObject, group: RuleGroup): boolean {\n  return group.rules.some((rule) => shouldUseRule(schema, rule))\n}\n\nexport function shouldUseRule(schema: AnySchemaObject, rule: Rule): boolean | undefined {\n  return (\n    schema[rule.keyword] !== undefined ||\n    rule.definition.implements?.some((kwd) => schema[kwd] !== undefined)\n  )\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assignDefaults = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nfunction assignDefaults(it, ty) {\n    const { properties, items } = it.schema;\n    if (ty === \"object\" && properties) {\n        for (const key in properties) {\n            assignDefault(it, key, properties[key].default);\n        }\n    }\n    else if (ty === \"array\" && Array.isArray(items)) {\n        items.forEach((sch, i) => assignDefault(it, i, sch.default));\n    }\n}\nexports.assignDefaults = assignDefaults;\nfunction assignDefault(it, prop, defaultValue) {\n    const { gen, compositeRule, data, opts } = it;\n    if (defaultValue === undefined)\n        return;\n    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;\n    if (compositeRule) {\n        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);\n        return;\n    }\n    let condition = (0, codegen_1._) `${childData} === undefined`;\n    if (opts.useDefaults === \"empty\") {\n        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === \"\"`;\n    }\n    // `${childData} === undefined` +\n    // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);\n}\n//# sourceMappingURL=defaults.js.map","import type {SchemaObjCxt} from \"..\"\nimport {_, getProperty, stringify} from \"../codegen\"\nimport {checkStrictMode} from \"../util\"\n\nexport function assignDefaults(it: SchemaObjCxt, ty?: string): void {\n  const {properties, items} = it.schema\n  if (ty === \"object\" && properties) {\n    for (const key in properties) {\n      assignDefault(it, key, properties[key].default)\n    }\n  } else if (ty === \"array\" && Array.isArray(items)) {\n    items.forEach((sch, i: number) => assignDefault(it, i, sch.default))\n  }\n}\n\nfunction assignDefault(it: SchemaObjCxt, prop: string | number, defaultValue: unknown): void {\n  const {gen, compositeRule, data, opts} = it\n  if (defaultValue === undefined) return\n  const childData = _`${data}${getProperty(prop)}`\n  if (compositeRule) {\n    checkStrictMode(it, `default is ignored for: ${childData}`)\n    return\n  }\n\n  let condition = _`${childData} === undefined`\n  if (opts.useDefaults === \"empty\") {\n    condition = _`${condition} || ${childData} === null || ${childData} === \"\"`\n  }\n  // `${childData} === undefined` +\n  // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n  gen.if(condition, _`${childData} = ${stringify(defaultValue)}`)\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst errors_1 = require(\"../errors\");\nfunction macroKeywordCode(cxt, def) {\n    const { gen, keyword, schema, parentSchema, it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true,\n    }, valid);\n    cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n    checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = useKeyword(gen, keyword, validate);\n    const valid = gen.let(\"valid\");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => cxt.error());\n        }\n        else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !((\"compile\" in def && !$data) || def.schema === false);\n        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n    const { gen, data, it } = cxt;\n    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n    const { gen } = cxt;\n    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {\n        gen\n            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)\n            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n        (0, errors_1.extendErrors)(cxt);\n    }, () => cxt.error());\n}\nfunction checkAsyncKeyword({ schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n    if (result === undefined)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n    return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return (!schemaType.length ||\n        schemaType.some((st) => st === \"array\"\n            ? Array.isArray(schema)\n            : st === \"object\"\n                ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n                : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")));\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */\n    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n    }\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n    }\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n                self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === \"log\")\n                self.logger.error(msg);\n            else\n                throw new Error(msg);\n        }\n    }\n}\nexports.validateKeywordUsage = validateKeywordUsage;\n//# sourceMappingURL=keyword.js.map","import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;\nconst codegen_1 = require(\"../compile/codegen\");\nconst util_1 = require(\"../compile/util\");\nconst names_1 = require(\"../compile/names\");\nconst util_2 = require(\"../compile/util\");\nfunction checkReportMissingProp(cxt, prop) {\n    const { gen, data, it } = cxt;\n    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);\n        cxt.error();\n    });\n}\nexports.checkReportMissingProp = checkReportMissingProp;\nfunction checkMissingProp({ gen, data, it: { opts } }, properties, missing) {\n    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));\n}\nexports.checkMissingProp = checkMissingProp;\nfunction reportMissingProp(cxt, missing) {\n    cxt.setParams({ missingProperty: missing }, true);\n    cxt.error();\n}\nexports.reportMissingProp = reportMissingProp;\nfunction hasPropFunc(gen) {\n    return gen.scopeValue(\"func\", {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        ref: Object.prototype.hasOwnProperty,\n        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,\n    });\n}\nexports.hasPropFunc = hasPropFunc;\nfunction isOwnProperty(gen, data, property) {\n    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;\n}\nexports.isOwnProperty = isOwnProperty;\nfunction propertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;\n    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;\n}\nexports.propertyInData = propertyInData;\nfunction noPropertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;\n    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;\n}\nexports.noPropertyInData = noPropertyInData;\nfunction allSchemaProperties(schemaMap) {\n    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : [];\n}\nexports.allSchemaProperties = allSchemaProperties;\nfunction schemaProperties(it, schemaMap) {\n    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));\n}\nexports.schemaProperties = schemaProperties;\nfunction callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {\n    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;\n    const valCxt = [\n        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],\n        [names_1.default.parentData, it.parentData],\n        [names_1.default.parentDataProperty, it.parentDataProperty],\n        [names_1.default.rootData, names_1.default.rootData],\n    ];\n    if (it.opts.dynamicRef)\n        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;\n    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;\n}\nexports.callValidateCode = callValidateCode;\nconst newRegExp = (0, codegen_1._) `new RegExp`;\nfunction usePattern({ gen, it: { opts } }, pattern) {\n    const u = opts.unicodeRegExp ? \"u\" : \"\";\n    const { regExp } = opts.code;\n    const rx = regExp(pattern, u);\n    return gen.scopeValue(\"pattern\", {\n        key: rx.toString(),\n        ref: rx,\n        code: (0, codegen_1._) `${regExp.code === \"new RegExp\" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,\n    });\n}\nexports.usePattern = usePattern;\nfunction validateArray(cxt) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    if (it.allErrors) {\n        const validArr = gen.let(\"valid\", true);\n        validateItems(() => gen.assign(validArr, false));\n        return validArr;\n    }\n    gen.var(valid, true);\n    validateItems(() => gen.break());\n    return valid;\n    function validateItems(notValid) {\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        gen.forRange(\"i\", 0, len, (i) => {\n            cxt.subschema({\n                keyword,\n                dataProp: i,\n                dataPropType: util_1.Type.Num,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), notValid);\n        });\n    }\n}\nexports.validateArray = validateArray;\nfunction validateUnion(cxt) {\n    const { gen, schema, keyword, it } = cxt;\n    /* istanbul ignore if */\n    if (!Array.isArray(schema))\n        throw new Error(\"ajv implementation error\");\n    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));\n    if (alwaysValid && !it.opts.unevaluated)\n        return;\n    const valid = gen.let(\"valid\", false);\n    const schValid = gen.name(\"_valid\");\n    gen.block(() => schema.forEach((_sch, i) => {\n        const schCxt = cxt.subschema({\n            keyword,\n            schemaProp: i,\n            compositeRule: true,\n        }, schValid);\n        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);\n        const merged = cxt.mergeValidEvaluated(schCxt, schValid);\n        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n        // or if all properties and items were evaluated (it.props === true && it.items === true)\n        if (!merged)\n            gen.if((0, codegen_1.not)(valid));\n    }));\n    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n}\nexports.validateUnion = validateUnion;\n//# sourceMappingURL=code.js.map","import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nfunction getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {\n    if (keyword !== undefined && schema !== undefined) {\n        throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n    }\n    if (keyword !== undefined) {\n        const sch = it.schema[keyword];\n        return schemaProp === undefined\n            ? {\n                schema: sch,\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n            }\n            : {\n                schema: sch[schemaProp],\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,\n            };\n    }\n    if (schema !== undefined) {\n        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n            throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n        }\n        return {\n            schema,\n            schemaPath,\n            topSchemaRef,\n            errSchemaPath,\n        };\n    }\n    throw new Error('either \"keyword\" or \"schema\" must be passed');\n}\nexports.getSubschema = getSubschema;\nfunction extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {\n    if (data !== undefined && dataProp !== undefined) {\n        throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n    }\n    const { gen } = it;\n    if (dataProp !== undefined) {\n        const { errorPath, dataPathArr, opts } = it;\n        const nextData = gen.let(\"data\", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);\n        dataContextProps(nextData);\n        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;\n        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;\n        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n    }\n    if (data !== undefined) {\n        const nextData = data instanceof codegen_1.Name ? data : gen.let(\"data\", data, true); // replaceable if used once?\n        dataContextProps(nextData);\n        if (propertyName !== undefined)\n            subschema.propertyName = propertyName;\n        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n    }\n    if (dataTypes)\n        subschema.dataTypes = dataTypes;\n    function dataContextProps(_nextData) {\n        subschema.data = _nextData;\n        subschema.dataLevel = it.dataLevel + 1;\n        subschema.dataTypes = [];\n        it.definedProperties = new Set();\n        subschema.parentData = it.data;\n        subschema.dataNames = [...it.dataNames, _nextData];\n    }\n}\nexports.extendSubschemaData = extendSubschemaData;\nfunction extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {\n    if (compositeRule !== undefined)\n        subschema.compositeRule = compositeRule;\n    if (createErrors !== undefined)\n        subschema.createErrors = createErrors;\n    if (allErrors !== undefined)\n        subschema.allErrors = allErrors;\n    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited\n    subschema.jtdMetadata = jtdMetadata; // not inherited\n}\nexports.extendSubschemaMode = extendSubschemaMode;\n//# sourceMappingURL=subschema.js.map","import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nconst util_1 = require(\"./util\");\nconst equal = require(\"fast-deep-equal\");\nconst traverse = require(\"json-schema-traverse\");\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n    \"type\",\n    \"format\",\n    \"pattern\",\n    \"maxLength\",\n    \"minLength\",\n    \"maxProperties\",\n    \"minProperties\",\n    \"maxItems\",\n    \"minItems\",\n    \"maximum\",\n    \"minimum\",\n    \"uniqueItems\",\n    \"multipleOf\",\n    \"required\",\n    \"enum\",\n    \"const\",\n]);\nfunction inlineRef(schema, limit = true) {\n    if (typeof schema == \"boolean\")\n        return true;\n    if (limit === true)\n        return !hasRef(schema);\n    if (!limit)\n        return false;\n    return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\n    \"$ref\",\n    \"$recursiveRef\",\n    \"$recursiveAnchor\",\n    \"$dynamicRef\",\n    \"$dynamicAnchor\",\n]);\nfunction hasRef(schema) {\n    for (const key in schema) {\n        if (REF_KEYWORDS.has(key))\n            return true;\n        const sch = schema[key];\n        if (Array.isArray(sch) && sch.some(hasRef))\n            return true;\n        if (typeof sch == \"object\" && hasRef(sch))\n            return true;\n    }\n    return false;\n}\nfunction countKeys(schema) {\n    let count = 0;\n    for (const key in schema) {\n        if (key === \"$ref\")\n            return Infinity;\n        count++;\n        if (SIMPLE_INLINED.has(key))\n            continue;\n        if (typeof schema[key] == \"object\") {\n            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));\n        }\n        if (count === Infinity)\n            return Infinity;\n    }\n    return count;\n}\nfunction getFullPath(resolver, id = \"\", normalize) {\n    if (normalize !== false)\n        id = normalizeId(id);\n    const p = resolver.parse(id);\n    return _getFullPath(resolver, p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(resolver, p) {\n    const serialized = resolver.serialize(p);\n    return serialized.split(\"#\")[0] + \"#\";\n}\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(resolver, baseId, id) {\n    id = normalizeId(id);\n    return resolver.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema, baseId) {\n    if (typeof schema == \"boolean\")\n        return {};\n    const { schemaId, uriResolver } = this.opts;\n    const schId = normalizeId(schema[schemaId] || baseId);\n    const baseIds = { \"\": schId };\n    const pathPrefix = getFullPath(uriResolver, schId, false);\n    const localRefs = {};\n    const schemaRefs = new Set();\n    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {\n        if (parentJsonPtr === undefined)\n            return;\n        const fullPath = pathPrefix + jsonPtr;\n        let baseId = baseIds[parentJsonPtr];\n        if (typeof sch[schemaId] == \"string\")\n            baseId = addRef.call(this, sch[schemaId]);\n        addAnchor.call(this, sch.$anchor);\n        addAnchor.call(this, sch.$dynamicAnchor);\n        baseIds[jsonPtr] = baseId;\n        function addRef(ref) {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            const _resolve = this.opts.uriResolver.resolve;\n            ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);\n            if (schemaRefs.has(ref))\n                throw ambiguos(ref);\n            schemaRefs.add(ref);\n            let schOrRef = this.refs[ref];\n            if (typeof schOrRef == \"string\")\n                schOrRef = this.refs[schOrRef];\n            if (typeof schOrRef == \"object\") {\n                checkAmbiguosRef(sch, schOrRef.schema, ref);\n            }\n            else if (ref !== normalizeId(fullPath)) {\n                if (ref[0] === \"#\") {\n                    checkAmbiguosRef(sch, localRefs[ref], ref);\n                    localRefs[ref] = sch;\n                }\n                else {\n                    this.refs[ref] = fullPath;\n                }\n            }\n            return ref;\n        }\n        function addAnchor(anchor) {\n            if (typeof anchor == \"string\") {\n                if (!ANCHOR.test(anchor))\n                    throw new Error(`invalid anchor \"${anchor}\"`);\n                addRef.call(this, `#${anchor}`);\n            }\n        }\n    });\n    return localRefs;\n    function checkAmbiguosRef(sch1, sch2, ref) {\n        if (sch2 !== undefined && !equal(sch1, sch2))\n            throw ambiguos(ref);\n    }\n    function ambiguos(ref) {\n        return new Error(`reference \"${ref}\" resolves to more than one schema`);\n    }\n}\nexports.getSchemaRefs = getSchemaRefs;\n//# sourceMappingURL=resolve.js.map","import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport type {URIComponents} from \"uri-js\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = resolver.parse(id)\n  return _getFullPath(resolver, p)\n}\n\nexport function _getFullPath(resolver: UriResolver, p: URIComponents): string {\n  const serialized = resolver.serialize(p)\n  return serialized.split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\n  id = normalizeId(id)\n  return resolver.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId, uriResolver} = this.opts\n  const schId = normalizeId(schema[schemaId] || baseId)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(uriResolver, schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let baseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = baseId\n\n    function addRef(this: Ajv, ref: string): string {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve\n      ref = normalizeId(baseId ? _resolve(baseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass ValidationError extends Error {\n    constructor(errors) {\n        super(\"validation failed\");\n        this.errors = errors;\n        this.ajv = this.validation = true;\n    }\n}\nexports.default = ValidationError;\n//# sourceMappingURL=validation_error.js.map","import type {ErrorObject} from \"../types\"\n\nexport default class ValidationError extends Error {\n  readonly errors: Partial<ErrorObject>[]\n  readonly ajv: true\n  readonly validation: true\n\n  constructor(errors: Partial<ErrorObject>[]) {\n    super(\"validation failed\")\n    this.errors = errors\n    this.ajv = this.validation = true\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst resolve_1 = require(\"./resolve\");\nclass MissingRefError extends Error {\n    constructor(resolver, baseId, ref, msg) {\n        super(msg || `can't resolve reference ${ref} from id ${baseId}`);\n        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);\n        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));\n    }\n}\nexports.default = MissingRefError;\n//# sourceMappingURL=ref_error.js.map","import {resolveUrl, normalizeId, getFullPath} from \"./resolve\"\nimport type {UriResolver} from \"../types\"\n\nexport default class MissingRefError extends Error {\n  readonly missingRef: string\n  readonly missingSchema: string\n\n  constructor(resolver: UriResolver, baseId: string, ref: string, msg?: string) {\n    super(msg || `can't resolve reference ${ref} from id ${baseId}`)\n    this.missingRef = resolveUrl(resolver, baseId, ref)\n    this.missingSchema = normalizeId(getFullPath(resolver, this.missingRef))\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst validation_error_1 = require(\"../runtime/validation_error\");\nconst names_1 = require(\"./names\");\nconst resolve_1 = require(\"./resolve\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nclass SchemaEnv {\n    constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\")\n            schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n    }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n    // TODO refactor - remove compilations\n    const _sch = getCompilingSchema.call(this, sch);\n    if (_sch)\n        return _sch;\n    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n    const { es5, lines } = this.opts.code;\n    const { ownProperties } = this.opts;\n    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n    let _ValidationError;\n    if (sch.$async) {\n        _ValidationError = gen.scopeValue(\"Error\", {\n            ref: validation_error_1.default,\n            code: (0, codegen_1._) `require(\"ajv/dist/runtime/validation_error\").default`,\n        });\n    }\n    const validateName = gen.scopeName(\"validate\");\n    sch.validateName = validateName;\n    const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil],\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true\n            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }\n            : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: (0, codegen_1._) `\"\"`,\n        opts: this.opts,\n        self: this,\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        (0, validate_1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        // gen.optimize(1)\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n        if (this.opts.code.process)\n            sourceCode = this.opts.code.process(sourceCode, sch);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n            validate.$async = true;\n        if (this.opts.code.source === true) {\n            validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n            const { props, items } = schemaCxt;\n            validate.evaluated = {\n                props: props instanceof codegen_1.Name ? undefined : props,\n                items: items instanceof codegen_1.Name ? undefined : items,\n                dynamicProps: props instanceof codegen_1.Name,\n                dynamicItems: items instanceof codegen_1.Name,\n            };\n            if (validate.source)\n                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n    }\n    catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n            this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n        throw e;\n    }\n    finally {\n        this._compilations.delete(sch);\n    }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n    var _a;\n    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n    const schOrFunc = root.refs[ref];\n    if (schOrFunc)\n        return schOrFunc;\n    let _sch = resolve.call(this, root, ref);\n    if (_sch === undefined) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n        const { schemaId } = this.opts;\n        if (schema)\n            _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    if (_sch === undefined)\n        return;\n    return (root.refs[ref] = inlineOrCompile.call(this, _sch));\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n    return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n    for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n            return sch;\n    }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n    let sch;\n    while (typeof (sch = this.refs[ref]) == \"string\")\n        ref = sch;\n    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n    const p = this.opts.uriResolver.parse(ref);\n    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n    if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n    }\n    const id = (0, resolve_1.normalizeId)(refPath);\n    const schOrRef = this.refs[id] || this.schemas[id];\n    if (typeof schOrRef == \"string\") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\")\n            return;\n        return getJsonPointer.call(this, p, sch);\n    }\n    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\")\n        return;\n    if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n    if (id === (0, resolve_1.normalizeId)(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\n    \"properties\",\n    \"patternProperties\",\n    \"enum\",\n    \"dependencies\",\n    \"definitions\",\n]);\nfunction getJsonPointer(parsedRef, { baseId, schema, root }) {\n    var _a;\n    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\")\n        return;\n    for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n        if (typeof schema === \"boolean\")\n            return;\n        const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n        if (partSchema === undefined)\n            return;\n        schema = partSchema;\n        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n        const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        }\n    }\n    let env;\n    if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n    }\n    // even though resolution failed we need to return SchemaEnv to throw exception\n    // so that compileAsync loads missing schema.\n    const { schemaId } = this.opts;\n    env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n    if (env.schema !== env.root.schema)\n        return env;\n    return undefined;\n}\n//# sourceMappingURL=index.js.map","import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport * as URI from \"uri-js\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  ref: string\n): AnySchema | SchemaEnv | undefined {\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = this.opts.uriResolver.parse(ref)\n  const refPath = _getFullPath(this.opts.uriResolver, p)\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URI.URIComponents,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return\n    const partSchema = schema[unescapeFragment(part)]\n    if (partSchema === undefined) return\n    schema = partSchema\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n","{\n  \"$id\": \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n  \"description\": \"Meta-schema for $data reference (JSON AnySchema extension proposal)\",\n  \"type\": \"object\",\n  \"required\": [\"$data\"],\n  \"properties\": {\n    \"$data\": {\n      \"type\": \"string\",\n      \"anyOf\": [{\"format\": \"relative-json-pointer\"}, {\"format\": \"json-pointer\"}]\n    }\n  },\n  \"additionalProperties\": false\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst uri = require(\"uri-js\");\nuri.code = 'require(\"ajv/dist/runtime/uri\").default';\nexports.default = uri;\n//# sourceMappingURL=uri.js.map","import * as uri from \"uri-js\"\n\ntype URI = typeof uri & {code: string}\n;(uri as URI).code = 'require(\"ajv/dist/runtime/uri\").default'\n\nexport default uri as URI\n","/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.URI = global.URI || {})));\n}(this, (function (exports) { 'use strict';\n\nfunction merge() {\n    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {\n        sets[_key] = arguments[_key];\n    }\n\n    if (sets.length > 1) {\n        sets[0] = sets[0].slice(0, -1);\n        var xl = sets.length - 1;\n        for (var x = 1; x < xl; ++x) {\n            sets[x] = sets[x].slice(1, -1);\n        }\n        sets[xl] = sets[xl].slice(1);\n        return sets.join('');\n    } else {\n        return sets[0];\n    }\n}\nfunction subexp(str) {\n    return \"(?:\" + str + \")\";\n}\nfunction typeOf(o) {\n    return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n}\nfunction toUpperCase(str) {\n    return str.toUpperCase();\n}\nfunction toArray(obj) {\n    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\n}\nfunction assign(target, source) {\n    var obj = target;\n    if (source) {\n        for (var key in source) {\n            obj[key] = source[key];\n        }\n    }\n    return obj;\n}\n\nfunction buildExps(isIRI) {\n    var ALPHA$$ = \"[A-Za-z]\",\n        CR$ = \"[\\\\x0D]\",\n        DIGIT$$ = \"[0-9]\",\n        DQUOTE$$ = \"[\\\\x22]\",\n        HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),\n        //case-insensitive\n    LF$$ = \"[\\\\x0A]\",\n        SP$$ = \"[\\\\x20]\",\n        PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),\n        //expanded\n    GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n        SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n        UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",\n        //subset, excludes bidi control characters\n    IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\n        //subset\n    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n        USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n        DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n        DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),\n        //relaxed parsing rules\n    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n        H16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n        LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n        IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$),\n        //                           6( h16 \":\" ) ls32\n    IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$),\n        //                      \"::\" 5( h16 \":\" ) ls32\n    IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$),\n        //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$),\n        //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$),\n        //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$),\n        //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$),\n        //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$),\n        //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"),\n        //[ *6( h16 \":\" ) h16 ] \"::\"\n    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n        ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),\n        //RFC 6874\n    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),\n        //RFC 6874\n    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),\n        //RFC 6874, with relaxed parsing rules\n    IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n        IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),\n        //RFC 6874\n    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n        HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n        PORT$ = subexp(DIGIT$$ + \"*\"),\n        AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n        PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n        SEGMENT$ = subexp(PCHAR$ + \"*\"),\n        SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n        PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n        PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),\n        //simplified\n    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n        PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n        FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n        HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n        RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n        ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n        GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n        SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n    return {\n        NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n        NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n        NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n        ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n        OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n        PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n        IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n        IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n    };\n}\nvar URI_PROTOCOL = buildExps(false);\n\nvar IRI_PROTOCOL = buildExps(true);\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/** Highest positive signed 32-bit float value */\n\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nvar regexPunycode = /^xn--/;\nvar regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nvar regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nvar errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error$1(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tvar result = [];\n\tvar length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tvar parts = string.split('@');\n\tvar result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tvar labels = string.split('.');\n\tvar encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tvar output = [];\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t// Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nvar ucs2encode = function ucs2encode(array) {\n\treturn String.fromCodePoint.apply(String, toConsumableArray(array));\n};\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nvar basicToDigit = function basicToDigit(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nvar digitToBasic = function digitToBasic(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nvar adapt = function adapt(delta, numPoints, firstTime) {\n\tvar k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nvar decode = function decode(input) {\n\t// Don't use UCS-2.\n\tvar output = [];\n\tvar inputLength = input.length;\n\tvar i = 0;\n\tvar n = initialN;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tvar basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (var j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror$1('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tvar oldi = i;\n\t\tfor (var w = 1, k = base;; /* no condition */k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror$1('invalid-input');\n\t\t\t}\n\n\t\t\tvar digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\t\t}\n\n\t\tvar out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\t}\n\n\treturn String.fromCodePoint.apply(String, output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nvar encode = function encode(input) {\n\tvar output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tvar inputLength = input.length;\n\n\t// Initialize the state.\n\tvar n = initialN;\n\tvar delta = 0;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points.\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar _currentValue2 = _step.value;\n\n\t\t\tif (_currentValue2 < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(_currentValue2));\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar basicLength = output.length;\n\tvar handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tvar m = maxInt;\n\t\tvar _iteratorNormalCompletion2 = true;\n\t\tvar _didIteratorError2 = false;\n\t\tvar _iteratorError2 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\tvar currentValue = _step2.value;\n\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow.\n\t\t} catch (err) {\n\t\t\t_didIteratorError2 = true;\n\t\t\t_iteratorError2 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t_iterator2.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tvar _iteratorNormalCompletion3 = true;\n\t\tvar _didIteratorError3 = false;\n\t\tvar _iteratorError3 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\tvar _currentValue = _step3.value;\n\n\t\t\t\tif (_currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror$1('overflow');\n\t\t\t\t}\n\t\t\t\tif (_currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\t\tvar q = delta;\n\t\t\t\t\tfor (var k = base;; /* no condition */k += base) {\n\t\t\t\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar qMinusT = q - t;\n\t\t\t\t\t\tvar baseMinusT = base - t;\n\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError3 = true;\n\t\t\t_iteratorError3 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t_iterator3.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nvar toUnicode = function toUnicode(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nvar toASCII = function toASCII(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nvar punycode = {\n\t/**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */\n\t'version': '2.1.0',\n\t/**\n  * An object of methods to convert from JavaScript's internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\n/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\nvar SCHEMES = {};\nfunction pctEncChar(chr) {\n    var c = chr.charCodeAt(0);\n    var e = void 0;\n    if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n    return e;\n}\nfunction pctDecChars(str) {\n    var newStr = \"\";\n    var i = 0;\n    var il = str.length;\n    while (i < il) {\n        var c = parseInt(str.substr(i + 1, 2), 16);\n        if (c < 128) {\n            newStr += String.fromCharCode(c);\n            i += 3;\n        } else if (c >= 194 && c < 224) {\n            if (il - i >= 6) {\n                var c2 = parseInt(str.substr(i + 4, 2), 16);\n                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n            } else {\n                newStr += str.substr(i, 6);\n            }\n            i += 6;\n        } else if (c >= 224) {\n            if (il - i >= 9) {\n                var _c = parseInt(str.substr(i + 4, 2), 16);\n                var c3 = parseInt(str.substr(i + 7, 2), 16);\n                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n            } else {\n                newStr += str.substr(i, 9);\n            }\n            i += 9;\n        } else {\n            newStr += str.substr(i, 3);\n            i += 3;\n        }\n    }\n    return newStr;\n}\nfunction _normalizeComponentEncoding(components, protocol) {\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n    }\n    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    return components;\n}\n\nfunction _stripLeadingZeros(str) {\n    return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\nfunction _normalizeIPv4(host, protocol) {\n    var matches = host.match(protocol.IPV4ADDRESS) || [];\n\n    var _matches = slicedToArray(matches, 2),\n        address = _matches[1];\n\n    if (address) {\n        return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n    } else {\n        return host;\n    }\n}\nfunction _normalizeIPv6(host, protocol) {\n    var matches = host.match(protocol.IPV6ADDRESS) || [];\n\n    var _matches2 = slicedToArray(matches, 3),\n        address = _matches2[1],\n        zone = _matches2[2];\n\n    if (address) {\n        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),\n            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),\n            last = _address$toLowerCase$2[0],\n            first = _address$toLowerCase$2[1];\n\n        var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n        var lastFields = last.split(\":\").map(_stripLeadingZeros);\n        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n        var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n        var lastFieldsStart = lastFields.length - fieldCount;\n        var fields = Array(fieldCount);\n        for (var x = 0; x < fieldCount; ++x) {\n            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n        }\n        if (isLastFieldIPv4Address) {\n            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n        }\n        var allZeroFields = fields.reduce(function (acc, field, index) {\n            if (!field || field === \"0\") {\n                var lastLongest = acc[acc.length - 1];\n                if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                    lastLongest.length++;\n                } else {\n                    acc.push({ index: index, length: 1 });\n                }\n            }\n            return acc;\n        }, []);\n        var longestZeroFields = allZeroFields.sort(function (a, b) {\n            return b.length - a.length;\n        })[0];\n        var newHost = void 0;\n        if (longestZeroFields && longestZeroFields.length > 1) {\n            var newFirst = fields.slice(0, longestZeroFields.index);\n            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n            newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n        } else {\n            newHost = fields.join(\":\");\n        }\n        if (zone) {\n            newHost += \"%\" + zone;\n        }\n        return newHost;\n    } else {\n        return host;\n    }\n}\nvar URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nvar NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\nfunction parse(uriString) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var components = {};\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n    var matches = uriString.match(URI_PARSE);\n    if (matches) {\n        if (NO_MATCH_IS_UNDEFINED) {\n            //store each component\n            components.scheme = matches[1];\n            components.userinfo = matches[3];\n            components.host = matches[4];\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = matches[7];\n            components.fragment = matches[8];\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = matches[5];\n            }\n        } else {\n            //IE FIX for improper RegExp matching\n            //store each component\n            components.scheme = matches[1] || undefined;\n            components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n            components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n            components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n            }\n        }\n        if (components.host) {\n            //normalize IP hosts\n            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n        }\n        //determine reference type\n        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n            components.reference = \"same-document\";\n        } else if (components.scheme === undefined) {\n            components.reference = \"relative\";\n        } else if (components.fragment === undefined) {\n            components.reference = \"absolute\";\n        } else {\n            components.reference = \"uri\";\n        }\n        //check for reference errors\n        if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n            components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n        }\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //check if scheme can't handle IRIs\n        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n            //if host component is a domain name\n            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            }\n            //convert IRI -> URI\n            _normalizeComponentEncoding(components, URI_PROTOCOL);\n        } else {\n            //normalize encodings\n            _normalizeComponentEncoding(components, protocol);\n        }\n        //perform scheme specific parsing\n        if (schemeHandler && schemeHandler.parse) {\n            schemeHandler.parse(components, options);\n        }\n    } else {\n        components.error = components.error || \"URI can not be parsed.\";\n    }\n    return components;\n}\n\nfunction _recomposeAuthority(components, options) {\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    if (components.userinfo !== undefined) {\n        uriTokens.push(components.userinfo);\n        uriTokens.push(\"@\");\n    }\n    if (components.host !== undefined) {\n        //normalize IP hosts, add brackets and escape zone separator for IPv6\n        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {\n            return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n        }));\n    }\n    if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n        uriTokens.push(\":\");\n        uriTokens.push(String(components.port));\n    }\n    return uriTokens.length ? uriTokens.join(\"\") : undefined;\n}\n\nvar RDS1 = /^\\.\\.?\\//;\nvar RDS2 = /^\\/\\.(\\/|$)/;\nvar RDS3 = /^\\/\\.\\.(\\/|$)/;\nvar RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\nfunction removeDotSegments(input) {\n    var output = [];\n    while (input.length) {\n        if (input.match(RDS1)) {\n            input = input.replace(RDS1, \"\");\n        } else if (input.match(RDS2)) {\n            input = input.replace(RDS2, \"/\");\n        } else if (input.match(RDS3)) {\n            input = input.replace(RDS3, \"/\");\n            output.pop();\n        } else if (input === \".\" || input === \"..\") {\n            input = \"\";\n        } else {\n            var im = input.match(RDS5);\n            if (im) {\n                var s = im[0];\n                input = input.slice(s.length);\n                output.push(s);\n            } else {\n                throw new Error(\"Unexpected dot segment condition\");\n            }\n        }\n    }\n    return output.join(\"\");\n}\n\nfunction serialize(components) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    //find scheme handler\n    var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n    //perform scheme specific serialization\n    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n    if (components.host) {\n        //if host component is an IPv6 address\n        if (protocol.IPV6ADDRESS.test(components.host)) {}\n        //TODO: normalize IPv6 address as per RFC 5952\n\n        //if host component is a domain name\n        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n                //convert IDN via punycode\n                try {\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n            }\n    }\n    //normalize encoding\n    _normalizeComponentEncoding(components, protocol);\n    if (options.reference !== \"suffix\" && components.scheme) {\n        uriTokens.push(components.scheme);\n        uriTokens.push(\":\");\n    }\n    var authority = _recomposeAuthority(components, options);\n    if (authority !== undefined) {\n        if (options.reference !== \"suffix\") {\n            uriTokens.push(\"//\");\n        }\n        uriTokens.push(authority);\n        if (components.path && components.path.charAt(0) !== \"/\") {\n            uriTokens.push(\"/\");\n        }\n    }\n    if (components.path !== undefined) {\n        var s = components.path;\n        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n            s = removeDotSegments(s);\n        }\n        if (authority === undefined) {\n            s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n        }\n        uriTokens.push(s);\n    }\n    if (components.query !== undefined) {\n        uriTokens.push(\"?\");\n        uriTokens.push(components.query);\n    }\n    if (components.fragment !== undefined) {\n        uriTokens.push(\"#\");\n        uriTokens.push(components.fragment);\n    }\n    return uriTokens.join(\"\"); //merge tokens into a string\n}\n\nfunction resolveComponents(base, relative) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var skipNormalization = arguments[3];\n\n    var target = {};\n    if (!skipNormalization) {\n        base = parse(serialize(base, options), options); //normalize base components\n        relative = parse(serialize(relative, options), options); //normalize relative components\n    }\n    options = options || {};\n    if (!options.tolerant && relative.scheme) {\n        target.scheme = relative.scheme;\n        //target.authority = relative.authority;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || \"\");\n        target.query = relative.query;\n    } else {\n        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        } else {\n            if (!relative.path) {\n                target.path = base.path;\n                if (relative.query !== undefined) {\n                    target.query = relative.query;\n                } else {\n                    target.query = base.query;\n                }\n            } else {\n                if (relative.path.charAt(0) === \"/\") {\n                    target.path = removeDotSegments(relative.path);\n                } else {\n                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                        target.path = \"/\" + relative.path;\n                    } else if (!base.path) {\n                        target.path = relative.path;\n                    } else {\n                        target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                    }\n                    target.path = removeDotSegments(target.path);\n                }\n                target.query = relative.query;\n            }\n            //target.authority = base.authority;\n            target.userinfo = base.userinfo;\n            target.host = base.host;\n            target.port = base.port;\n        }\n        target.scheme = base.scheme;\n    }\n    target.fragment = relative.fragment;\n    return target;\n}\n\nfunction resolve(baseURI, relativeURI, options) {\n    var schemelessOptions = assign({ scheme: 'null' }, options);\n    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n}\n\nfunction normalize(uri, options) {\n    if (typeof uri === \"string\") {\n        uri = serialize(parse(uri, options), options);\n    } else if (typeOf(uri) === \"object\") {\n        uri = parse(serialize(uri, options), options);\n    }\n    return uri;\n}\n\nfunction equal(uriA, uriB, options) {\n    if (typeof uriA === \"string\") {\n        uriA = serialize(parse(uriA, options), options);\n    } else if (typeOf(uriA) === \"object\") {\n        uriA = serialize(uriA, options);\n    }\n    if (typeof uriB === \"string\") {\n        uriB = serialize(parse(uriB, options), options);\n    } else if (typeOf(uriB) === \"object\") {\n        uriB = serialize(uriB, options);\n    }\n    return uriA === uriB;\n}\n\nfunction escapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n}\n\nfunction unescapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n}\n\nvar handler = {\n    scheme: \"http\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        //report missing host\n        if (!components.host) {\n            components.error = components.error || \"HTTP URIs must have a host.\";\n        }\n        return components;\n    },\n    serialize: function serialize(components, options) {\n        var secure = String(components.scheme).toLowerCase() === \"https\";\n        //normalize the default port\n        if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n            components.port = undefined;\n        }\n        //normalize the empty path\n        if (!components.path) {\n            components.path = \"/\";\n        }\n        //NOTE: We do not parse query strings for HTTP URIs\n        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n        //and not the HTTP spec.\n        return components;\n    }\n};\n\nvar handler$1 = {\n    scheme: \"https\",\n    domainHost: handler.domainHost,\n    parse: handler.parse,\n    serialize: handler.serialize\n};\n\nfunction isSecure(wsComponents) {\n    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n//RFC 6455\nvar handler$2 = {\n    scheme: \"ws\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        var wsComponents = components;\n        //indicate if the secure flag is set\n        wsComponents.secure = isSecure(wsComponents);\n        //construct resouce name\n        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n        wsComponents.path = undefined;\n        wsComponents.query = undefined;\n        return wsComponents;\n    },\n    serialize: function serialize(wsComponents, options) {\n        //normalize the default port\n        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n            wsComponents.port = undefined;\n        }\n        //ensure scheme matches secure flag\n        if (typeof wsComponents.secure === 'boolean') {\n            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';\n            wsComponents.secure = undefined;\n        }\n        //reconstruct path from resource name\n        if (wsComponents.resourceName) {\n            var _wsComponents$resourc = wsComponents.resourceName.split('?'),\n                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),\n                path = _wsComponents$resourc2[0],\n                query = _wsComponents$resourc2[1];\n\n            wsComponents.path = path && path !== '/' ? path : undefined;\n            wsComponents.query = query;\n            wsComponents.resourceName = undefined;\n        }\n        //forbid fragment component\n        wsComponents.fragment = undefined;\n        return wsComponents;\n    }\n};\n\nvar handler$3 = {\n    scheme: \"wss\",\n    domainHost: handler$2.domainHost,\n    parse: handler$2.parse,\n    serialize: handler$2.serialize\n};\n\nvar O = {};\nvar isIRI = true;\n//RFC 3986\nvar UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nvar HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\nvar PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nvar ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nvar QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nvar VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nvar SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nvar UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nvar PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nvar NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nvar NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nvar NOT_HFVALUE = NOT_HFNAME;\nfunction decodeUnreserved(str) {\n    var decStr = pctDecChars(str);\n    return !decStr.match(UNRESERVED) ? str : decStr;\n}\nvar handler$4 = {\n    scheme: \"mailto\",\n    parse: function parse$$1(components, options) {\n        var mailtoComponents = components;\n        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n        mailtoComponents.path = undefined;\n        if (mailtoComponents.query) {\n            var unknownHeaders = false;\n            var headers = {};\n            var hfields = mailtoComponents.query.split(\"&\");\n            for (var x = 0, xl = hfields.length; x < xl; ++x) {\n                var hfield = hfields[x].split(\"=\");\n                switch (hfield[0]) {\n                    case \"to\":\n                        var toAddrs = hfield[1].split(\",\");\n                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {\n                            to.push(toAddrs[_x]);\n                        }\n                        break;\n                    case \"subject\":\n                        mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                        break;\n                    case \"body\":\n                        mailtoComponents.body = unescapeComponent(hfield[1], options);\n                        break;\n                    default:\n                        unknownHeaders = true;\n                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                        break;\n                }\n            }\n            if (unknownHeaders) mailtoComponents.headers = headers;\n        }\n        mailtoComponents.query = undefined;\n        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {\n            var addr = to[_x2].split(\"@\");\n            addr[0] = unescapeComponent(addr[0]);\n            if (!options.unicodeSupport) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                } catch (e) {\n                    mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            } else {\n                addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n            }\n            to[_x2] = addr.join(\"@\");\n        }\n        return mailtoComponents;\n    },\n    serialize: function serialize$$1(mailtoComponents, options) {\n        var components = mailtoComponents;\n        var to = toArray(mailtoComponents.to);\n        if (to) {\n            for (var x = 0, xl = to.length; x < xl; ++x) {\n                var toAddr = String(to[x]);\n                var atIdx = toAddr.lastIndexOf(\"@\");\n                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                var domain = toAddr.slice(atIdx + 1);\n                //convert IDN via punycode\n                try {\n                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                } catch (e) {\n                    components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n                to[x] = localPart + \"@\" + domain;\n            }\n            components.path = to.join(\",\");\n        }\n        var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n        if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n        if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n        var fields = [];\n        for (var name in headers) {\n            if (headers[name] !== O[name]) {\n                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n            }\n        }\n        if (fields.length) {\n            components.query = fields.join(\"&\");\n        }\n        return components;\n    }\n};\n\nvar URN_PARSE = /^([^\\:]+)\\:(.*)/;\n//RFC 2141\nvar handler$5 = {\n    scheme: \"urn\",\n    parse: function parse$$1(components, options) {\n        var matches = components.path && components.path.match(URN_PARSE);\n        var urnComponents = components;\n        if (matches) {\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n            var nid = matches[1].toLowerCase();\n            var nss = matches[2];\n            var urnScheme = scheme + \":\" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            urnComponents.nid = nid;\n            urnComponents.nss = nss;\n            urnComponents.path = undefined;\n            if (schemeHandler) {\n                urnComponents = schemeHandler.parse(urnComponents, options);\n            }\n        } else {\n            urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n        }\n        return urnComponents;\n    },\n    serialize: function serialize$$1(urnComponents, options) {\n        var scheme = options.scheme || urnComponents.scheme || \"urn\";\n        var nid = urnComponents.nid;\n        var urnScheme = scheme + \":\" + (options.nid || nid);\n        var schemeHandler = SCHEMES[urnScheme];\n        if (schemeHandler) {\n            urnComponents = schemeHandler.serialize(urnComponents, options);\n        }\n        var uriComponents = urnComponents;\n        var nss = urnComponents.nss;\n        uriComponents.path = (nid || options.nid) + \":\" + nss;\n        return uriComponents;\n    }\n};\n\nvar UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n//RFC 4122\nvar handler$6 = {\n    scheme: \"urn:uuid\",\n    parse: function parse(urnComponents, options) {\n        var uuidComponents = urnComponents;\n        uuidComponents.uuid = uuidComponents.nss;\n        uuidComponents.nss = undefined;\n        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n            uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n        }\n        return uuidComponents;\n    },\n    serialize: function serialize(uuidComponents, options) {\n        var urnComponents = uuidComponents;\n        //normalize UUID\n        urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n        return urnComponents;\n    }\n};\n\nSCHEMES[handler.scheme] = handler;\nSCHEMES[handler$1.scheme] = handler$1;\nSCHEMES[handler$2.scheme] = handler$2;\nSCHEMES[handler$3.scheme] = handler$3;\nSCHEMES[handler$4.scheme] = handler$4;\nSCHEMES[handler$5.scheme] = handler$5;\nSCHEMES[handler$6.scheme] = handler$6;\n\nexports.SCHEMES = SCHEMES;\nexports.pctEncChar = pctEncChar;\nexports.pctDecChars = pctDecChars;\nexports.parse = parse;\nexports.removeDotSegments = removeDotSegments;\nexports.serialize = serialize;\nexports.resolveComponents = resolveComponents;\nexports.resolve = resolve;\nexports.normalize = normalize;\nexports.equal = equal;\nexports.escapeComponent = escapeComponent;\nexports.unescapeComponent = unescapeComponent;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=uri.all.js.map\n","import { SCHEMES } from \"./uri\";\n\nimport http from \"./schemes/http\";\nSCHEMES[http.scheme] = http;\n\nimport https from \"./schemes/https\";\nSCHEMES[https.scheme] = https;\n\nimport ws from \"./schemes/ws\";\nSCHEMES[ws.scheme] = ws;\n\nimport wss from \"./schemes/wss\";\nSCHEMES[wss.scheme] = wss;\n\nimport mailto from \"./schemes/mailto\";\nSCHEMES[mailto.scheme] = mailto;\n\nimport urn from \"./schemes/urn\";\nSCHEMES[urn.scheme] = urn;\n\nimport uuid from \"./schemes/urn-uuid\";\nSCHEMES[uuid.scheme] = uuid;\n\nexport * from \"./uri\";\n","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { URNComponents } from \"./urn\";\nimport { SCHEMES } from \"../uri\";\n\nexport interface UUIDComponents extends URNComponents {\n\tuuid?: string;\n}\n\nconst UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\nconst UUID_PARSE = /^[0-9A-Fa-f\\-]{36}/;\n\n//RFC 4122\nconst handler:URISchemeHandler<UUIDComponents, URIOptions, URNComponents> = {\n\tscheme : \"urn:uuid\",\n\n\tparse : function (urnComponents:URNComponents, options:URIOptions):UUIDComponents {\n\t\tconst uuidComponents = urnComponents as UUIDComponents;\n\t\tuuidComponents.uuid = uuidComponents.nss;\n\t\tuuidComponents.nss = undefined;\n\n\t\tif (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n\t\t\tuuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n\t\t}\n\n\t\treturn uuidComponents;\n\t},\n\n\tserialize : function (uuidComponents:UUIDComponents, options:URIOptions):URNComponents {\n\t\tconst urnComponents = uuidComponents as URNComponents;\n\t\t//normalize UUID\n\t\turnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n\t\treturn urnComponents;\n\t},\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, SCHEMES } from \"../uri\";\n\nexport interface URNComponents extends URIComponents {\n\tnid?:string;\n\tnss?:string;\n}\n\nexport interface URNOptions extends URIOptions {\n\tnid?:string;\n}\n\nconst NID$ = \"(?:[0-9A-Za-z][0-9A-Za-z\\\\-]{1,31})\";\nconst PCT_ENCODED$ = \"(?:\\\\%[0-9A-Fa-f]{2})\";\nconst TRANS$$ = \"[0-9A-Za-z\\\\(\\\\)\\\\+\\\\,\\\\-\\\\.\\\\:\\\\=\\\\@\\\\;\\\\$\\\\_\\\\!\\\\*\\\\'\\\\/\\\\?\\\\#]\";\nconst NSS$ = \"(?:(?:\" + PCT_ENCODED$ + \"|\" + TRANS$$ + \")+)\";\nconst URN_SCHEME = new RegExp(\"^urn\\\\:(\" + NID$ + \")$\");\nconst URN_PATH = new RegExp(\"^(\" + NID$ + \")\\\\:(\" + NSS$ + \")$\");\nconst URN_PARSE = /^([^\\:]+)\\:(.*)/;\nconst URN_EXCLUDED = /[\\x00-\\x20\\\\\\\"\\&\\<\\>\\[\\]\\^\\`\\{\\|\\}\\~\\x7F-\\xFF]/g;\n\n//RFC 2141\nconst handler:URISchemeHandler<URNComponents,URNOptions> = {\n\tscheme : \"urn\",\n\n\tparse : function (components:URIComponents, options:URNOptions):URNComponents {\n\t\tconst matches = components.path && components.path.match(URN_PARSE);\n\t\tlet urnComponents = components as URNComponents;\n\n\t\tif (matches) {\n\t\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\t\tconst nid = matches[1].toLowerCase();\n\t\t\tconst nss = matches[2];\n\t\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\t\turnComponents.nid = nid;\n\t\t\turnComponents.nss = nss;\n\t\t\turnComponents.path = undefined;\n\n\t\t\tif (schemeHandler) {\n\t\t\t\turnComponents = schemeHandler.parse(urnComponents, options) as URNComponents;\n\t\t\t}\n\t\t} else {\n\t\t\turnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n\t\t}\n\n\t\treturn urnComponents;\n\t},\n\n\tserialize : function (urnComponents:URNComponents, options:URNOptions):URIComponents {\n\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\tconst nid = urnComponents.nid;\n\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\tif (schemeHandler) {\n\t\t\turnComponents = schemeHandler.serialize(urnComponents, options) as URNComponents;\n\t\t}\n\n\t\tconst uriComponents = urnComponents as URIComponents;\n\t\tconst nss = urnComponents.nss;\n\t\turiComponents.path = `${nid || options.nid}:${nss}`;\n\n\t\treturn uriComponents;\n\t},\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, pctDecChars, unescapeComponent } from \"../uri\";\nimport punycode from \"punycode\";\nimport { merge, subexp, toUpperCase, toArray } from \"../util\";\n\nexport interface MailtoHeaders {\n\t[hfname:string]:string\n}\n\nexport interface MailtoComponents extends URIComponents {\n\tto:Array<string>,\n\theaders?:MailtoHeaders,\n\tsubject?:string,\n\tbody?:string\n}\n\nconst O:MailtoHeaders = {};\nconst isIRI = true;\n\n//RFC 3986\nconst UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nconst HEXDIG$$ = \"[0-9A-Fa-f]\";  //case-insensitive\nconst PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$));  //expanded\n\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nconst ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nconst QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nconst VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nconst DOT_ATOM_TEXT$ = subexp(ATEXT$$ + \"+\" + subexp(\"\\\\.\" + ATEXT$$ + \"+\") + \"*\");\nconst QUOTED_PAIR$ = subexp(\"\\\\\\\\\" + VCHAR$$);\nconst QCONTENT$ = subexp(QTEXT$$ + \"|\" + QUOTED_PAIR$);\nconst QUOTED_STRING$ = subexp('\\\\\"' + QCONTENT$ + \"*\" + '\\\\\"');\n\n//RFC 6068\nconst DTEXT_NO_OBS$$ = \"[\\\\x21-\\\\x5A\\\\x5E-\\\\x7E]\";  //%d33-90 / %d94-126\nconst SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nconst QCHAR$ = subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$ + \"|\" + SOME_DELIMS$$);\nconst DOMAIN$ = subexp(DOT_ATOM_TEXT$ + \"|\" + \"\\\\[\" + DTEXT_NO_OBS$$ + \"*\" + \"\\\\]\");\nconst LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + \"|\" + QUOTED_STRING$);\nconst ADDR_SPEC$ = subexp(LOCAL_PART$ + \"\\\\@\" + DOMAIN$);\nconst TO$ = subexp(ADDR_SPEC$ + subexp(\"\\\\,\" + ADDR_SPEC$) + \"*\");\nconst HFNAME$ = subexp(QCHAR$ + \"*\");\nconst HFVALUE$ = HFNAME$;\nconst HFIELD$ = subexp(HFNAME$ + \"\\\\=\" + HFVALUE$);\nconst HFIELDS2$ = subexp(HFIELD$ + subexp(\"\\\\&\" + HFIELD$) + \"*\");\nconst HFIELDS$ = subexp(\"\\\\?\" + HFIELDS2$);\nconst MAILTO_URI = new RegExp(\"^mailto\\\\:\" + TO$ + \"?\" + HFIELDS$ + \"?$\");\n\nconst UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nconst PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nconst NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nconst NOT_DOMAIN = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", \"[\\\\[]\", DTEXT_NO_OBS$$, \"[\\\\]]\"), \"g\");\nconst NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nconst NOT_HFVALUE = NOT_HFNAME;\nconst TO = new RegExp(\"^\" + TO$ + \"$\");\nconst HFIELDS = new RegExp(\"^\" + HFIELDS2$ + \"$\");\n\nfunction decodeUnreserved(str:string):string {\n\tconst decStr = pctDecChars(str);\n\treturn (!decStr.match(UNRESERVED) ? str : decStr);\n}\n\nconst handler:URISchemeHandler<MailtoComponents> =  {\n\tscheme : \"mailto\",\n\n\tparse : function (components:URIComponents, options:URIOptions):MailtoComponents {\n\t\tconst mailtoComponents = components as MailtoComponents;\n\t\tconst to = mailtoComponents.to = (mailtoComponents.path ? mailtoComponents.path.split(\",\") : []);\n\t\tmailtoComponents.path = undefined;\n\n\t\tif (mailtoComponents.query) {\n\t\t\tlet unknownHeaders = false\n\t\t\tconst headers:MailtoHeaders = {};\n\t\t\tconst hfields = mailtoComponents.query.split(\"&\");\n\n\t\t\tfor (let x = 0, xl = hfields.length; x < xl; ++x) {\n\t\t\t\tconst hfield = hfields[x].split(\"=\");\n\n\t\t\t\tswitch (hfield[0]) {\n\t\t\t\t\tcase \"to\":\n\t\t\t\t\t\tconst toAddrs = hfield[1].split(\",\");\n\t\t\t\t\t\tfor (let x = 0, xl = toAddrs.length; x < xl; ++x) {\n\t\t\t\t\t\t\tto.push(toAddrs[x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"subject\":\n\t\t\t\t\t\tmailtoComponents.subject = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"body\":\n\t\t\t\t\t\tmailtoComponents.body = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tunknownHeaders = true;\n\t\t\t\t\t\theaders[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (unknownHeaders) mailtoComponents.headers = headers;\n\t\t}\n\n\t\tmailtoComponents.query = undefined;\n\n\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\tconst addr = to[x].split(\"@\");\n\n\t\t\taddr[0] = unescapeComponent(addr[0]);\n\n\t\t\tif (!options.unicodeSupport) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\taddr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tmailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr[1] = unescapeComponent(addr[1], options).toLowerCase();\n\t\t\t}\n\n\t\t\tto[x] = addr.join(\"@\");\n\t\t}\n\n\t\treturn mailtoComponents;\n\t},\n\n\tserialize : function (mailtoComponents:MailtoComponents, options:URIOptions):URIComponents {\n\t\tconst components = mailtoComponents as URIComponents;\n\t\tconst to = toArray(mailtoComponents.to);\n\t\tif (to) {\n\t\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\t\tconst toAddr = String(to[x]);\n\t\t\t\tconst atIdx = toAddr.lastIndexOf(\"@\");\n\t\t\t\tconst localPart = (toAddr.slice(0, atIdx)).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n\t\t\t\tlet domain = toAddr.slice(atIdx + 1);\n\n\t\t\t\t//convert IDN via punycode\n\t\t\t\ttry {\n\t\t\t\t\tdomain = (!options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t\t}\n\n\t\t\t\tto[x] = localPart + \"@\" + domain;\n\t\t\t}\n\n\t\t\tcomponents.path = to.join(\",\");\n\t\t}\n\n\t\tconst headers = mailtoComponents.headers = mailtoComponents.headers || {};\n\n\t\tif (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n\t\tif (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n\n\t\tconst fields = [];\n\t\tfor (const name in headers) {\n\t\t\tif (headers[name] !== O[name]) {\n\t\t\t\tfields.push(\n\t\t\t\t\tname.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) +\n\t\t\t\t\t\"=\" +\n\t\t\t\t\theaders[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (fields.length) {\n\t\t\tcomponents.query = fields.join(\"&\");\n\t\t}\n\n\t\treturn components;\n\t}\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport ws from \"./ws\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"wss\",\n\tdomainHost : ws.domainHost,\n\tparse : ws.parse,\n\tserialize : ws.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nexport interface WSComponents extends URIComponents {\n\tresourceName?: string;\n\tsecure?: boolean;\n}\n\nfunction isSecure(wsComponents:WSComponents):boolean {\n\treturn typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n\n//RFC 6455\nconst handler:URISchemeHandler = {\n\tscheme : \"ws\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):WSComponents {\n\t\tconst wsComponents = components as WSComponents;\n\n\t\t//indicate if the secure flag is set\n\t\twsComponents.secure = isSecure(wsComponents);\n\n\t\t//construct resouce name\n\t\twsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n\t\twsComponents.path = undefined;\n\t\twsComponents.query = undefined;\n\n\t\treturn wsComponents;\n\t},\n\n\tserialize : function (wsComponents:WSComponents, options:URIOptions):URIComponents {\n\t\t//normalize the default port\n\t\tif (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n\t\t\twsComponents.port = undefined;\n\t\t}\n\n\t\t//ensure scheme matches secure flag\n\t\tif (typeof wsComponents.secure === 'boolean') {\n\t\t\twsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws');\n\t\t\twsComponents.secure = undefined;\n\t\t}\n\n\t\t//reconstruct path from resource name\n\t\tif (wsComponents.resourceName) {\n\t\t\tconst [path, query] = wsComponents.resourceName.split('?');\n\t\t\twsComponents.path = (path && path !== '/' ? path : undefined);\n\t\t\twsComponents.query = query;\n\t\t\twsComponents.resourceName = undefined;\n\t\t}\n\n\t\t//forbid fragment component\n\t\twsComponents.fragment = undefined;\n\n\t\treturn wsComponents;\n\t}\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport http from \"./http\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"https\",\n\tdomainHost : http.domainHost,\n\tparse : http.parse,\n\tserialize : http.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"http\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\t//report missing host\n\t\tif (!components.host) {\n\t\t\tcomponents.error = components.error || \"HTTP URIs must have a host.\";\n\t\t}\n\n\t\treturn components;\n\t},\n\n\tserialize : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\tconst secure = String(components.scheme).toLowerCase() === \"https\";\n\n\t\t//normalize the default port\n\t\tif (components.port === (secure ? 443 : 80) || components.port === \"\") {\n\t\t\tcomponents.port = undefined;\n\t\t}\n\t\t\n\t\t//normalize the empty path\n\t\tif (!components.path) {\n\t\t\tcomponents.path = \"/\";\n\t\t}\n\n\t\t//NOTE: We do not parse query strings for HTTP URIs\n\t\t//as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n\t\t//and not the HTTP spec.\n\n\t\treturn components;\n\t}\n};\n\nexport default handler;","/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\n\nimport URI_PROTOCOL from \"./regexps-uri\";\nimport IRI_PROTOCOL from \"./regexps-iri\";\nimport punycode from \"punycode\";\nimport { toUpperCase, typeOf, assign } from \"./util\";\n\nexport interface URIComponents {\n\tscheme?:string;\n\tuserinfo?:string;\n\thost?:string;\n\tport?:number|string;\n\tpath?:string;\n\tquery?:string;\n\tfragment?:string;\n\treference?:string;\n\terror?:string;\n}\n\nexport interface URIOptions {\n\tscheme?:string;\n\treference?:string;\n\ttolerant?:boolean;\n\tabsolutePath?:boolean;\n\tiri?:boolean;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n}\n\nexport interface URISchemeHandler<Components extends URIComponents = URIComponents, Options extends URIOptions = URIOptions, ParentComponents extends URIComponents = URIComponents> {\n\tscheme:string;\n\tparse(components:ParentComponents, options:Options):Components;\n\tserialize(components:Components, options:Options):ParentComponents;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n\tabsolutePath?:boolean;\n}\n\nexport interface URIRegExps {\n\tNOT_SCHEME : RegExp,\n\tNOT_USERINFO : RegExp,\n\tNOT_HOST : RegExp,\n\tNOT_PATH : RegExp,\n\tNOT_PATH_NOSCHEME : RegExp,\n\tNOT_QUERY : RegExp,\n\tNOT_FRAGMENT : RegExp,\n\tESCAPE : RegExp,\n\tUNRESERVED : RegExp,\n\tOTHER_CHARS : RegExp,\n\tPCT_ENCODED : RegExp,\n\tIPV4ADDRESS : RegExp,\n\tIPV6ADDRESS : RegExp,\n}\n\nexport const SCHEMES:{[scheme:string]:URISchemeHandler} = {};\n\nexport function pctEncChar(chr:string):string {\n\tconst c = chr.charCodeAt(0);\n\tlet e:string;\n\n\tif (c < 16) e = \"%0\" + c.toString(16).toUpperCase();\n\telse if (c < 128) e = \"%\" + c.toString(16).toUpperCase();\n\telse if (c < 2048) e = \"%\" + ((c >> 6) | 192).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\telse e = \"%\" + ((c >> 12) | 224).toString(16).toUpperCase() + \"%\" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\n\treturn e;\n}\n\nexport function pctDecChars(str:string):string {\n\tlet newStr = \"\";\n\tlet i = 0;\n\tconst il = str.length;\n\n\twhile (i < il) {\n\t\tconst c = parseInt(str.substr(i + 1, 2), 16);\n\n\t\tif (c < 128) {\n\t\t\tnewStr += String.fromCharCode(c);\n\t\t\ti += 3;\n\t\t}\n\t\telse if (c >= 194 && c < 224) {\n\t\t\tif ((il - i) >= 6) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 6);\n\t\t\t}\n\t\t\ti += 6;\n\t\t}\n\t\telse if (c >= 224) {\n\t\t\tif ((il - i) >= 9) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tconst c3 = parseInt(str.substr(i + 7, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 9);\n\t\t\t}\n\t\t\ti += 9;\n\t\t}\n\t\telse {\n\t\t\tnewStr += str.substr(i, 3);\n\t\t\ti += 3;\n\t\t}\n\t}\n\n\treturn newStr;\n}\n\nfunction _normalizeComponentEncoding(components:URIComponents, protocol:URIRegExps) {\n\tfunction decodeUnreserved(str:string):string {\n\t\tconst decStr = pctDecChars(str);\n\t\treturn (!decStr.match(protocol.UNRESERVED) ? str : decStr);\n\t}\n\n\tif (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n\tif (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\n\treturn components;\n};\n\nfunction _stripLeadingZeros(str:string):string {\n\treturn str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\n\nfunction _normalizeIPv4(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV4ADDRESS) || [];\n\tconst [, address] = matches;\n\t\n\tif (address) {\n\t\treturn address.split(\".\").map(_stripLeadingZeros).join(\".\");\n\t} else {\n\t\treturn host;\n\t}\n}\n\nfunction _normalizeIPv6(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV6ADDRESS) || [];\n\tconst [, address, zone] = matches;\n\n\tif (address) {\n\t\tconst [last, first] = address.toLowerCase().split('::').reverse();\n\t\tconst firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n\t\tconst lastFields = last.split(\":\").map(_stripLeadingZeros);\n\t\tconst isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n\t\tconst fieldCount = isLastFieldIPv4Address ? 7 : 8;\n\t\tconst lastFieldsStart = lastFields.length - fieldCount;\n\t\tconst fields = Array<string>(fieldCount);\n\n\t\tfor (let x = 0; x < fieldCount; ++x) {\n\t\t\tfields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n\t\t}\n\n\t\tif (isLastFieldIPv4Address) {\n\t\t\tfields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n\t\t}\n\n\t\tconst allZeroFields = fields.reduce<Array<{index:number,length:number}>>((acc, field, index) => {\n\t\t\tif (!field || field === \"0\") {\n\t\t\t\tconst lastLongest = acc[acc.length - 1];\n\t\t\t\tif (lastLongest && lastLongest.index + lastLongest.length === index) {\n\t\t\t\t\tlastLongest.length++;\n\t\t\t\t} else {\n\t\t\t\t\tacc.push({ index, length : 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\n\t\tconst longestZeroFields = allZeroFields.sort((a, b) => b.length - a.length)[0];\n\n\t\tlet newHost:string;\n\t\tif (longestZeroFields && longestZeroFields.length > 1) {\n\t\t\tconst newFirst = fields.slice(0, longestZeroFields.index) ;\n\t\t\tconst newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n\t\t\tnewHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n\t\t} else {\n\t\t\tnewHost = fields.join(\":\");\n\t\t}\n\n\t\tif (zone) {\n\t\t\tnewHost += \"%\" + zone;\n\t\t}\n\n\t\treturn newHost;\n\t} else {\n\t\treturn host;\n\t}\n}\n\nconst URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nconst NO_MATCH_IS_UNDEFINED = (<RegExpMatchArray>(\"\").match(/(){0}/))[1] === undefined;\n\nexport function parse(uriString:string, options:URIOptions = {}):URIComponents {\n\tconst components:URIComponents = {};\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\n\tif (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n\n\tconst matches = uriString.match(URI_PARSE);\n\n\tif (matches) {\n\t\tif (NO_MATCH_IS_UNDEFINED) {\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1];\n\t\t\tcomponents.userinfo = matches[3];\n\t\t\tcomponents.host = matches[4];\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = matches[7];\n\t\t\tcomponents.fragment = matches[8];\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = matches[5];\n\t\t\t}\n\t\t} else {  //IE FIX for improper RegExp matching\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1] || undefined;\n\t\t\tcomponents.userinfo = (uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined);\n\t\t\tcomponents.host = (uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined);\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = (uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined);\n\t\t\tcomponents.fragment = (uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined);\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = (uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined);\n\t\t\t}\n\t\t}\n\n\t\tif (components.host) {\n\t\t\t//normalize IP hosts\n\t\t\tcomponents.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n\t\t}\n\n\t\t//determine reference type\n\t\tif (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n\t\t\tcomponents.reference = \"same-document\";\n\t\t} else if (components.scheme === undefined) {\n\t\t\tcomponents.reference = \"relative\";\n\t\t} else if (components.fragment === undefined) {\n\t\t\tcomponents.reference = \"absolute\";\n\t\t} else {\n\t\t\tcomponents.reference = \"uri\";\n\t\t}\n\n\t\t//check for reference errors\n\t\tif (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n\t\t\tcomponents.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n\t\t}\n\n\t\t//find scheme handler\n\t\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t\t//check if scheme can't handle IRIs\n\t\tif (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n\t\t\t//if host component is a domain name\n\t\t\tif (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\tcomponents.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//convert IRI -> URI\n\t\t\t_normalizeComponentEncoding(components, URI_PROTOCOL);\n\t\t} else {\n\t\t\t//normalize encodings\n\t\t\t_normalizeComponentEncoding(components, protocol);\n\t\t}\n\n\t\t//perform scheme specific parsing\n\t\tif (schemeHandler && schemeHandler.parse) {\n\t\t\tschemeHandler.parse(components, options);\n\t\t}\n\t} else {\n\t\tcomponents.error = components.error || \"URI can not be parsed.\";\n\t}\n\n\treturn components;\n};\n\nfunction _recomposeAuthority(components:URIComponents, options:URIOptions):string|undefined {\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\tif (components.userinfo !== undefined) {\n\t\turiTokens.push(components.userinfo);\n\t\turiTokens.push(\"@\");\n\t}\n\n\tif (components.host !== undefined) {\n\t\t//normalize IP hosts, add brackets and escape zone separator for IPv6\n\t\turiTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, (_, $1, $2) => \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\"));\n\t}\n\n\tif (typeof components.port === \"number\" || typeof components.port === \"string\") {\n\t\turiTokens.push(\":\");\n\t\turiTokens.push(String(components.port));\n\t}\n\n\treturn uriTokens.length ? uriTokens.join(\"\") : undefined;\n};\n\nconst RDS1 = /^\\.\\.?\\//;\nconst RDS2 = /^\\/\\.(\\/|$)/;\nconst RDS3 = /^\\/\\.\\.(\\/|$)/;\nconst RDS4 = /^\\.\\.?$/;\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n\nexport function removeDotSegments(input:string):string {\n\tconst output:Array<string> = [];\n\n\twhile (input.length) {\n\t\tif (input.match(RDS1)) {\n\t\t\tinput = input.replace(RDS1, \"\");\n\t\t} else if (input.match(RDS2)) {\n\t\t\tinput = input.replace(RDS2, \"/\");\n\t\t} else if (input.match(RDS3)) {\n\t\t\tinput = input.replace(RDS3, \"/\");\n\t\t\toutput.pop();\n\t\t} else if (input === \".\" || input === \"..\") {\n\t\t\tinput = \"\";\n\t\t} else {\n\t\t\tconst im = input.match(RDS5);\n\t\t\tif (im) {\n\t\t\t\tconst s = im[0];\n\t\t\t\tinput = input.slice(s.length);\n\t\t\t\toutput.push(s);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unexpected dot segment condition\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output.join(\"\");\n};\n\nexport function serialize(components:URIComponents, options:URIOptions = {}):string {\n\tconst protocol = (options.iri ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\t//find scheme handler\n\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t//perform scheme specific serialization\n\tif (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n\n\tif (components.host) {\n\t\t//if host component is an IPv6 address\n\t\tif (protocol.IPV6ADDRESS.test(components.host)) {\n\t\t\t//TODO: normalize IPv6 address as per RFC 5952\n\t\t}\n\n\t\t//if host component is a domain name\n\t\telse if (options.domainHost || (schemeHandler && schemeHandler.domainHost)) {\n\t\t\t//convert IDN via punycode\n\t\t\ttry {\n\t\t\t\tcomponents.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));\n\t\t\t} catch (e) {\n\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//normalize encoding\n\t_normalizeComponentEncoding(components, protocol);\n\n\tif (options.reference !== \"suffix\" && components.scheme) {\n\t\turiTokens.push(components.scheme);\n\t\turiTokens.push(\":\");\n\t}\n\n\tconst authority = _recomposeAuthority(components, options);\n\tif (authority !== undefined) {\n\t\tif (options.reference !== \"suffix\") {\n\t\t\turiTokens.push(\"//\");\n\t\t}\n\n\t\turiTokens.push(authority);\n\n\t\tif (components.path && components.path.charAt(0) !== \"/\") {\n\t\t\turiTokens.push(\"/\");\n\t\t}\n\t}\n\n\tif (components.path !== undefined) {\n\t\tlet s = components.path;\n\n\t\tif (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n\t\t\ts = removeDotSegments(s);\n\t\t}\n\n\t\tif (authority === undefined) {\n\t\t\ts = s.replace(/^\\/\\//, \"/%2F\");  //don't allow the path to start with \"//\"\n\t\t}\n\n\t\turiTokens.push(s);\n\t}\n\n\tif (components.query !== undefined) {\n\t\turiTokens.push(\"?\");\n\t\turiTokens.push(components.query);\n\t}\n\n\tif (components.fragment !== undefined) {\n\t\turiTokens.push(\"#\");\n\t\turiTokens.push(components.fragment);\n\t}\n\n\treturn uriTokens.join(\"\");  //merge tokens into a string\n};\n\nexport function resolveComponents(base:URIComponents, relative:URIComponents, options:URIOptions = {}, skipNormalization?:boolean):URIComponents {\n\tconst target:URIComponents = {};\n\n\tif (!skipNormalization) {\n\t\tbase = parse(serialize(base, options), options);  //normalize base components\n\t\trelative = parse(serialize(relative, options), options);  //normalize relative components\n\t}\n\toptions = options || {};\n\n\tif (!options.tolerant && relative.scheme) {\n\t\ttarget.scheme = relative.scheme;\n\t\t//target.authority = relative.authority;\n\t\ttarget.userinfo = relative.userinfo;\n\t\ttarget.host = relative.host;\n\t\ttarget.port = relative.port;\n\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\ttarget.query = relative.query;\n\t} else {\n\t\tif (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n\t\t\t//target.authority = relative.authority;\n\t\t\ttarget.userinfo = relative.userinfo;\n\t\t\ttarget.host = relative.host;\n\t\t\ttarget.port = relative.port;\n\t\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\t\ttarget.query = relative.query;\n\t\t} else {\n\t\t\tif (!relative.path) {\n\t\t\t\ttarget.path = base.path;\n\t\t\t\tif (relative.query !== undefined) {\n\t\t\t\t\ttarget.query = relative.query;\n\t\t\t\t} else {\n\t\t\t\t\ttarget.query = base.query;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (relative.path.charAt(0) === \"/\") {\n\t\t\t\t\ttarget.path = removeDotSegments(relative.path);\n\t\t\t\t} else {\n\t\t\t\t\tif ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n\t\t\t\t\t\ttarget.path = \"/\" + relative.path;\n\t\t\t\t\t} else if (!base.path) {\n\t\t\t\t\t\ttarget.path = relative.path;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n\t\t\t\t\t}\n\t\t\t\t\ttarget.path = removeDotSegments(target.path);\n\t\t\t\t}\n\t\t\t\ttarget.query = relative.query;\n\t\t\t}\n\t\t\t//target.authority = base.authority;\n\t\t\ttarget.userinfo = base.userinfo;\n\t\t\ttarget.host = base.host;\n\t\t\ttarget.port = base.port;\n\t\t}\n\t\ttarget.scheme = base.scheme;\n\t}\n\n\ttarget.fragment = relative.fragment;\n\n\treturn target;\n};\n\nexport function resolve(baseURI:string, relativeURI:string, options?:URIOptions):string {\n\tconst schemelessOptions = assign({ scheme : 'null' }, options);\n\treturn serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n};\n\nexport function normalize(uri:string, options?:URIOptions):string;\nexport function normalize(uri:URIComponents, options?:URIOptions):URIComponents;\nexport function normalize(uri:any, options?:URIOptions):any {\n\tif (typeof uri === \"string\") {\n\t\turi = serialize(parse(uri, options), options);\n\t} else if (typeOf(uri) === \"object\") {\n\t\turi = parse(serialize(<URIComponents>uri, options), options);\n\t}\n\n\treturn uri;\n};\n\nexport function equal(uriA:string, uriB:string, options?: URIOptions):boolean;\nexport function equal(uriA:URIComponents, uriB:URIComponents, options?:URIOptions):boolean;\nexport function equal(uriA:any, uriB:any, options?:URIOptions):boolean {\n\tif (typeof uriA === \"string\") {\n\t\turiA = serialize(parse(uriA, options), options);\n\t} else if (typeOf(uriA) === \"object\") {\n\t\turiA = serialize(<URIComponents>uriA, options);\n\t}\n\n\tif (typeof uriB === \"string\") {\n\t\turiB = serialize(parse(uriB, options), options);\n\t} else if (typeOf(uriB) === \"object\") {\n\t\turiB = serialize(<URIComponents>uriB, options);\n\t}\n\n\treturn uriA === uriB;\n};\n\nexport function escapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);\n};\n\nexport function unescapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);\n};\n","'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tconst parts = string.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tconst labels = string.split('.');\n\tconst encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = array => String.fromCodePoint(...array);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tlet oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tlet inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tlet basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue == n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.1.0',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nexport default punycode;\n","import { URIRegExps } from \"./uri\";\nimport { buildExps } from \"./regexps-uri\";\n\nexport default buildExps(true);\n","import { URIRegExps } from \"./uri\";\nimport { merge, subexp } from \"./util\";\n\nexport function buildExps(isIRI:boolean):URIRegExps {\n\tconst\n\t\tALPHA$$ = \"[A-Za-z]\",\n\t\tCR$ = \"[\\\\x0D]\",\n\t\tDIGIT$$ = \"[0-9]\",\n\t\tDQUOTE$$ = \"[\\\\x22]\",\n\t\tHEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),  //case-insensitive\n\t\tLF$$ = \"[\\\\x0A]\",\n\t\tSP$$ = \"[\\\\x20]\",\n\t\tPCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),  //expanded\n\t\tGEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n\t\tSUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n\t\tRESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n\t\tUCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",  //subset, excludes bidi control characters\n\t\tIPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",  //subset\n\t\tUNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n\t\tSCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n\t\tUSERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n\t\tDEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n\t\tDEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),  //relaxed parsing rules\n\t\tIPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n\t\tH16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n\t\tLS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n\t\tIPV6ADDRESS1$ = subexp(                                                            subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), //                           6( h16 \":\" ) ls32\n\t\tIPV6ADDRESS2$ = subexp(                                                 \"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), //                      \"::\" 5( h16 \":\" ) ls32\n\t\tIPV6ADDRESS3$ = subexp(subexp(                                 H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n\t\tIPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n\t\tIPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n\t\tIPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" +        H16$ + \"\\\\:\"          + LS32$), //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n\t\tIPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\"                                + LS32$), //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n\t\tIPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\"                                + H16$ ), //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n\t\tIPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"                                       ), //[ *6( h16 \":\" ) h16 ] \"::\"\n\t\tIPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n\t\tZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),  //RFC 6874\n\t\tIPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),  //RFC 6874\n\t\tIPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),  //RFC 6874, with relaxed parsing rules\n\t\tIPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n\t\tIP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),  //RFC 6874\n\t\tREG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n\t\tHOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n\t\tPORT$ = subexp(DIGIT$$ + \"*\"),\n\t\tAUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n\t\tPCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n\t\tSEGMENT$ = subexp(PCHAR$ + \"*\"),\n\t\tSEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n\t\tSEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n\t\tPATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n\t\tPATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),  //simplified\n\t\tPATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n\t\tPATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tQUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n\t\tFRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n\t\tHIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tURI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tRELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n\t\tRELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tURI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n\t\tABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n\n\t\tGENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tRELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n\t\tSAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tAUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\"\n\t;\n\n\treturn {\n\t\tNOT_SCHEME : new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n\t\tNOT_USERINFO : new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_HOST : new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH : new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH_NOSCHEME : new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_QUERY : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n\t\tNOT_FRAGMENT : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n\t\tESCAPE : new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tUNRESERVED : new RegExp(UNRESERVED$$, \"g\"),\n\t\tOTHER_CHARS : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n\t\tPCT_ENCODED : new RegExp(PCT_ENCODED$, \"g\"),\n\t\tIPV4ADDRESS : new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n\t\tIPV6ADDRESS : new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\")  //RFC 6874, with relaxed parsing rules\n\t};\n}\n\nexport default buildExps(false);\n","export function merge(...sets:Array<string>):string {\n\tif (sets.length > 1) {\n\t\tsets[0] = sets[0].slice(0, -1);\n\t\tconst xl = sets.length - 1;\n\t\tfor (let x = 1; x < xl; ++x) {\n\t\t\tsets[x] = sets[x].slice(1, -1);\n\t\t}\n\t\tsets[xl] = sets[xl].slice(1);\n\t\treturn sets.join('');\n\t} else {\n\t\treturn sets[0];\n\t}\n}\n\nexport function subexp(str:string):string {\n\treturn \"(?:\" + str + \")\";\n}\n\nexport function typeOf(o:any):string {\n\treturn o === undefined ? \"undefined\" : (o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase());\n}\n\nexport function toUpperCase(str:string):string {\n\treturn str.toUpperCase();\n}\n\nexport function toArray(obj:any):Array<any> {\n\treturn obj !== undefined && obj !== null ? (obj instanceof Array ? obj : (typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj))) : [];\n}\n\n\nexport function assign(target: object, source: any): any {\n\tconst obj = target as any;\n\tif (source) {\n\t\tfor (const key in source) {\n\t\t\tobj[key] = source[key];\n\t\t}\n\t}\n\treturn obj;\n}","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_1 = require(\"./core\");\nconst validation_1 = require(\"./validation\");\nconst applicator_1 = require(\"./applicator\");\nconst format_1 = require(\"./format\");\nconst metadata_1 = require(\"./metadata\");\nconst draft7Vocabularies = [\n    core_1.default,\n    validation_1.default,\n    (0, applicator_1.default)(),\n    format_1.default,\n    metadata_1.metadataVocabulary,\n    metadata_1.contentVocabulary,\n];\nexports.default = draft7Vocabularies;\n//# sourceMappingURL=draft7.js.map","import type {Vocabulary} from \"../types\"\nimport coreVocabulary from \"./core\"\nimport validationVocabulary from \"./validation\"\nimport getApplicatorVocabulary from \"./applicator\"\nimport formatVocabulary from \"./format\"\nimport {metadataVocabulary, contentVocabulary} from \"./metadata\"\n\nconst draft7Vocabularies: Vocabulary[] = [\n  coreVocabulary,\n  validationVocabulary,\n  getApplicatorVocabulary(),\n  formatVocabulary,\n  metadataVocabulary,\n  contentVocabulary,\n]\n\nexport default draft7Vocabularies\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst id_1 = require(\"./id\");\nconst ref_1 = require(\"./ref\");\nconst core = [\n    \"$schema\",\n    \"$id\",\n    \"$defs\",\n    \"$vocabulary\",\n    { keyword: \"$comment\" },\n    \"definitions\",\n    id_1.default,\n    ref_1.default,\n];\nexports.default = core;\n//# sourceMappingURL=index.js.map","import type {Vocabulary} from \"../../types\"\nimport idKeyword from \"./id\"\nimport refKeyword from \"./ref\"\n\nconst core: Vocabulary = [\n  \"$schema\",\n  \"$id\",\n  \"$defs\",\n  \"$vocabulary\",\n  {keyword: \"$comment\"},\n  \"definitions\",\n  idKeyword,\n  refKeyword,\n]\n\nexport default core\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst def = {\n    keyword: \"id\",\n    code() {\n        throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID');\n    },\n};\nexports.default = def;\n//# sourceMappingURL=id.js.map","import type {CodeKeywordDefinition} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"id\",\n  code() {\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID')\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self } = it;\n        const { root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId)\n            return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n        if (schOrEnv === undefined)\n            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n            return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n            if (env === root)\n                return callRef(cxt, validateName, env, env.$async);\n            const rootName = gen.scopeValue(\"root\", { ref: root });\n            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n            const v = getValidate(cxt, sch);\n            callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n            const schName = gen.scopeValue(\"schema\", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });\n            const valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({\n                schema: sch,\n                dataTypes: [],\n                schemaPath: codegen_1.nil,\n                topSchemaRef: schName,\n                errSchemaPath: $ref,\n            }, valid);\n            cxt.mergeEvaluated(schCxt);\n            cxt.ok(valid);\n        }\n    },\n};\nfunction getValidate(cxt, sch) {\n    const { gen } = cxt;\n    return sch.validate\n        ? gen.scopeValue(\"validate\", { ref: sch.validate })\n        : (0, codegen_1._) `${gen.scopeValue(\"wrapper\", { ref: sch })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n    const { gen, it } = cxt;\n    const { allErrors, schemaEnv: env, opts } = it;\n    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n    if ($async)\n        callAsyncRef();\n    else\n        callSyncRef();\n    function callAsyncRef() {\n        if (!env.$async)\n            throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(() => {\n            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n            if (!allErrors)\n                gen.assign(valid, true);\n        }, (e) => {\n            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n            addErrorsFrom(e);\n            if (!allErrors)\n                gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n    }\n    function callSyncRef() {\n        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n    }\n    function addErrorsFrom(source) {\n        const errs = (0, codegen_1._) `${source}.errors`;\n        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n    }\n    function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n            return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        // TODO refactor\n        if (it.props !== true) {\n            if (schEvaluated && !schEvaluated.dynamicProps) {\n                if (schEvaluated.props !== undefined) {\n                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n                }\n            }\n            else {\n                const props = gen.var(\"props\", (0, codegen_1._) `${source}.evaluated.props`);\n                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n            }\n        }\n        if (it.items !== true) {\n            if (schEvaluated && !schEvaluated.dynamicItems) {\n                if (schEvaluated.items !== undefined) {\n                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n                }\n            }\n            else {\n                const items = gen.var(\"items\", (0, codegen_1._) `${source}.evaluated.items`);\n                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n            }\n        }\n    }\n}\nexports.callRef = callRef;\nexports.default = def;\n//# sourceMappingURL=ref.js.map","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {callValidateCode} from \"../code\"\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {SchemaEnv, resolveRef} from \"../../compile\"\nimport {mergeEvaluated} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt): void {\n    const {gen, schema: $ref, it} = cxt\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\n    const {root} = env\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\n    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\n    return inlineRefSchema(schOrEnv)\n\n    function callRootRef(): void {\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\n      const rootName = gen.scopeValue(\"root\", {ref: root})\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\n    }\n\n    function callValidate(sch: SchemaEnv): void {\n      const v = getValidate(cxt, sch)\n      callRef(cxt, v, sch, sch.$async)\n    }\n\n    function inlineRefSchema(sch: AnySchema): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\n      )\n      const valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema(\n        {\n          schema: sch,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: $ref,\n        },\n        valid\n      )\n      cxt.mergeEvaluated(schCxt)\n      cxt.ok(valid)\n    }\n  },\n}\n\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\n  const {gen} = cxt\n  return sch.validate\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\n}\n\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\n  const {gen, it} = cxt\n  const {allErrors, schemaEnv: env, opts} = it\n  const passCxt = opts.passContext ? N.this : nil\n  if ($async) callAsyncRef()\n  else callSyncRef()\n\n  function callAsyncRef(): void {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\n    const valid = gen.let(\"valid\")\n    gen.try(\n      () => {\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\n        if (!allErrors) gen.assign(valid, true)\n      },\n      (e) => {\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _`${source}.errors`\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\n    gen.assign(N.errors, _`${N.vErrors}.length`)\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst limitNumber_1 = require(\"./limitNumber\");\nconst multipleOf_1 = require(\"./multipleOf\");\nconst limitLength_1 = require(\"./limitLength\");\nconst pattern_1 = require(\"./pattern\");\nconst limitProperties_1 = require(\"./limitProperties\");\nconst required_1 = require(\"./required\");\nconst limitItems_1 = require(\"./limitItems\");\nconst uniqueItems_1 = require(\"./uniqueItems\");\nconst const_1 = require(\"./const\");\nconst enum_1 = require(\"./enum\");\nconst validation = [\n    // number\n    limitNumber_1.default,\n    multipleOf_1.default,\n    // string\n    limitLength_1.default,\n    pattern_1.default,\n    // object\n    limitProperties_1.default,\n    required_1.default,\n    // array\n    limitItems_1.default,\n    uniqueItems_1.default,\n    // any\n    { keyword: \"type\", schemaType: [\"string\", \"array\"] },\n    { keyword: \"nullable\", schemaType: \"boolean\" },\n    const_1.default,\n    enum_1.default,\n];\nexports.default = validation;\n//# sourceMappingURL=index.js.map","import type {ErrorObject, Vocabulary} from \"../../types\"\nimport limitNumber, {LimitNumberError} from \"./limitNumber\"\nimport multipleOf, {MultipleOfError} from \"./multipleOf\"\nimport limitLength from \"./limitLength\"\nimport pattern, {PatternError} from \"./pattern\"\nimport limitProperties from \"./limitProperties\"\nimport required, {RequiredError} from \"./required\"\nimport limitItems from \"./limitItems\"\nimport uniqueItems, {UniqueItemsError} from \"./uniqueItems\"\nimport constKeyword, {ConstError} from \"./const\"\nimport enumKeyword, {EnumError} from \"./enum\"\n\nconst validation: Vocabulary = [\n  // number\n  limitNumber,\n  multipleOf,\n  // string\n  limitLength,\n  pattern,\n  // object\n  limitProperties,\n  required,\n  // array\n  limitItems,\n  uniqueItems,\n  // any\n  {keyword: \"type\", schemaType: [\"string\", \"array\"]},\n  {keyword: \"nullable\", schemaType: \"boolean\"},\n  constKeyword,\n  enumKeyword,\n]\n\nexport default validation\n\ntype LimitError = ErrorObject<\n  \"maxItems\" | \"minItems\" | \"minProperties\" | \"maxProperties\" | \"minLength\" | \"maxLength\",\n  {limit: number},\n  number | {$data: string}\n>\n\nexport type ValidationKeywordError =\n  | LimitError\n  | LimitNumberError\n  | MultipleOfError\n  | PatternError\n  | RequiredError\n  | UniqueItemsError\n  | ConstError\n  | EnumError\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    maximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    minimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    exclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    exclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: Object.keys(KWDs),\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitNumber.js.map","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators, Code} from \"../../compile/codegen\"\n\nconst ops = operators\n\ntype Kwd = \"maximum\" | \"minimum\" | \"exclusiveMaximum\" | \"exclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  maximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  minimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  exclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  exclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitNumberError = ErrorObject<\n  Kwd,\n  {limit: number; comparison: Comparison},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`must be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    cxt.fail$data(_`${data} ${KWDs[keyword as Kwd].fail} ${schemaCode} || isNaN(${data})`)\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"multipleOf\",\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, it } = cxt;\n        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n        const prec = it.opts.multipleOfPrecision;\n        const res = gen.let(\"res\");\n        const invalid = prec\n            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n            : (0, codegen_1._) `${res} !== parseInt(${res})`;\n        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=multipleOf.js.map","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type MultipleOfError = ErrorObject<\n  \"multipleOf\",\n  {multipleOf: number},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schemaCode, it} = cxt\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n    const prec = it.opts.multipleOfPrecision\n    const res = gen.let(\"res\")\n    const invalid = prec\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n      : _`${res} !== parseInt(${res})`\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst ucs2length_1 = require(\"../../runtime/ucs2length\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxLength\", \"minLength\"],\n    type: \"string\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode, it } = cxt;\n        const op = keyword === \"maxLength\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;\n        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitLength.js.map","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport ucs2length from \"../../runtime/ucs2length\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} characters`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxLength\", \"minLength\"],\n  type: \"string\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode, it} = cxt\n    const op = keyword === \"maxLength\" ? operators.GT : operators.LT\n    const len =\n      it.opts.unicode === false ? _`${data}.length` : _`${useFunc(cxt.gen, ucs2length)}(${data})`\n    cxt.fail$data(_`${len} ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nfunction ucs2length(str) {\n    const len = str.length;\n    let length = 0;\n    let pos = 0;\n    let value;\n    while (pos < len) {\n        length++;\n        value = str.charCodeAt(pos++);\n        if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n            // high surrogate, and there is a next character\n            value = str.charCodeAt(pos);\n            if ((value & 0xfc00) === 0xdc00)\n                pos++; // low surrogate\n        }\n    }\n    return length;\n}\nexports.default = ucs2length;\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default';\n//# sourceMappingURL=ucs2length.js.map","// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nexport default function ucs2length(str: string): number {\n  const len = str.length\n  let length = 0\n  let pos = 0\n  let value: number\n  while (pos < len) {\n    length++\n    value = str.charCodeAt(pos++)\n    if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos)\n      if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate\n    }\n  }\n  return length\n}\n\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default'\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"pattern\",\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { data, $data, schema, schemaCode, it } = cxt;\n        // TODO regexp should be wrapped in try/catchs\n        const u = it.opts.unicodeRegExp ? \"u\" : \"\";\n        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);\n        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=pattern.js.map","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {usePattern} from \"../code\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type PatternError = ErrorObject<\"pattern\", {pattern: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match pattern \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{pattern: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"pattern\",\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {data, $data, schema, schemaCode, it} = cxt\n    // TODO regexp should be wrapped in try/catchs\n    const u = it.opts.unicodeRegExp ? \"u\" : \"\"\n    const regExp = $data ? _`(new RegExp(${schemaCode}, ${u}))` : usePattern(cxt, schema)\n    cxt.fail$data(_`!${regExp}.test(${data})`)\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxProperties\", \"minProperties\"],\n    type: \"object\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxProperties\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitProperties.js.map","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} properties`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxProperties\", \"minProperties\"],\n  type: \"object\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxProperties\" ? operators.GT : operators.LT\n    cxt.fail$data(_`Object.keys(${data}).length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,\n    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,\n};\nconst def = {\n    keyword: \"required\",\n    type: \"object\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, schema, schemaCode, data, $data, it } = cxt;\n        const { opts } = it;\n        if (!$data && schema.length === 0)\n            return;\n        const useLoop = schema.length >= opts.loopRequired;\n        if (it.allErrors)\n            allErrorsMode();\n        else\n            exitOnErrorMode();\n        if (opts.strictRequired) {\n            const props = cxt.parentSchema.properties;\n            const { definedProperties } = cxt.it;\n            for (const requiredKey of schema) {\n                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n                    const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n                }\n            }\n        }\n        function allErrorsMode() {\n            if (useLoop || $data) {\n                cxt.block$data(codegen_1.nil, loopAllRequired);\n            }\n            else {\n                for (const prop of schema) {\n                    (0, code_1.checkReportMissingProp)(cxt, prop);\n                }\n            }\n        }\n        function exitOnErrorMode() {\n            const missing = gen.let(\"missing\");\n            if (useLoop || $data) {\n                const valid = gen.let(\"valid\", true);\n                cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n                cxt.ok(valid);\n            }\n            else {\n                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n                (0, code_1.reportMissingProp)(cxt, missing);\n                gen.else();\n            }\n        }\n        function loopAllRequired() {\n            gen.forOf(\"prop\", schemaCode, (prop) => {\n                cxt.setParams({ missingProperty: prop });\n                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n            });\n        }\n        function loopUntilMissing(missing, valid) {\n            cxt.setParams({ missingProperty: missing });\n            gen.forOf(missing, schemaCode, () => {\n                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n                gen.if((0, codegen_1.not)(valid), () => {\n                    cxt.error();\n                    gen.break();\n                });\n            }, codegen_1.nil);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=required.js.map","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxItems\", \"minItems\"],\n    type: \"array\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxItems\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitItems.js.map","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} items`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxItems\", \"minItems\"],\n  type: \"array\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxItems\" ? operators.GT : operators.LT\n    cxt.fail$data(_`${data}.length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dataType_1 = require(\"../../compile/validate/dataType\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,\n};\nconst def = {\n    keyword: \"uniqueItems\",\n    type: \"array\",\n    schemaType: \"boolean\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;\n        if (!$data && !schema)\n            return;\n        const valid = gen.let(\"valid\");\n        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);\n        cxt.ok(valid);\n        function validateUniqueItems() {\n            const i = gen.let(\"i\", (0, codegen_1._) `${data}.length`);\n            const j = gen.let(\"j\");\n            cxt.setParams({ i, j });\n            gen.assign(valid, true);\n            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n        }\n        function canOptimize() {\n            return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\");\n        }\n        function loopN(i, j) {\n            const item = gen.name(\"item\");\n            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n            const indices = gen.const(\"indices\", (0, codegen_1._) `{}`);\n            gen.for((0, codegen_1._) `;${i}--;`, () => {\n                gen.let(item, (0, codegen_1._) `${data}[${i}]`);\n                gen.if(wrongType, (0, codegen_1._) `continue`);\n                if (itemTypes.length > 1)\n                    gen.if((0, codegen_1._) `typeof ${item} == \"string\"`, (0, codegen_1._) `${item} += \"_\"`);\n                gen\n                    .if((0, codegen_1._) `typeof ${indices}[${item}] == \"number\"`, () => {\n                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);\n                    cxt.error();\n                    gen.assign(valid, false).break();\n                })\n                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);\n            });\n        }\n        function loopN2(i, j) {\n            const eql = (0, util_1.useFunc)(gen, equal_1.default);\n            const outer = gen.name(\"outer\");\n            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {\n                cxt.error();\n                gen.assign(valid, false).break(outer);\n            })));\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=uniqueItems.js.map","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// https://github.com/ajv-validator/ajv/issues/889\nconst equal = require(\"fast-deep-equal\");\nequal.code = 'require(\"ajv/dist/runtime/equal\").default';\nexports.default = equal;\n//# sourceMappingURL=equal.js.map","// https://github.com/ajv-validator/ajv/issues/889\nimport * as equal from \"fast-deep-equal\"\n\ntype Equal = typeof equal & {code: string}\n;(equal as Equal).code = 'require(\"ajv/dist/runtime/equal\").default'\n\nexport default equal as Equal\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to constant\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"const\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schemaCode, schema } = cxt;\n        if ($data || (schema && typeof schema == \"object\")) {\n            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);\n        }\n        else {\n            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=const.js.map","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type ConstError = ErrorObject<\"const\", {allowedValue: any}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to constant\",\n  params: ({schemaCode}) => _`{allowedValue: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"const\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schemaCode, schema} = cxt\n    if ($data || (schema && typeof schema == \"object\")) {\n      cxt.fail$data(_`!${useFunc(gen, equal)}(${data}, ${schemaCode})`)\n    } else {\n      cxt.fail(_`${schema} !== ${data}`)\n    }\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to one of the allowed values\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n            throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        let eql;\n        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let(\"valid\");\n            cxt.block$data(valid, loopEnum);\n        }\n        else {\n            /* istanbul ignore if */\n            if (!Array.isArray(schema))\n                throw new Error(\"ajv implementation error\");\n            const vSchema = gen.const(\"vSchema\", schemaCode);\n            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf(\"v\", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return typeof sch === \"object\" && sch !== null\n                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`\n                : (0, codegen_1._) `${data} === ${sch}`;\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=enum.js.map","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    let eql: Name | undefined\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\n\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst additionalItems_1 = require(\"./additionalItems\");\nconst prefixItems_1 = require(\"./prefixItems\");\nconst items_1 = require(\"./items\");\nconst items2020_1 = require(\"./items2020\");\nconst contains_1 = require(\"./contains\");\nconst dependencies_1 = require(\"./dependencies\");\nconst propertyNames_1 = require(\"./propertyNames\");\nconst additionalProperties_1 = require(\"./additionalProperties\");\nconst properties_1 = require(\"./properties\");\nconst patternProperties_1 = require(\"./patternProperties\");\nconst not_1 = require(\"./not\");\nconst anyOf_1 = require(\"./anyOf\");\nconst oneOf_1 = require(\"./oneOf\");\nconst allOf_1 = require(\"./allOf\");\nconst if_1 = require(\"./if\");\nconst thenElse_1 = require(\"./thenElse\");\nfunction getApplicator(draft2020 = false) {\n    const applicator = [\n        // any\n        not_1.default,\n        anyOf_1.default,\n        oneOf_1.default,\n        allOf_1.default,\n        if_1.default,\n        thenElse_1.default,\n        // object\n        propertyNames_1.default,\n        additionalProperties_1.default,\n        dependencies_1.default,\n        properties_1.default,\n        patternProperties_1.default,\n    ];\n    // array\n    if (draft2020)\n        applicator.push(prefixItems_1.default, items2020_1.default);\n    else\n        applicator.push(additionalItems_1.default, items_1.default);\n    applicator.push(contains_1.default);\n    return applicator;\n}\nexports.default = getApplicator;\n//# sourceMappingURL=index.js.map","import type {ErrorNoParams, Vocabulary} from \"../../types\"\nimport additionalItems, {AdditionalItemsError} from \"./additionalItems\"\nimport prefixItems from \"./prefixItems\"\nimport items from \"./items\"\nimport items2020, {ItemsError} from \"./items2020\"\nimport contains, {ContainsError} from \"./contains\"\nimport dependencies, {DependenciesError} from \"./dependencies\"\nimport propertyNames, {PropertyNamesError} from \"./propertyNames\"\nimport additionalProperties, {AdditionalPropertiesError} from \"./additionalProperties\"\nimport properties from \"./properties\"\nimport patternProperties from \"./patternProperties\"\nimport notKeyword, {NotKeywordError} from \"./not\"\nimport anyOf, {AnyOfError} from \"./anyOf\"\nimport oneOf, {OneOfError} from \"./oneOf\"\nimport allOf from \"./allOf\"\nimport ifKeyword, {IfKeywordError} from \"./if\"\nimport thenElse from \"./thenElse\"\n\nexport default function getApplicator(draft2020 = false): Vocabulary {\n  const applicator = [\n    // any\n    notKeyword,\n    anyOf,\n    oneOf,\n    allOf,\n    ifKeyword,\n    thenElse,\n    // object\n    propertyNames,\n    additionalProperties,\n    dependencies,\n    properties,\n    patternProperties,\n  ]\n  // array\n  if (draft2020) applicator.push(prefixItems, items2020)\n  else applicator.push(additionalItems, items)\n  applicator.push(contains)\n  return applicator\n}\n\nexport type ApplicatorKeywordError =\n  | ErrorNoParams<\"false schema\">\n  | AdditionalItemsError\n  | ItemsError\n  | ContainsError\n  | AdditionalPropertiesError\n  | DependenciesError\n  | IfKeywordError\n  | AnyOfError\n  | OneOfError\n  | NotKeywordError\n  | PropertyNamesError\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateAdditionalItems = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"additionalItems\",\n    type: \"array\",\n    schemaType: [\"boolean\", \"object\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { parentSchema, it } = cxt;\n        const { items } = parentSchema;\n        if (!Array.isArray(items)) {\n            (0, util_1.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n            return;\n        }\n        validateAdditionalItems(cxt, items);\n    },\n};\nfunction validateAdditionalItems(cxt, items) {\n    const { gen, schema, data, keyword, it } = cxt;\n    it.items = true;\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    if (schema === false) {\n        cxt.setParams({ len: items.length });\n        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);\n    }\n    else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.var(\"valid\", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var\n        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));\n        cxt.ok(valid);\n    }\n    function validateItems(valid) {\n        gen.forRange(\"i\", items.length, len, (i) => {\n            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);\n            if (!it.allErrors)\n                gen.if((0, codegen_1.not)(valid), () => gen.break());\n        });\n    }\n}\nexports.validateAdditionalItems = validateAdditionalItems;\nexports.default = def;\n//# sourceMappingURL=additionalItems.js.map","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type AdditionalItemsError = ErrorObject<\"additionalItems\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"additionalItems\" as const,\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {parentSchema, it} = cxt\n    const {items} = parentSchema\n    if (!Array.isArray(items)) {\n      checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas')\n      return\n    }\n    validateAdditionalItems(cxt, items)\n  },\n}\n\nexport function validateAdditionalItems(cxt: KeywordCxt, items: AnySchema[]): void {\n  const {gen, schema, data, keyword, it} = cxt\n  it.items = true\n  const len = gen.const(\"len\", _`${data}.length`)\n  if (schema === false) {\n    cxt.setParams({len: items.length})\n    cxt.pass(_`${len} <= ${items.length}`)\n  } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n    const valid = gen.var(\"valid\", _`${len} <= ${items.length}`) // TODO var\n    gen.if(not(valid), () => validateItems(valid))\n    cxt.ok(valid)\n  }\n\n  function validateItems(valid: Name): void {\n    gen.forRange(\"i\", items.length, len, (i) => {\n      cxt.subschema({keyword, dataProp: i, dataPropType: Type.Num}, valid)\n      if (!it.allErrors) gen.if(not(valid), () => gen.break())\n    })\n  }\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst items_1 = require(\"./items\");\nconst def = {\n    keyword: \"prefixItems\",\n    type: \"array\",\n    schemaType: [\"array\"],\n    before: \"uniqueItems\",\n    code: (cxt) => (0, items_1.validateTuple)(cxt, \"items\"),\n};\nexports.default = def;\n//# sourceMappingURL=prefixItems.js.map","import type {CodeKeywordDefinition} from \"../../types\"\nimport {validateTuple} from \"./items\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"prefixItems\",\n  type: \"array\",\n  schemaType: [\"array\"],\n  before: \"uniqueItems\",\n  code: (cxt) => validateTuple(cxt, \"items\"),\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateTuple = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"array\", \"boolean\"],\n    before: \"uniqueItems\",\n    code(cxt) {\n        const { schema, it } = cxt;\n        if (Array.isArray(schema))\n            return validateTuple(cxt, \"additionalItems\", schema);\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nfunction validateTuple(cxt, extraItems, schArr = cxt.schema) {\n    const { gen, parentSchema, data, keyword, it } = cxt;\n    checkStrictTuple(parentSchema);\n    if (it.opts.unevaluated && schArr.length && it.items !== true) {\n        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n    }\n    const valid = gen.name(\"valid\");\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    schArr.forEach((sch, i) => {\n        if ((0, util_1.alwaysValidSchema)(it, sch))\n            return;\n        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({\n            keyword,\n            schemaProp: i,\n            dataProp: i,\n        }, valid));\n        cxt.ok(valid);\n    });\n    function checkStrictTuple(sch) {\n        const { opts, errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n            const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n    }\n}\nexports.validateTuple = validateTuple;\nexports.default = def;\n//# sourceMappingURL=items.js.map","import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt: KeywordCxt) {\n    const {schema, it} = cxt\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    cxt.ok(validateArray(cxt))\n  },\n}\n\nexport function validateTuple(\n  cxt: KeywordCxt,\n  extraItems: string,\n  schArr: AnySchema[] = cxt.schema\n): void {\n  const {gen, parentSchema, data, keyword, it} = cxt\n  checkStrictTuple(parentSchema)\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\n  }\n  const valid = gen.name(\"valid\")\n  const len = gen.const(\"len\", _`${data}.length`)\n  schArr.forEach((sch: AnySchema, i: number) => {\n    if (alwaysValidSchema(it, sch)) return\n    gen.if(_`${len} > ${i}`, () =>\n      cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          dataProp: i,\n        },\n        valid\n      )\n    )\n    cxt.ok(valid)\n  })\n\n  function checkStrictTuple(sch: AnySchemaObject): void {\n    const {opts, errSchemaPath} = it\n    const l = schArr.length\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\n      checkStrictMode(it, msg, opts.strictTuples)\n    }\n  }\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst additionalItems_1 = require(\"./additionalItems\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { schema, parentSchema, it } = cxt;\n        const { prefixItems } = parentSchema;\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        if (prefixItems)\n            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);\n        else\n            cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nexports.default = def;\n//# sourceMappingURL=items2020.js.map","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\nimport {validateAdditionalItems} from \"./additionalItems\"\n\nexport type ItemsError = ErrorObject<\"items\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {schema, parentSchema, it} = cxt\n    const {prefixItems} = parentSchema\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    if (prefixItems) validateAdditionalItems(cxt, prefixItems)\n    else cxt.ok(validateArray(cxt))\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { min, max } }) => max === undefined\n        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`\n        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,\n    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,\n};\nconst def = {\n    keyword: \"contains\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        let min;\n        let max;\n        const { minContains, maxContains } = parentSchema;\n        if (it.opts.next) {\n            min = minContains === undefined ? 1 : minContains;\n            max = maxContains;\n        }\n        else {\n            min = 1;\n        }\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        cxt.setParams({ min, max });\n        if (max === undefined && min === 0) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n            return;\n        }\n        if (max !== undefined && min > max) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n            cxt.fail();\n            return;\n        }\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            let cond = (0, codegen_1._) `${len} >= ${min}`;\n            if (max !== undefined)\n                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;\n            cxt.pass(cond);\n            return;\n        }\n        it.items = true;\n        const valid = gen.name(\"valid\");\n        if (max === undefined && min === 1) {\n            validateItems(valid, () => gen.if(valid, () => gen.break()));\n        }\n        else if (min === 0) {\n            gen.let(valid, true);\n            if (max !== undefined)\n                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);\n        }\n        else {\n            gen.let(valid, false);\n            validateItemsWithCount();\n        }\n        cxt.result(valid, () => cxt.reset());\n        function validateItemsWithCount() {\n            const schValid = gen.name(\"_valid\");\n            const count = gen.let(\"count\", 0);\n            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n        }\n        function validateItems(_valid, block) {\n            gen.forRange(\"i\", 0, len, (i) => {\n                cxt.subschema({\n                    keyword: \"contains\",\n                    dataProp: i,\n                    dataPropType: util_1.Type.Num,\n                    compositeRule: true,\n                }, _valid);\n                block();\n            });\n        }\n        function checkLimits(count) {\n            gen.code((0, codegen_1._) `${count}++`);\n            if (max === undefined) {\n                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());\n            }\n            else {\n                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());\n                if (min === 1)\n                    gen.assign(valid, true);\n                else\n                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=contains.js.map","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nexports.error = {\n    message: ({ params: { property, depsCount, deps } }) => {\n        const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;\n    },\n    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n};\nconst def = {\n    keyword: \"dependencies\",\n    type: \"object\",\n    schemaType: \"object\",\n    error: exports.error,\n    code(cxt) {\n        const [propDeps, schDeps] = splitDependencies(cxt);\n        validatePropertyDeps(cxt, propDeps);\n        validateSchemaDeps(cxt, schDeps);\n    },\n};\nfunction splitDependencies({ schema }) {\n    const propertyDeps = {};\n    const schemaDeps = {};\n    for (const key in schema) {\n        if (key === \"__proto__\")\n            continue;\n        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n        deps[key] = schema[key];\n    }\n    return [propertyDeps, schemaDeps];\n}\nfunction validatePropertyDeps(cxt, propertyDeps = cxt.schema) {\n    const { gen, data, it } = cxt;\n    if (Object.keys(propertyDeps).length === 0)\n        return;\n    const missing = gen.let(\"missing\");\n    for (const prop in propertyDeps) {\n        const deps = propertyDeps[prop];\n        if (deps.length === 0)\n            continue;\n        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n        cxt.setParams({\n            property: prop,\n            depsCount: deps.length,\n            deps: deps.join(\", \"),\n        });\n        if (it.allErrors) {\n            gen.if(hasProperty, () => {\n                for (const depProp of deps) {\n                    (0, code_1.checkReportMissingProp)(cxt, depProp);\n                }\n            });\n        }\n        else {\n            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);\n            (0, code_1.reportMissingProp)(cxt, missing);\n            gen.else();\n        }\n    }\n}\nexports.validatePropertyDeps = validatePropertyDeps;\nfunction validateSchemaDeps(cxt, schemaDeps = cxt.schema) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    for (const prop in schemaDeps) {\n        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))\n            continue;\n        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {\n            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);\n            cxt.mergeValidEvaluated(schCxt, valid);\n        }, () => gen.var(valid, true) // TODO var\n        );\n        cxt.ok(valid);\n    }\n}\nexports.validateSchemaDeps = validateSchemaDeps;\nexports.default = def;\n//# sourceMappingURL=dependencies.js.map","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"property name must be valid\",\n    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,\n};\nconst def = {\n    keyword: \"propertyNames\",\n    type: \"object\",\n    schemaType: [\"object\", \"boolean\"],\n    error,\n    code(cxt) {\n        const { gen, schema, data, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const valid = gen.name(\"valid\");\n        gen.forIn(\"key\", data, (key) => {\n            cxt.setParams({ propertyName: key });\n            cxt.subschema({\n                keyword: \"propertyNames\",\n                data: key,\n                dataTypes: [\"string\"],\n                propertyName: key,\n                compositeRule: true,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), () => {\n                cxt.error(true);\n                if (!it.allErrors)\n                    gen.break();\n            });\n        });\n        cxt.ok(valid);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=propertyNames.js.map","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type PropertyNamesError = ErrorObject<\"propertyNames\", {propertyName: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: \"property name must be valid\",\n  params: ({params}) => _`{propertyName: ${params.propertyName}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"propertyNames\",\n  type: \"object\",\n  schemaType: [\"object\", \"boolean\"],\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, it} = cxt\n    if (alwaysValidSchema(it, schema)) return\n    const valid = gen.name(\"valid\")\n\n    gen.forIn(\"key\", data, (key) => {\n      cxt.setParams({propertyName: key})\n      cxt.subschema(\n        {\n          keyword: \"propertyNames\",\n          data: key,\n          dataTypes: [\"string\"],\n          propertyName: key,\n          compositeRule: true,\n        },\n        valid\n      )\n      gen.if(not(valid), () => {\n        cxt.error(true)\n        if (!it.allErrors) gen.break()\n      })\n    })\n\n    cxt.ok(valid)\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"must NOT have additional properties\",\n    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,\n};\nconst def = {\n    keyword: \"additionalProperties\",\n    type: [\"object\"],\n    schemaType: [\"boolean\", \"object\"],\n    allowUndefined: true,\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, errsCount, it } = cxt;\n        /* istanbul ignore if */\n        if (!errsCount)\n            throw new Error(\"ajv implementation error\");\n        const { allErrors, opts } = it;\n        it.props = true;\n        if (opts.removeAdditional !== \"all\" && (0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);\n        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);\n        checkAdditionalProperties();\n        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n        function checkAdditionalProperties() {\n            gen.forIn(\"key\", data, (key) => {\n                if (!props.length && !patProps.length)\n                    additionalPropertyCode(key);\n                else\n                    gen.if(isAdditional(key), () => additionalPropertyCode(key));\n            });\n        }\n        function isAdditional(key) {\n            let definedProp;\n            if (props.length > 8) {\n                // TODO maybe an option instead of hard-coded 8?\n                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, \"properties\");\n                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);\n            }\n            else if (props.length) {\n                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));\n            }\n            else {\n                definedProp = codegen_1.nil;\n            }\n            if (patProps.length) {\n                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));\n            }\n            return (0, codegen_1.not)(definedProp);\n        }\n        function deleteAdditional(key) {\n            gen.code((0, codegen_1._) `delete ${data}[${key}]`);\n        }\n        function additionalPropertyCode(key) {\n            if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n                deleteAdditional(key);\n                return;\n            }\n            if (schema === false) {\n                cxt.setParams({ additionalProperty: key });\n                cxt.error();\n                if (!allErrors)\n                    gen.break();\n                return;\n            }\n            if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n                const valid = gen.name(\"valid\");\n                if (opts.removeAdditional === \"failing\") {\n                    applyAdditionalSchema(key, valid, false);\n                    gen.if((0, codegen_1.not)(valid), () => {\n                        cxt.reset();\n                        deleteAdditional(key);\n                    });\n                }\n                else {\n                    applyAdditionalSchema(key, valid);\n                    if (!allErrors)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                }\n            }\n        }\n        function applyAdditionalSchema(key, valid, errors) {\n            const subschema = {\n                keyword: \"additionalProperties\",\n                dataProp: key,\n                dataPropType: util_1.Type.Str,\n            };\n            if (errors === false) {\n                Object.assign(subschema, {\n                    compositeRule: true,\n                    createErrors: false,\n                    allErrors: false,\n                });\n            }\n            cxt.subschema(subschema, valid);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=additionalProperties.js.map","import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst validate_1 = require(\"../../compile/validate\");\nconst code_1 = require(\"../code\");\nconst util_1 = require(\"../../compile/util\");\nconst additionalProperties_1 = require(\"./additionalProperties\");\nconst def = {\n    keyword: \"properties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, \"additionalProperties\"));\n        }\n        const allProps = (0, code_1.allSchemaProperties)(schema);\n        for (const prop of allProps) {\n            it.definedProperties.add(prop);\n        }\n        if (it.opts.unevaluated && allProps.length && it.props !== true) {\n            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);\n        }\n        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (properties.length === 0)\n            return;\n        const valid = gen.name(\"valid\");\n        for (const prop of properties) {\n            if (hasDefault(prop)) {\n                applyPropertySchema(prop);\n            }\n            else {\n                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));\n                applyPropertySchema(prop);\n                if (!it.allErrors)\n                    gen.else().var(valid, true);\n                gen.endIf();\n            }\n            cxt.it.definedProperties.add(prop);\n            cxt.ok(valid);\n        }\n        function hasDefault(prop) {\n            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;\n        }\n        function applyPropertySchema(prop) {\n            cxt.subschema({\n                keyword: \"properties\",\n                schemaProp: prop,\n                dataProp: prop,\n            }, valid);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=properties.js.map","import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst util_2 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 ||\n            (alwaysValidPatterns.length === patterns.length &&\n                (!it.opts.unevaluated || it.props === true))) {\n            return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns) {\n                if (checkProperties)\n                    checkMatchingProperties(pat);\n                if (it.allErrors) {\n                    validateProperties(pat);\n                }\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for (const prop in checkProperties) {\n                if (new RegExp(pat).test(prop)) {\n                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n                }\n            }\n        }\n        function validateProperties(pat) {\n            gen.forIn(\"key\", data, (key) => {\n                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n                    const alwaysValid = alwaysValidPatterns.includes(pat);\n                    if (!alwaysValid) {\n                        cxt.subschema({\n                            keyword: \"patternProperties\",\n                            schemaProp: pat,\n                            dataProp: key,\n                            dataPropType: util_2.Type.Str,\n                        }, valid);\n                    }\n                    if (it.opts.unevaluated && props !== true) {\n                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);\n                    }\n                    else if (!alwaysValid && !it.allErrors) {\n                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                        // or if all properties were evaluated (props === true)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                    }\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=patternProperties.js.map","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"not\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            cxt.fail();\n            return;\n        }\n        const valid = gen.name(\"valid\");\n        cxt.subschema({\n            keyword: \"not\",\n            compositeRule: true,\n            createErrors: false,\n            allErrors: false,\n        }, valid);\n        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());\n    },\n    error: { message: \"must NOT be valid\" },\n};\nexports.default = def;\n//# sourceMappingURL=not.js.map","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type NotKeywordError = ErrorNoParams<\"not\", AnySchema>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"not\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    if (alwaysValidSchema(it, schema)) {\n      cxt.fail()\n      return\n    }\n\n    const valid = gen.name(\"valid\")\n    cxt.subschema(\n      {\n        keyword: \"not\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false,\n      },\n      valid\n    )\n\n    cxt.failResult(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error()\n    )\n  },\n  error: {message: \"must NOT be valid\"},\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst def = {\n    keyword: \"anyOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    code: code_1.validateUnion,\n    error: { message: \"must match a schema in anyOf\" },\n};\nexports.default = def;\n//# sourceMappingURL=anyOf.js.map","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport {validateUnion} from \"../code\"\n\nexport type AnyOfError = ErrorNoParams<\"anyOf\", AnySchema[]>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"anyOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  code: validateUnion,\n  error: {message: \"must match a schema in anyOf\"},\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"must match exactly one schema in oneOf\",\n    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,\n};\nconst def = {\n    keyword: \"oneOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        if (it.opts.discriminator && parentSchema.discriminator)\n            return;\n        const schArr = schema;\n        const valid = gen.let(\"valid\", false);\n        const passing = gen.let(\"passing\", null);\n        const schValid = gen.name(\"_valid\");\n        cxt.setParams({ passing });\n        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n        gen.block(validateOneOf);\n        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n        function validateOneOf() {\n            schArr.forEach((sch, i) => {\n                let schCxt;\n                if ((0, util_1.alwaysValidSchema)(it, sch)) {\n                    gen.var(schValid, true);\n                }\n                else {\n                    schCxt = cxt.subschema({\n                        keyword: \"oneOf\",\n                        schemaProp: i,\n                        compositeRule: true,\n                    }, schValid);\n                }\n                if (i > 0) {\n                    gen\n                        .if((0, codegen_1._) `${schValid} && ${valid}`)\n                        .assign(valid, false)\n                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)\n                        .else();\n                }\n                gen.if(schValid, () => {\n                    gen.assign(valid, true);\n                    gen.assign(passing, i);\n                    if (schCxt)\n                        cxt.mergeEvaluated(schCxt, codegen_1.Name);\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=oneOf.js.map","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {SchemaCxt} from \"../../compile\"\n\nexport type OneOfError = ErrorObject<\n  \"oneOf\",\n  {passingSchemas: [number, number] | null},\n  AnySchema[]\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    if (it.opts.discriminator && parentSchema.discriminator) return\n    const schArr: AnySchema[] = schema\n    const valid = gen.let(\"valid\", false)\n    const passing = gen.let(\"passing\", null)\n    const schValid = gen.name(\"_valid\")\n    cxt.setParams({passing})\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf)\n\n    cxt.result(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error(true)\n    )\n\n    function validateOneOf(): void {\n      schArr.forEach((sch: AnySchema, i: number) => {\n        let schCxt: SchemaCxt | undefined\n        if (alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true)\n        } else {\n          schCxt = cxt.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: i,\n              compositeRule: true,\n            },\n            schValid\n          )\n        }\n\n        if (i > 0) {\n          gen\n            .if(_`${schValid} && ${valid}`)\n            .assign(valid, false)\n            .assign(passing, _`[${passing}, ${i}]`)\n            .else()\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true)\n          gen.assign(passing, i)\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"allOf\",\n    schemaType: \"array\",\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        const valid = gen.name(\"valid\");\n        schema.forEach((sch, i) => {\n            if ((0, util_1.alwaysValidSchema)(it, sch))\n                return;\n            const schCxt = cxt.subschema({ keyword: \"allOf\", schemaProp: i }, valid);\n            cxt.ok(valid);\n            cxt.mergeEvaluated(schCxt);\n        });\n    },\n};\nexports.default = def;\n//# sourceMappingURL=allOf.js.map","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"allOf\",\n  schemaType: \"array\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    const valid = gen.name(\"valid\")\n    schema.forEach((sch: AnySchema, i: number) => {\n      if (alwaysValidSchema(it, sch)) return\n      const schCxt = cxt.subschema({keyword: \"allOf\", schemaProp: i}, valid)\n      cxt.ok(valid)\n      cxt.mergeEvaluated(schCxt)\n    })\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params }) => (0, codegen_1.str) `must match \"${params.ifClause}\" schema`,\n    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,\n};\nconst def = {\n    keyword: \"if\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, parentSchema, it } = cxt;\n        if (parentSchema.then === undefined && parentSchema.else === undefined) {\n            (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n        }\n        const hasThen = hasSchema(it, \"then\");\n        const hasElse = hasSchema(it, \"else\");\n        if (!hasThen && !hasElse)\n            return;\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        validateIf();\n        cxt.reset();\n        if (hasThen && hasElse) {\n            const ifClause = gen.let(\"ifClause\");\n            cxt.setParams({ ifClause });\n            gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n        }\n        else if (hasThen) {\n            gen.if(schValid, validateClause(\"then\"));\n        }\n        else {\n            gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n        }\n        cxt.pass(valid, () => cxt.error(true));\n        function validateIf() {\n            const schCxt = cxt.subschema({\n                keyword: \"if\",\n                compositeRule: true,\n                createErrors: false,\n                allErrors: false,\n            }, schValid);\n            cxt.mergeEvaluated(schCxt);\n        }\n        function validateClause(keyword, ifClause) {\n            return () => {\n                const schCxt = cxt.subschema({ keyword }, schValid);\n                gen.assign(valid, schValid);\n                cxt.mergeValidEvaluated(schCxt, valid);\n                if (ifClause)\n                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);\n                else\n                    cxt.setParams({ ifClause: keyword });\n            };\n        }\n    },\n};\nfunction hasSchema(it, keyword) {\n    const schema = it.schema[keyword];\n    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\nexports.default = def;\n//# sourceMappingURL=if.js.map","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: [\"then\", \"else\"],\n    schemaType: [\"object\", \"boolean\"],\n    code({ keyword, parentSchema, it }) {\n        if (parentSchema.if === undefined)\n            (0, util_1.checkStrictMode)(it, `\"${keyword}\" without \"if\" is ignored`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=thenElse.js.map","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"then\", \"else\"],\n  schemaType: [\"object\", \"boolean\"],\n  code({keyword, parentSchema, it}: KeywordCxt) {\n    if (parentSchema.if === undefined) checkStrictMode(it, `\"${keyword}\" without \"if\" is ignored`)\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst format_1 = require(\"./format\");\nconst format = [format_1.default];\nexports.default = format;\n//# sourceMappingURL=index.js.map","import type {Vocabulary} from \"../../types\"\nimport formatKeyword from \"./format\"\n\nconst format: Vocabulary = [formatKeyword]\n\nexport default format\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match format \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"format\",\n    type: [\"number\", \"string\"],\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt, ruleType) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        const { opts, errSchemaPath, schemaEnv, self } = it;\n        if (!opts.validateFormats)\n            return;\n        if ($data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fDef = gen.const(\"fDef\", (0, codegen_1._) `${fmts}[${schemaCode}]`);\n            const fType = gen.let(\"fType\");\n            const format = gen.let(\"format\");\n            // TODO simplify\n            gen.if((0, codegen_1._) `typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || \"string\"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `\"string\"`).assign(format, fDef));\n            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n            function unknownFmt() {\n                if (opts.strictSchema === false)\n                    return codegen_1.nil;\n                return (0, codegen_1._) `${schemaCode} && !${format}`;\n            }\n            function invalidFmt() {\n                const callFormat = schemaEnv.$async\n                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n                    : (0, codegen_1._) `${format}(${data})`;\n                const validData = (0, codegen_1._) `(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n            }\n        }\n        function validateFormat() {\n            const formatDef = self.formats[schema];\n            if (!formatDef) {\n                unknownFormat();\n                return;\n            }\n            if (formatDef === true)\n                return;\n            const [fmtType, format, fmtRef] = getFormat(formatDef);\n            if (fmtType === ruleType)\n                cxt.pass(validCondition());\n            function unknownFormat() {\n                if (opts.strictSchema === false) {\n                    self.logger.warn(unknownMsg());\n                    return;\n                }\n                throw new Error(unknownMsg());\n                function unknownMsg() {\n                    return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n                }\n            }\n            function getFormat(fmtDef) {\n                const code = fmtDef instanceof RegExp\n                    ? (0, codegen_1.regexpCode)(fmtDef)\n                    : opts.code.formats\n                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`\n                        : undefined;\n                const fmt = gen.scopeValue(\"formats\", { key: schema, ref: fmtDef, code });\n                if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n                    return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];\n                }\n                return [\"string\", fmtDef, fmt];\n            }\n            function validCondition() {\n                if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n                    if (!schemaEnv.$async)\n                        throw new Error(\"async format in sync schema\");\n                    return (0, codegen_1._) `await ${fmtRef}(${data})`;\n                }\n                return typeof format == \"function\" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=format.js.map","import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.contentVocabulary = exports.metadataVocabulary = void 0;\nexports.metadataVocabulary = [\n    \"title\",\n    \"description\",\n    \"default\",\n    \"deprecated\",\n    \"readOnly\",\n    \"writeOnly\",\n    \"examples\",\n];\nexports.contentVocabulary = [\n    \"contentMediaType\",\n    \"contentEncoding\",\n    \"contentSchema\",\n];\n//# sourceMappingURL=metadata.js.map","import type {Vocabulary} from \"../types\"\n\nexport const metadataVocabulary: Vocabulary = [\n  \"title\",\n  \"description\",\n  \"default\",\n  \"deprecated\",\n  \"readOnly\",\n  \"writeOnly\",\n  \"examples\",\n]\n\nexport const contentVocabulary: Vocabulary = [\n  \"contentMediaType\",\n  \"contentEncoding\",\n  \"contentSchema\",\n]\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst types_1 = require(\"../discriminator/types\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag\n        ? `tag \"${tagName}\" must be string`\n        : `value of tag \"${tagName}\" must be in oneOf`,\n    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n};\nconst def = {\n    keyword: \"discriminator\",\n    type: \"object\",\n    schemaType: \"object\",\n    error,\n    code(cxt) {\n        const { gen, data, schema, parentSchema, it } = cxt;\n        const { oneOf } = parentSchema;\n        if (!it.opts.discriminator) {\n            throw new Error(\"discriminator: requires discriminator option\");\n        }\n        const tagName = schema.propertyName;\n        if (typeof tagName != \"string\")\n            throw new Error(\"discriminator: requires propertyName\");\n        if (schema.mapping)\n            throw new Error(\"discriminator: mapping is not supported\");\n        if (!oneOf)\n            throw new Error(\"discriminator: requires oneOf keyword\");\n        const valid = gen.let(\"valid\", false);\n        const tag = gen.const(\"tag\", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);\n        gen.if((0, codegen_1._) `typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));\n        cxt.ok(valid);\n        function validateMapping() {\n            const mapping = getMapping();\n            gen.if(false);\n            for (const tagValue in mapping) {\n                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);\n                gen.assign(valid, applyTagSchema(mapping[tagValue]));\n            }\n            gen.else();\n            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });\n            gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n            const _valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({ keyword: \"oneOf\", schemaProp }, _valid);\n            cxt.mergeEvaluated(schCxt, codegen_1.Name);\n            return _valid;\n        }\n        function getMapping() {\n            var _a;\n            const oneOfMapping = {};\n            const topRequired = hasRequired(parentSchema);\n            let tagRequired = true;\n            for (let i = 0; i < oneOf.length; i++) {\n                let sch = oneOf[i];\n                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);\n                    if (sch instanceof compile_1.SchemaEnv)\n                        sch = sch.schema;\n                }\n                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n                if (typeof propSch != \"object\") {\n                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n                }\n                tagRequired = tagRequired && (topRequired || hasRequired(sch));\n                addMappings(propSch, i);\n            }\n            if (!tagRequired)\n                throw new Error(`discriminator: \"${tagName}\" must be required`);\n            return oneOfMapping;\n            function hasRequired({ required }) {\n                return Array.isArray(required) && required.includes(tagName);\n            }\n            function addMappings(sch, i) {\n                if (sch.const) {\n                    addMapping(sch.const, i);\n                }\n                else if (sch.enum) {\n                    for (const tagValue of sch.enum) {\n                        addMapping(tagValue, i);\n                    }\n                }\n                else {\n                    throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n                }\n            }\n            function addMapping(tagValue, i) {\n                if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n                    throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n                }\n                oneOfMapping[tagValue] = i;\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=index.js.map","import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Name} from \"../../compile/codegen\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\nimport {resolveRef, SchemaEnv} from \"../../compile\"\nimport {schemaHasRulesButRef} from \"../../compile/util\"\n\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {discrError, tagName}}) =>\n    discrError === DiscrError.Tag\n      ? `tag \"${tagName}\" must be string`\n      : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({params: {discrError, tag, tagName}}) =>\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schema, parentSchema, it} = cxt\n    const {oneOf} = parentSchema\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\")\n    }\n    const tagName = schema.propertyName\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\")\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\n    const valid = gen.let(\"valid\", false)\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\n    gen.if(\n      _`typeof ${tag} == \"string\"`,\n      () => validateMapping(),\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\n    )\n    cxt.ok(valid)\n\n    function validateMapping(): void {\n      const mapping = getMapping()\n      gen.if(false)\n      for (const tagValue in mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\n      }\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp?: number): Name {\n      const _valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\n      cxt.mergeEvaluated(schCxt, Name)\n      return _valid\n    }\n\n    function getMapping(): {[T in string]?: number} {\n      const oneOfMapping: {[T in string]?: number} = {}\n      const topRequired = hasRequired(parentSchema)\n      let tagRequired = true\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i]\n        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {\n          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch?.$ref)\n          if (sch instanceof SchemaEnv) sch = sch.schema\n        }\n        const propSch = sch?.properties?.[tagName]\n        if (typeof propSch != \"object\") {\n          throw new Error(\n            `discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`\n          )\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\n        addMappings(propSch, i)\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\n      return oneOfMapping\n\n      function hasRequired({required}: AnySchemaObject): boolean {\n        return Array.isArray(required) && required.includes(tagName)\n      }\n\n      function addMappings(sch: AnySchemaObject, i: number): void {\n        if (sch.const) {\n          addMapping(sch.const, i)\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i)\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\n        }\n      }\n\n      function addMapping(tagValue: unknown, i: number): void {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\n        }\n        oneOfMapping[tagValue] = i\n      }\n    }\n  },\n}\n\nexport default def\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DiscrError = void 0;\nvar DiscrError;\n(function (DiscrError) {\n    DiscrError[\"Tag\"] = \"tag\";\n    DiscrError[\"Mapping\"] = \"mapping\";\n})(DiscrError = exports.DiscrError || (exports.DiscrError = {}));\n//# sourceMappingURL=types.js.map","import type {ErrorObject} from \"../../types\"\n\nexport enum DiscrError {\n  Tag = \"tag\",\n  Mapping = \"mapping\",\n}\n\nexport type DiscrErrorObj<E extends DiscrError> = ErrorObject<\n  \"discriminator\",\n  {error: E; tag: string; tagValue: unknown},\n  string\n>\n","{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"$id\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Core schema meta-schema\",\n  \"definitions\": {\n    \"schemaArray\": {\n      \"type\": \"array\",\n      \"minItems\": 1,\n      \"items\": {\"$ref\": \"#\"}\n    },\n    \"nonNegativeInteger\": {\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"nonNegativeIntegerDefault0\": {\n      \"allOf\": [{\"$ref\": \"#/definitions/nonNegativeInteger\"}, {\"default\": 0}]\n    },\n    \"simpleTypes\": {\n      \"enum\": [\"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\"]\n    },\n    \"stringArray\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"uniqueItems\": true,\n      \"default\": []\n    }\n  },\n  \"type\": [\"object\", \"boolean\"],\n  \"properties\": {\n    \"$id\": {\n      \"type\": \"string\",\n      \"format\": \"uri-reference\"\n    },\n    \"$schema\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"$ref\": {\n      \"type\": \"string\",\n      \"format\": \"uri-reference\"\n    },\n    \"$comment\": {\n      \"type\": \"string\"\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"default\": true,\n    \"readOnly\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"examples\": {\n      \"type\": \"array\",\n      \"items\": true\n    },\n    \"multipleOf\": {\n      \"type\": \"number\",\n      \"exclusiveMinimum\": 0\n    },\n    \"maximum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMaximum\": {\n      \"type\": \"number\"\n    },\n    \"minimum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMinimum\": {\n      \"type\": \"number\"\n    },\n    \"maxLength\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minLength\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"pattern\": {\n      \"type\": \"string\",\n      \"format\": \"regex\"\n    },\n    \"additionalItems\": {\"$ref\": \"#\"},\n    \"items\": {\n      \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/schemaArray\"}],\n      \"default\": true\n    },\n    \"maxItems\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minItems\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"uniqueItems\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"contains\": {\"$ref\": \"#\"},\n    \"maxProperties\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minProperties\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"required\": {\"$ref\": \"#/definitions/stringArray\"},\n    \"additionalProperties\": {\"$ref\": \"#\"},\n    \"definitions\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"default\": {}\n    },\n    \"properties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"default\": {}\n    },\n    \"patternProperties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"propertyNames\": {\"format\": \"regex\"},\n      \"default\": {}\n    },\n    \"dependencies\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/stringArray\"}]\n      }\n    },\n    \"propertyNames\": {\"$ref\": \"#\"},\n    \"const\": true,\n    \"enum\": {\n      \"type\": \"array\",\n      \"items\": true,\n      \"minItems\": 1,\n      \"uniqueItems\": true\n    },\n    \"type\": {\n      \"anyOf\": [\n        {\"$ref\": \"#/definitions/simpleTypes\"},\n        {\n          \"type\": \"array\",\n          \"items\": {\"$ref\": \"#/definitions/simpleTypes\"},\n          \"minItems\": 1,\n          \"uniqueItems\": true\n        }\n      ]\n    },\n    \"format\": {\"type\": \"string\"},\n    \"contentMediaType\": {\"type\": \"string\"},\n    \"contentEncoding\": {\"type\": \"string\"},\n    \"if\": {\"$ref\": \"#\"},\n    \"then\": {\"$ref\": \"#\"},\n    \"else\": {\"$ref\": \"#\"},\n    \"allOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"anyOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"oneOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"not\": {\"$ref\": \"#\"}\n  },\n  \"default\": true\n}\n","// import { SchemaValidator } from \"/bundle.js\";\n// TODO : import directly from the bundle.js file\n\nimport { SchemaValidator } from \"../../../lib/validator.js\";\nimport { ServiceProfileMetadata, ServiceProfile } from \"../../../lib/models.js\";\nimport { resolveDID } from \"../../../lib/did.js\";\nimport { fetchServiceProfile } from \"../util.js\";\nimport { createPublicPrivateKey } from \"../../../lib/crypto.js\";\nimport { ProfileSigner } from \"../../../lib/proof.js\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { multiHash } from \"../../../lib/crypto.js\";\n\nclass ProfileAPI {\n  baseUrl: string;\n\n  constructor(baseUrl: string) {\n    this.baseUrl = baseUrl;\n  }\n\n  async getProfile(id: string) {\n    const response = await fetch(`${this.baseUrl}/profiles/${id}`);\n    if (!response.ok) {\n      throw new Error(\"Failed to get profile\");\n    }\n    return response.json();\n  }\n\n  async validateProfile(profile: any): Promise<any> {\n    const resp = await fetch(`${this.baseUrl}/validate/profile`, {\n      method: \"POST\",\n      body: JSON.stringify(profile),\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    });\n    return resp.json();\n  }\n\n  async resolveDID(did: string): Promise<any> {\n    const response = await fetch(`${this.baseUrl}/resolve?did=${did}`);\n    if (!response.ok) {\n      throw new Error(\"Failed to resolve DID\");\n    }\n    return response.json();\n  }\n\n  async referenceProfile(url: string): Promise<any> {\n    const response = await fetch(`${this.baseUrl}/reference?url=${url}`);\n    if (!response.ok) {\n      throw new Error(\"Failed to reference profile\");\n    }\n    return response.json();\n  }\n\n  async storeProfile(profile: any): Promise<any> {\n    const response = await fetch(`${this.baseUrl}/profiles`, {\n      method: \"POST\",\n      body: JSON.stringify(profile),\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to store profile\");\n    }\n    return response.json();\n  }\n\n  async getProfiles(): Promise<any> {\n    const response = await fetch(`${this.baseUrl}/profiles`);\n    if (!response.ok) {\n      throw new Error(\"Failed to get profiles\");\n    }\n    return response.json();\n  }\n}\n\nconst profileAPI = new ProfileAPI(\"https://service-profile-api.andor.us/api\");\n\nconst validate = () => {\n  console.log(\"DOM content loaded\");\n  try {\n    if (!document) {\n      throw new Error(\"Document not found\");\n    }\n\n    const validateButton = document.getElementById(\"validateButton\");\n    if (!validateButton) {\n      throw new Error(\"Validate button not found\");\n    }\n\n    validateButton.addEventListener(\"click\", async () => {\n      console.log(\"validating\");\n      const profileData = document.getElementById(\"profileData\");\n      if (!profileData) {\n        document.getElementById(\"validationResult\")!.textContent =\n          \"Profile data not found\";\n      }\n\n      // @ts-ignore\n      const profileDataText = profileData.value;\n      try {\n        const profileData = JSON.parse(profileDataText);\n        const isValid = SchemaValidator.validate(profileData);\n        if (isValid) {\n          document.getElementById(\"validationResult\")!.textContent =\n            \"Profile is valid\";\n        } else {\n          document.getElementById(\"validationResult\")!.textContent =\n            \"Profile is not valid\";\n        }\n      } catch (error) {\n        document.getElementById(\"validationResult\")!.textContent =\n          \"Error parsing profile data: \" + error;\n      }\n    });\n  } catch (error) {\n    alert(\"Error: \" + error);\n  }\n};\n\nlet privateKey: Uint8Array;\nconst generateKeys = async () => {\n  const ppk = await createPublicPrivateKey();\n  privateKey = ppk.privateKey;\n  console.log(\"generated key: \", privateKey);\n};\n\nconst resolvers = () => {\n  console.log(\"adding resolvers\");\n  document.getElementById(\"resolveDID\")?.addEventListener(\"click\", async () => {\n    const resolvedDIDResult = document.getElementById(\"resolvedDIDResult\");\n    if (!resolvedDIDResult) {\n      alert(\"DOM Element not found for resolvedDIDResult\");\n    }\n\n    try {\n      const didInput = document.getElementById(\"didInput\");\n      if (!didInput) {\n        resolvedDIDResult!.textContent = \"DID input not found\";\n      }\n      // @ts-ignore\n      const did = didInput.value;\n      const doc = await resolveDID(did);\n      if (!doc || !doc.service || doc.service.length === 0) {\n        resolvedDIDResult!.textContent = \"DID not resolved\";\n      }\n\n      const profile = await fetchServiceProfile(\n        doc.service[0].serviceEndpoint.profile,\n      );\n\n      resolvedDIDResult!.textContent = JSON.stringify(profile, null, 2);\n      //const resolved = await profileAPI.resolveDID(did);\n    } catch (error) {\n      if (!resolvedDIDResult) {\n        alert(\"Error: \" + error);\n      }\n      resolvedDIDResult!.textContent = \"Error resolving DID: \" + error;\n    }\n  });\n};\n\nconst reference = () => {\n  console.log(\"adding resolvers\");\n  document\n    .getElementById(\"referenceProfile\")\n    ?.addEventListener(\"click\", async () => {\n      const resolvedProfileResult = document.getElementById(\n        \"referenceProfileResult\",\n      );\n      try {\n        const urlInput = document.getElementById(\"referenceProfileInput\");\n        if (!urlInput) {\n          resolvedProfileResult!.textContent = \"URL input not found\";\n          return;\n        }\n        console.log(urlInput);\n        // @ts-ignore\n        const url = urlInput.value;\n        const response = await fetch(url, { method: \"GET\" });\n        if (!response.ok) {\n          resolvedProfileResult!.textContent = \"Network response was not ok.\";\n          return;\n        }\n        const text = await response.text();\n        const buffer = Buffer.from(text);\n        const integrity = await multiHash(buffer);\n        const reference = {\n          integrity: integrity,\n          profile: url,\n          uri: \"<insert service uri here>\",\n        };\n        console.log(JSON.stringify(reference, null, 2));\n        //       const resolved = await profileAPI.referenceProfile(url);\n        if (!resolvedProfileResult) {\n          alert(\"Resolved DID: \" + JSON.stringify(reference, null, 2));\n        }\n        resolvedProfileResult!.textContent = JSON.stringify(reference, null, 2);\n      } catch (error) {\n        if (!resolvedProfileResult) {\n          alert(\"Error: \" + error);\n        }\n        resolvedProfileResult!.textContent = \"Error resolving DID: \" + error;\n      }\n    });\n};\n\nconst downloadKeyListener = () => {\n  const downloadKeyButton = document.getElementById(\"downloadPrivateKey\");\n  if (!downloadKeyButton) {\n    throw new Error(\"Download key button not found\");\n  }\n  downloadKeyButton.addEventListener(\"click\", async () => {\n    const blob = new Blob([privateKey], { type: \"text/plain\" });\n    const url = window.URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = \"privateKey.txt\";\n    a.click();\n  });\n};\n\nconst generateProfile = () => {\n  console.log(\"adding generateProfile\");\n  const form = document.getElementById(\"generateProfileForm\");\n  if (!form) {\n    throw new Error(\"Form not found\");\n  }\n  const profileResult = document.getElementById(\"generatedProfileResult\");\n  form.addEventListener(\"submit\", async (event: Event) => {\n    event.preventDefault();\n    const form = event.target as HTMLFormElement;\n    const formData = new FormData(form);\n    let meta: Partial<ServiceProfileMetadata> = {};\n    formData.forEach((value: FormDataEntryValue, key: string) => {\n      const metadataKey = key as keyof ServiceProfileMetadata;\n      if (key === \"supported_protocols\" || key === \"tags\") {\n        // @ts-ignore\n        meta[metadataKey] = value\n          .toString()\n          .split(\",\")\n          .map((tag) => tag.trim());\n      } else {\n        // @ts-ignore\n        meta[metadataKey] = value.toString();\n      }\n    });\n    meta.created = new Date().toISOString();\n    meta.id = uuidv4();\n    const signer = new ProfileSigner(privateKey);\n    const signedProfile = signer.signProfile({\n      metadata: meta,\n    } as ServiceProfile);\n    profileResult!.textContent = JSON.stringify(signedProfile, null, 2);\n  });\n};\n\nconst getProfiles = async () => {\n  const profiles = await profileAPI.getProfiles();\n  const selectElement = document.getElementById(\"profileSelect\");\n  if (!selectElement) {\n    throw new Error(\"Profile select not found\");\n  }\n  profiles.forEach((profile: any) => {\n    const option = document.createElement(\"option\");\n    option.value = profile.id;\n    option.text = profile.name;\n    selectElement.appendChild(option);\n  });\n\n  selectElement.addEventListener(\"change\", async () => {\n    // @ts-ignore\n    const profileId = selectElement.value;\n    console.log(\"Selected profile: \", profileId);\n    const profile = await profileAPI.getProfile(profileId);\n    const profileResult = document.getElementById(\"selectedProfileResult\");\n    if (!profileResult) {\n      throw new Error(\"Profile result not found\");\n    }\n    profileResult.textContent = JSON.stringify(profile, null, 2);\n  });\n};\n\nconst storeProfile = () => {\n  try {\n    if (!document) {\n      throw new Error(\"Document not found\");\n    }\n    const storeProfileButton = document.getElementById(\"storeProfileButton\");\n    if (!storeProfileButton) {\n      throw new Error(\"Store button not found\");\n    }\n\n    storeProfileButton.addEventListener(\"click\", async () => {\n      const storeProfileResult = document.getElementById(\"storeProfileResult\");\n      const profileData = document.getElementById(\"storeProfileData\");\n      if (!profileData) {\n        document.getElementById(\"storeProfileResult\")!.textContent =\n          \"Store Profile Result\";\n      }\n      // @ts-ignore\n      const profileDataText = profileData.value;\n      try {\n        console.log(\"Profile data: \", profileDataText);\n        const profileData = JSON.parse(profileDataText);\n        console.log(\"Storing profile: \", profileData);\n        const resp = await profileAPI.storeProfile(profileData);\n        storeProfileResult!.textContent = JSON.stringify(resp, null, 2);\n      } catch (error) {\n        storeProfileResult!.textContent =\n          \"Error parsing profile data: \" + error;\n      }\n    });\n  } catch (error) {\n    alert(\"Error: \" + error);\n  }\n};\n\nconst setup = () => {\n  generateKeys();\n  validate();\n  resolvers();\n  reference();\n  storeProfile();\n  getProfiles();\n  generateProfile();\n  downloadKeyListener();\n};\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  console.log(\"adding listeners\");\n  setup();\n});\n","import Ajv, { JSONSchemaType } from \"ajv\";\nimport { profileSchema } from \"../schemas/profile.js\";\n\nexport class SchemaValidator {\n  private static ajv = new Ajv();\n  private static validator = SchemaValidator.ajv.compile(profileSchema);\n\n  constructor() {}\n\n  static validate(data: any): boolean {\n    return SchemaValidator.validator(data);\n  }\n}\n","export const profileSchema = {\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"metadata\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\n          \"type\": \"string\",\n          \"description\": \"The decentralized identifier representing the profile in the DID format.\"\n        },\n        \"type\": {\n          \"type\": \"string\",\n          \"description\": \"A string indicating the type of the profile.\"\n        },\n        \"checksum\": {\n          \"type\": \"string\",\n          \"description\": \"A checksum value for data integrity validation.\"\n        },\n        \"created\": {\n          \"type\": \"string\",\n          \"description\": \"Timestamp indicating profile creation date.\"\n        },\n        \"name\": {\n          \"type\": \"string\",\n          \"description\": \"A human-readable name for the profile.\"\n        },\n        \"previous\": {\n          \"type\": \"string\",\n          \"description\": \"Reference to a previous version of the profile data.\"\n        },\n        \"description\": {\n          \"type\": \"string\",\n          \"description\": \"A detailed description of the profile.\"\n        },\n        \"short_description\": {\n          \"type\": \"string\",\n          \"description\": \"A concise description of the profile.\"\n        },\n        \"docs_url\": {\n          \"type\": \"string\",\n          \"description\": \"URL to documentation for the profile data.\"\n        },\n        \"version\": {\n          \"type\": \"string\",\n          \"description\": \"The version of the profile data, following semver.\"\n        },\n        \"tags\": {\n          \"type\": \"array\",\n          \"items\": { \"type\": \"string\" },\n          \"description\": \"Tags associated with the profile data.\"\n        }\n      },\n      \"required\": [\"id\"],\n      \"additionalProperties\": true\n    },\n    \"definitions\": {\n      \"type\": \"object\",\n      \"description\": \"Defines capabilities or services related to the profile data.\"\n    },\n    \"proof\": {\n      \"type\": \"object\",\n      \"description\": \"Information related to proofing the authenticity of the profile data.\"\n    }\n  },\n\n  \"required\": [\"metadata\"],\n  \"additionalProperties\": false\n}\n","import Ajv from \"ajv\";\nimport { serviceEndpointSchema } from \"../schemas/serviceEndpoint.js\";\n\ntype DIDDocument = {\n  service: Service[];\n};\n\ntype DIDResults = {\n  didDocument: DIDDocument;\n};\n\nexport const resolveDID = async (\n  did: string,\n  RESOLVER_API_URL = \"https://dev.uniresolver.io/1.0/identifiers/\",\n): Promise<DIDDocument> => {\n  try {\n    const url = `${RESOLVER_API_URL}${did}`;\n    const response = await fetch(url, {\n      method: \"GET\",\n    });\n    if (!response.ok) {\n      throw new Error(\n        `HTTP error! status: ${response.status}. ${response.statusText}}`,\n      );\n    }\n    const data = await response.json();\n    return (data as DIDResults).didDocument; // Assuming you want to return the response data\n  } catch (error) {\n    throw new Error(`Error resolving DID: ${error}`);\n  }\n};\n\ntype ServiceEndpoint = {\n  uri: string;\n  profile: string;\n  format: string;\n};\n\ntype Service = {\n  id: string;\n  type: string;\n  serviceEndpoint: ServiceEndpoint;\n};\n\nexport type ServiceValidationResult = {\n  id: string;\n  isValid: boolean;\n  errors: any;\n};\n\nexport const validateServiceProfiles = (\n  didDocument: any,\n): ServiceValidationResult[] => {\n  const ajv = new Ajv();\n  const validate = ajv.compile(serviceEndpointSchema);\n  const results: ServiceValidationResult[] = [];\n\n  if (didDocument.service && Array.isArray(didDocument.service)) {\n    didDocument.service.forEach((service: Service) => {\n      if (service.serviceEndpoint) {\n        const isValid = validate(service.serviceEndpoint);\n        results.push({\n          id: service.id,\n          isValid: isValid,\n          errors: validate.errors ? validate.errors : null,\n        });\n      }\n    });\n  }\n  return results;\n};\n","export const serviceEndpointSchema = {\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"uri\": {\n      \"type\": \"string\"\n    },\n    \"profile\": {\n      \"type\": \"string\"\n    },\n    \"integrity\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\"uri\", \"profile\"],\n  \"additionalProperties\": false\n}\n","import { ServiceProfile } from \"../../lib/models.js\";\n\nexport const fetchServiceProfile = async (\n  url: string,\n): Promise<ServiceProfile> => {\n  const response = await fetch(url, {\n    method: \"GET\",\n  });\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n  const data = await response.json();\n  return data as ServiceProfile;\n};\n","// import { createHash } from \"node:crypto\";\nimport { sha512 } from \"@noble/hashes/sha512\";\nimport { sha256 } from \"@noble/hashes/sha256\";\n\nimport * as ed from \"@noble/ed25519\";\ned.etc.sha512Sync = (...m) => sha512(ed.etc.concatBytes(...m));\n\nfunction encodeVarint(value: number): Uint8Array {\n  if (value < 0 || value > 127) {\n    throw new Error(\"This implementation supports values between 0 and 127.\");\n  }\n  return new Uint8Array([value]);\n}\n\n// 256 multihash\n// TODO: might recommend moving to CID instead of multihash\nexport const multiHash = async (data: Uint8Array) => {\n  const hash = sha256(data);\n  //  const hash = createHash(\"sha256\").update(data).digest();\n  const hashCode = encodeVarint(0x12);\n  const hashLength = encodeVarint(hash.length);\n  const multihash = new Uint8Array([...hashCode, ...hashLength, ...hash]);\n  return Array.from(multihash)\n    .map((b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n};\n\nexport const generateIntegrityValueFromBytes = async (data: Uint8Array) => {\n  return multiHash(data);\n};\n\nexport const generateIntegrityValueFromText = async (\n  text: string,\n): Promise<string> => {\n  const encoded = new TextEncoder().encode(text);\n  return generateIntegrityValueFromBytes(encoded);\n};\n\nexport const createPublicPrivateKey = async (): Promise<{\n  privateKey: Uint8Array;\n  publicKey: Uint8Array;\n}> => {\n  const privateKey = ed.utils.randomPrivateKey(); // Assuming this is how your library generates a random private key\n  const publicKey = await ed.getPublicKeyAsync(privateKey); // Assuming this is how your library gets the public key from the private key\n  return { privateKey, publicKey };\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;\nconst _sha2_js_1 = require(\"./_sha2.js\");\nconst _u64_js_1 = require(\"./_u64.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js_1.default.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _sha2_js_1.SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);\n            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);\n            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexports.SHA512 = SHA512;\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nexports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());\nexports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());\nexports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());\nexports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());\n//# sourceMappingURL=sha512.js.map","import { SHA2 } from './_sha2.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends SHA2<SHA512> {\n  // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n  // Also looks cleaner and easier to verify with spec.\n  // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x6a09e667 | 0;\n  Al = 0xf3bcc908 | 0;\n  Bh = 0xbb67ae85 | 0;\n  Bl = 0x84caa73b | 0;\n  Ch = 0x3c6ef372 | 0;\n  Cl = 0xfe94f82b | 0;\n  Dh = 0xa54ff53a | 0;\n  Dl = 0x5f1d36f1 | 0;\n  Eh = 0x510e527f | 0;\n  El = 0xade682d1 | 0;\n  Fh = 0x9b05688c | 0;\n  Fl = 0x2b3e6c1f | 0;\n  Gh = 0x1f83d9ab | 0;\n  Gl = 0xfb41bd6b | 0;\n  Hh = 0x5be0cd19 | 0;\n  Hl = 0x137e2179 | 0;\n\n  constructor() {\n    super(128, 64, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ) {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number) {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean() {\n    SHA512_W_H.fill(0);\n    SHA512_W_L.fill(0);\n  }\n  destroy() {\n    this.buffer.fill(0);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nclass SHA512_224 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x8c3d37c8 | 0;\n  Al = 0x19544da2 | 0;\n  Bh = 0x73e19966 | 0;\n  Bl = 0x89dcd4d6 | 0;\n  Ch = 0x1dfab7ae | 0;\n  Cl = 0x32ff9c82 | 0;\n  Dh = 0x679dd514 | 0;\n  Dl = 0x582f9fcf | 0;\n  Eh = 0x0f6d2b69 | 0;\n  El = 0x7bd44da8 | 0;\n  Fh = 0x77e36f73 | 0;\n  Fl = 0x04c48942 | 0;\n  Gh = 0x3f9d85a8 | 0;\n  Gl = 0x6a1d36c8 | 0;\n  Hh = 0x1112e6ad | 0;\n  Hl = 0x91d692a1 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\nclass SHA512_256 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x22312194 | 0;\n  Al = 0xfc2bf72c | 0;\n  Bh = 0x9f555fa3 | 0;\n  Bl = 0xc84c64c2 | 0;\n  Ch = 0x2393b86b | 0;\n  Cl = 0x6f53b151 | 0;\n  Dh = 0x96387719 | 0;\n  Dl = 0x5940eabd | 0;\n  Eh = 0x96283ee2 | 0;\n  El = 0xa88effe3 | 0;\n  Fh = 0xbe5e1e25 | 0;\n  Fl = 0x53863992 | 0;\n  Gh = 0x2b0199fc | 0;\n  Gl = 0x2c85b8aa | 0;\n  Hh = 0x0eb72ddc | 0;\n  Hl = 0x81c52ca2 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 32;\n  }\n}\n\nclass SHA384 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0xcbbb9d5d | 0;\n  Al = 0xc1059ed8 | 0;\n  Bh = 0x629a292a | 0;\n  Bl = 0x367cd507 | 0;\n  Ch = 0x9159015a | 0;\n  Cl = 0x3070dd17 | 0;\n  Dh = 0x152fecd8 | 0;\n  Dl = 0xf70e5939 | 0;\n  Eh = 0x67332667 | 0;\n  El = 0xffc00b31 | 0;\n  Fh = 0x8eb44a87 | 0;\n  Fl = 0x68581511 | 0;\n  Gh = 0xdb0c2e0d | 0;\n  Gl = 0x64f98fa7 | 0;\n  Hh = 0x47b5481d | 0;\n  Hl = 0xbefa4fa4 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 48;\n  }\n}\n\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SHA2 = void 0;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, _assert_js_1.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.SHA2 = SHA2;\n//# sourceMappingURL=_sha2.js.map","import { exists, output } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n// Polyfill for Safari 14\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n// Base SHA2 class (RFC 6234)\nexport abstract class SHA2<T extends SHA2<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    exists(this);\n    output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nexports.bool = bool;\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = { number, bool, bytes, hash, exists, output };\nexports.default = assert;\n//# sourceMappingURL=_assert.js.map","function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n\nfunction bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\n\n// copied from utils\nfunction isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\nfunction bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!isBytes(b)) throw new Error('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nfunction exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nexport { number, bool, bytes, hash, exists, output };\n\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n","\"use strict\";\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = require(\"@noble/hashes/crypto\");\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexports.rotr = rotr;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!exports.isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!isBytes(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\nexports.randomBytes = randomBytes;\n//# sourceMappingURL=utils.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!isBytes(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 } as const;\nfunction asciiToBase16(char: number): number | undefined {\n  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!isBytes(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    if (!isBytes(a)) throw new Error('Uint8Array expected');\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\nconst toStr = {}.toString;\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.crypto = void 0;\nexports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nexports.fromBig = fromBig;\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nexports.split = split;\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nexports.shrSH = shrSH;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.shrSL = shrSL;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nexports.rotrSH = rotrSH;\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.rotrSL = rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nexports.rotrBH = rotrBH;\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\nexports.rotrBL = rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nexports.rotr32H = rotr32H;\nconst rotr32L = (h, _l) => h;\nexports.rotr32L = rotr32L;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nexports.rotlSH = rotlSH;\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\nexports.rotlSL = rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nexports.rotlBH = rotlBH;\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\nexports.rotlBL = rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\nexports.add = add;\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexports.add3L = add3L;\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nexports.add3H = add3H;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexports.add4L = add4L;\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nexports.add4H = add4H;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexports.add5L = add5L;\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\nexports.add5H = add5H;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexports.default = u64;\n//# sourceMappingURL=_u64.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n: bigint, le = false) {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number) => h >>> s;\nconst shrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number) => l;\nconst rotr32L = (h: number, _l: number) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number) => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah: number, Al: number, Bh: number, Bl: number) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number) =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number) =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n// prettier-ignore\nconst u64 = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sha224 = exports.sha256 = void 0;\nconst _sha2_js_1 = require(\"./_sha2.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js_1.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());\nexports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n\n// Choice: a ? b : c\nconst Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = IV[0] | 0;\n  B = IV[1] | 0;\n  C = IV[2] | 0;\n  D = IV[3] | 0;\n  E = IV[4] | 0;\n  F = IV[5] | 0;\n  G = IV[6] | 0;\n  H = IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n","/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nconst P = 2n ** 255n - 19n; // ed25519 is twisted edwards curve\nconst N = 2n ** 252n + 27742317777372353535851937790883648493n; // curve's (group) order\nconst Gx = 0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an; // base point x\nconst Gy = 0x6666666666666666666666666666666666666666666666666666666666666658n; // base point y\nconst CURVE = {\n    a: -1n,\n    d: 37095705934669439343138083508754565189542113879843219016388785533085940283555n,\n    p: P, n: N, h: 8, Gx, Gy // field prime, curve (group) order, cofactor\n};\nconst err = (m = '') => { throw new Error(m); }; // error helper, messes-up stack trace\nconst str = (s) => typeof s === 'string'; // is string\nconst au8 = (a, l) => // is Uint8Array (of specific length)\n !(a instanceof Uint8Array) || (typeof l === 'number' && l > 0 && a.length !== l) ?\n    err('Uint8Array expected') : a;\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst toU8 = (a, len) => au8(str(a) ? h2b(a) : u8n(a), len); // norm(hex/u8a) to u8a\nconst mod = (a, b = P) => { let r = a % b; return r >= 0n ? r : b + r; }; // mod division\nconst isPoint = (p) => (p instanceof Point ? p : err('Point expected')); // is xyzt point\nlet Gpows = undefined; // precomputes for base point G\nclass Point {\n    constructor(ex, ey, ez, et) {\n        this.ex = ex;\n        this.ey = ey;\n        this.ez = ez;\n        this.et = et;\n    }\n    static fromAffine(p) { return new Point(p.x, p.y, 1n, mod(p.x * p.y)); }\n    static fromHex(hex, strict = true) {\n        const { d } = CURVE;\n        hex = toU8(hex, 32);\n        const normed = hex.slice(); // copy the array to not mess it up\n        normed[31] = hex[31] & ~0x80; // adjust first LE byte = last BE byte\n        const y = b2n_LE(normed); // decode as little-endian, convert to num\n        if (y === 0n) { // y=0 is valid, proceed\n        }\n        else {\n            if (strict && !(0n < y && y < P))\n                err('bad y coord 1'); // strict=true [1..P-1]\n            if (!strict && !(0n < y && y < 2n ** 256n))\n                err('bad y coord 2'); // strict=false [1..2^256-1]\n        }\n        const y2 = mod(y * y); // y²\n        const u = mod(y2 - 1n); // u=y²-1\n        const v = mod(d * y2 + 1n); // v=dy²+1\n        let { isValid, value: x } = uvRatio(u, v); // (uv³)(uv⁷)^(p-5)/8; square root\n        if (!isValid)\n            err('bad y coordinate 3'); // not square root: bad point\n        const isXOdd = (x & 1n) === 1n; // adjust sign of x coordinate\n        const isHeadOdd = (hex[31] & 0x80) !== 0;\n        if (isHeadOdd !== isXOdd)\n            x = mod(-x);\n        return new Point(x, y, 1n, mod(x * y)); // Z=1, T=xy\n    }\n    get x() { return this.toAffine().x; } // .x, .y will call expensive toAffine.\n    get y() { return this.toAffine().y; } // Should be used with care.\n    equals(other) {\n        const { ex: X1, ey: Y1, ez: Z1 } = this;\n        const { ex: X2, ey: Y2, ez: Z2 } = isPoint(other); // isPoint() checks class equality\n        const X1Z2 = mod(X1 * Z2), X2Z1 = mod(X2 * Z1);\n        const Y1Z2 = mod(Y1 * Z2), Y2Z1 = mod(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    is0() { return this.equals(I); }\n    negate() {\n        return new Point(mod(-this.ex), this.ey, this.ez, mod(-this.et));\n    }\n    double() {\n        const { ex: X1, ey: Y1, ez: Z1 } = this; // Cost: 4M + 4S + 1*a + 6add + 1*2\n        const { a } = CURVE; // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(2n * mod(Z1 * Z1));\n        const D = mod(a * A);\n        const x1y1 = X1 + Y1;\n        const E = mod(mod(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new Point(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this; // Cost: 8M + 1*k + 8add + 1*2.\n        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = isPoint(other); // doesn't check if other on-curve\n        const { a, d } = CURVE; // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3\n        const A = mod(X1 * X2);\n        const B = mod(Y1 * Y2);\n        const C = mod(T1 * d * T2);\n        const D = mod(Z1 * Z2);\n        const E = mod((X1 + Y1) * (X2 + Y2) - A - B);\n        const F = mod(D - C);\n        const G = mod(D + C);\n        const H = mod(B - a * A);\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new Point(X3, Y3, Z3, T3);\n    }\n    mul(n, safe = true) {\n        if (n === 0n)\n            return safe === true ? err('cannot multiply by 0') : I;\n        if (!(typeof n === 'bigint' && 0n < n && n < N))\n            err('invalid scalar, must be < L');\n        if (!safe && this.is0() || n === 1n)\n            return this; // safe=true bans 0. safe=false allows 0.\n        if (this.equals(G))\n            return wNAF(n).p; // use wNAF precomputes for base points\n        let p = I, f = G; // init result point & fake point\n        for (let d = this; n > 0n; d = d.double(), n >>= 1n) { // double-and-add ladder\n            if (n & 1n)\n                p = p.add(d); // if bit is present, add to point\n            else if (safe)\n                f = f.add(d); // if not, add to fake for timing safety\n        }\n        return p;\n    }\n    multiply(scalar) { return this.mul(scalar); } // Aliases for compatibilty\n    clearCofactor() { return this.mul(BigInt(CURVE.h), false); } // multiply by cofactor\n    isSmallOrder() { return this.clearCofactor().is0(); } // check if P is small order\n    isTorsionFree() {\n        let p = this.mul(N / 2n, false).double(); // ensures the point is not \"bad\".\n        if (N % 2n)\n            p = p.add(this); // P^(N+1)             // P*N == (P*(N/2))*2+P\n        return p.is0();\n    }\n    toAffine() {\n        const { ex: x, ey: y, ez: z } = this; // (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy)\n        if (this.is0())\n            return { x: 0n, y: 0n }; // fast-path for zero point\n        const iz = invert(z); // z^-1: invert z\n        if (mod(z * iz) !== 1n)\n            err('invalid inverse'); // (z * z^-1) must be 1, otherwise bad math\n        return { x: mod(x * iz), y: mod(y * iz) }; // x = x*z^-1; y = y*z^-1\n    }\n    toRawBytes() {\n        const { x, y } = this.toAffine(); // convert to affine 2d point\n        const b = n2b_32LE(y); // encode number to 32 bytes\n        b[31] |= x & 1n ? 0x80 : 0; // store sign in first LE byte\n        return b;\n    }\n    toHex() { return b2h(this.toRawBytes()); } // encode to hex string\n}\nPoint.BASE = new Point(Gx, Gy, 1n, mod(Gx * Gy)); // Generator / Base point\nPoint.ZERO = new Point(0n, 1n, 1n, 0n); // Identity / Zero point\nconst { BASE: G, ZERO: I } = Point; // Generator, identity points\nconst padh = (num, pad) => num.toString(16).padStart(pad, '0');\nconst b2h = (b) => Array.from(b).map(e => padh(e, 2)).join(''); // bytes to hex\nconst h2b = (hex) => {\n    const l = hex.length; // error if not string,\n    if (!str(hex) || l % 2)\n        err('hex invalid 1'); // or has odd length like 3, 5.\n    const arr = u8n(l / 2); // create result array\n    for (let i = 0; i < arr.length; i++) {\n        const j = i * 2;\n        const h = hex.slice(j, j + 2); // hexByte. slice is faster than substr\n        const b = Number.parseInt(h, 16); // byte, created from string part\n        if (Number.isNaN(b) || b < 0)\n            err('hex invalid 2'); // byte must be valid 0 <= byte < 256\n        arr[i] = b;\n    }\n    return arr;\n};\nconst n2b_32LE = (num) => h2b(padh(num, 32 * 2)).reverse(); // number to bytes LE\nconst b2n_LE = (b) => BigInt('0x' + b2h(u8n(au8(b)).reverse())); // bytes LE to num\nconst concatB = (...arrs) => {\n    const r = u8n(arrs.reduce((sum, a) => sum + au8(a).length, 0)); // create u8a of summed length\n    let pad = 0; // walk through each array,\n    arrs.forEach(a => { r.set(a, pad); pad += a.length; }); // ensure they have proper type\n    return r;\n};\nconst invert = (num, md = P) => {\n    if (num === 0n || md <= 0n)\n        err('no inverse n=' + num + ' mod=' + md); // no neg exponent for now\n    let a = mod(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;\n    while (a !== 0n) { // uses euclidean gcd algorithm\n        const q = b / a, r = b % a; // not constant-time\n        const m = x - u * q, n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    return b === 1n ? mod(x, md) : err('no inverse'); // b is gcd at this point\n};\nconst pow2 = (x, power) => {\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n};\nconst pow_2_252_3 = (x) => {\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n};\nconst RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n; // √-1\nconst uvRatio = (u, v) => {\n    const v3 = mod(v * v * v); // v³\n    const v7 = mod(v3 * v3 * v); // v⁷\n    const pow = pow_2_252_3(u * v7).pow_p_5_8; // (uv⁷)^(p-5)/8\n    let x = mod(u * v3 * pow); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = mod(v * x * x); // vx²\n    const root1 = x; // First root candidate\n    const root2 = mod(x * RM1); // Second root candidate; RM1 is √-1\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * RM1); // There is no valid root, vx² = -u√-1\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if ((mod(x) & 1n) === 1n)\n        x = mod(-x); // edIsNegative\n    return { isValid: useRoot1 || useRoot2, value: x };\n};\nconst modL_LE = (hash) => mod(b2n_LE(hash), N); // modulo L; but little-endian\nlet _shaS;\nconst sha512a = (...m) => etc.sha512Async(...m); // Async SHA512\nconst sha512s = (...m) => // Sync SHA512, not set by default\n typeof _shaS === 'function' ? _shaS(...m) : err('etc.sha512Sync not set');\nconst hash2extK = (hashed) => {\n    const head = hashed.slice(0, 32); // slice creates a copy, unlike subarray\n    head[0] &= 248; // Clamp bits: 0b1111_1000,\n    head[31] &= 127; // 0b0111_1111,\n    head[31] |= 64; // 0b0100_0000\n    const prefix = hashed.slice(32, 64); // private key \"prefix\"\n    const scalar = modL_LE(head); // modular division over curve order\n    const point = G.mul(scalar); // public key point\n    const pointBytes = point.toRawBytes(); // point serialized to Uint8Array\n    return { head, prefix, scalar, point, pointBytes };\n};\n// RFC8032 5.1.5; getPublicKey async, sync. Hash priv key and extract point.\nconst getExtendedPublicKeyAsync = (priv) => sha512a(toU8(priv, 32)).then(hash2extK);\nconst getExtendedPublicKey = (priv) => hash2extK(sha512s(toU8(priv, 32)));\nconst getPublicKeyAsync = (priv) => getExtendedPublicKeyAsync(priv).then(p => p.pointBytes);\nconst getPublicKey = (priv) => getExtendedPublicKey(priv).pointBytes;\nfunction hashFinish(asynchronous, res) {\n    if (asynchronous)\n        return sha512a(res.hashable).then(res.finish);\n    return res.finish(sha512s(res.hashable));\n}\nconst _sign = (e, rBytes, msg) => {\n    const { pointBytes: P, scalar: s } = e;\n    const r = modL_LE(rBytes); // r was created outside, reduce it modulo L\n    const R = G.mul(r).toRawBytes(); // R = [r]B\n    const hashable = concatB(R, P, msg); // dom2(F, C) || R || A || PH(M)\n    const finish = (hashed) => {\n        const S = mod(r + modL_LE(hashed) * s, N); // S = (r + k * s) mod L; 0 <= s < l\n        return au8(concatB(R, n2b_32LE(S)), 64); // 64-byte sig: 32b R.x + 32b LE(S)\n    };\n    return { hashable, finish };\n};\nconst signAsync = async (msg, privKey) => {\n    const m = toU8(msg); // RFC8032 5.1.6: sign msg with key async\n    const e = await getExtendedPublicKeyAsync(privKey); // pub,prfx\n    const rBytes = await sha512a(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return hashFinish(true, _sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\nconst sign = (msg, privKey) => {\n    const m = toU8(msg); // RFC8032 5.1.6: sign msg with key sync\n    const e = getExtendedPublicKey(privKey); // pub,prfx\n    const rBytes = sha512s(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return hashFinish(false, _sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\nconst _verify = (sig, msg, pub) => {\n    msg = toU8(msg); // Message hex str/Bytes\n    sig = toU8(sig, 64); // Signature hex str/Bytes, must be 64 bytes\n    const A = Point.fromHex(pub, false); // public key A decoded\n    const R = Point.fromHex(sig.slice(0, 32), false); // 0 <= R < 2^256: ZIP215 R can be >= P\n    const s = b2n_LE(sig.slice(32, 64)); // Decode second half as an integer S\n    const SB = G.mul(s, false); // in the range 0 <= s < L\n    const hashable = concatB(R.toRawBytes(), A.toRawBytes(), msg); // dom2(F, C) || R || A || PH(M)\n    const finish = (hashed) => {\n        const k = modL_LE(hashed); // decode in little-endian, modulo L\n        const RkA = R.add(A.mul(k, false)); // [8]R + [8][k]A'\n        return RkA.add(SB.negate()).clearCofactor().is0(); // [8][S]B = [8]R + [8][k]A'\n    };\n    return { hashable, finish };\n};\n// RFC8032 5.1.7: verification async, sync\nconst verifyAsync = async (s, m, p) => hashFinish(true, _verify(s, m, p));\nconst verify = (s, m, p) => hashFinish(false, _verify(s, m, p));\nconst cr = () => // We support: 1) browsers 2) node.js 19+\n typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\nconst etc = {\n    bytesToHex: b2h, hexToBytes: h2b, concatBytes: concatB,\n    mod, invert,\n    randomBytes: (len) => {\n        const crypto = cr(); // Can be shimmed in node.js <= 18 to prevent error:\n        // import { webcrypto } from 'node:crypto';\n        // if (!globalThis.crypto) globalThis.crypto = webcrypto;\n        if (!crypto)\n            err('crypto.getRandomValues must be defined');\n        return crypto.getRandomValues(u8n(len));\n    },\n    sha512Async: async (...messages) => {\n        const crypto = cr();\n        if (!crypto)\n            err('crypto.subtle or etc.sha512Async must be defined');\n        const m = concatB(...messages);\n        return u8n(await crypto.subtle.digest('SHA-512', m.buffer));\n    },\n    sha512Sync: undefined, // Actual logic below\n};\nObject.defineProperties(etc, { sha512Sync: {\n        configurable: false, get() { return _shaS; }, set(f) { if (!_shaS)\n            _shaS = f; },\n    } });\nconst utils = {\n    getExtendedPublicKeyAsync, getExtendedPublicKey,\n    randomPrivateKey: () => etc.randomBytes(32),\n    precompute(w = 8, p = G) { p.multiply(3n); return p; }, // no-op\n};\nconst W = 8; // Precomputes-related code. W = window size\nconst precompute = () => {\n    const points = []; // 10x sign(), 2x verify(). To achieve this,\n    const windows = 256 / W + 1; // app needs to spend 40ms+ to calculate\n    let p = G, b = p; // a lot of points related to base point G.\n    for (let w = 0; w < windows; w++) { // Points are stored in array and used\n        b = p; // any time Gx multiplication is done.\n        points.push(b); // They consume 16-32 MiB of RAM.\n        for (let i = 1; i < 2 ** (W - 1); i++) {\n            b = b.add(p);\n            points.push(b);\n        }\n        p = b.double(); // Precomputes don't speed-up getSharedKey,\n    } // which multiplies user point by scalar,\n    return points; // when precomputes are using base point\n};\nconst wNAF = (n) => {\n    // Compared to other point mult methods,\n    const comp = Gpows || (Gpows = precompute()); // stores 2x less points using subtraction\n    const neg = (cnd, p) => { let n = p.negate(); return cnd ? n : p; }; // negate\n    let p = I, f = G; // f must be G, or could become I in the end\n    const windows = 1 + 256 / W; // W=8 17 windows\n    const wsize = 2 ** (W - 1); // W=8 128 window size\n    const mask = BigInt(2 ** W - 1); // W=8 will create mask 0b11111111\n    const maxNum = 2 ** W; // W=8 256\n    const shiftBy = BigInt(W); // W=8 8\n    for (let w = 0; w < windows; w++) {\n        const off = w * wsize;\n        let wbits = Number(n & mask); // extract W bits.\n        n >>= shiftBy; // shift number by W bits.\n        if (wbits > wsize) {\n            wbits -= maxNum;\n            n += 1n;\n        } // split if bits > max: +224 => 256-32\n        const off1 = off, off2 = off + Math.abs(wbits) - 1; // offsets, evaluate both\n        const cnd1 = w % 2 !== 0, cnd2 = wbits < 0; // conditions, evaluate both\n        if (wbits === 0) {\n            f = f.add(neg(cnd1, comp[off1])); // bits are 0: add garbage to fake point\n        }\n        else { //          ^ can't add off2, off2 = I\n            p = p.add(neg(cnd2, comp[off2])); // bits are 1: add to result point\n        }\n    }\n    return { p, f }; // return both real and fake points for JIT\n}; // !! you can disable precomputes by commenting-out call of the wNAF() inside Point#mul()\nexport { getPublicKey, getPublicKeyAsync, sign, verify, // Remove the export to easily use in REPL\nsignAsync, verifyAsync, CURVE, etc, utils, Point as ExtendedPoint }; // envs like browser console\n","import { ServiceProfileMetadata, ServiceProfile } from \"../lib/models.js\";\nimport * as ed from \"@noble/ed25519\";\n\nimport { sha512 } from \"@noble/hashes/sha512\";\ned.etc.sha512Sync = (...m) => sha512(ed.etc.concatBytes(...m));\n\ntype Proof = {\n  type: string;\n  created: string;\n  proofValue: string;\n  verificationMethod: string;\n};\n\nexport class ProfileSigner {\n  private privKey: Uint8Array;\n\n  constructor(privKey: Uint8Array) {\n    this.privKey = privKey;\n  }\n\n  generateProof(metadata: ServiceProfileMetadata): Proof {\n    const rawMessage = JSON.stringify(metadata);\n    const message = Buffer.from(rawMessage, \"utf-8\");\n    const signature = ed.sign(message, this.privKey);\n    return {\n      type: \"Ed25519Signature2018\",\n      created: new Date().toISOString(),\n      proofValue: Buffer.from(signature).toString(\"base64\"),\n      verificationMethod: `did:example:123#key1`,\n    };\n  }\n\n  signProfile(profile: ServiceProfile): ServiceProfile {\n    const metadata = profile.metadata;\n    const proof = this.generateProof(metadata);\n    return {\n      metadata: metadata,\n      proof: proof,\n    } as ServiceProfile;\n  }\n}\n\nexport const verifyServiceProfileProof = (\n  proof: Proof,\n  metadata: ServiceProfileMetadata,\n  publicKey: Uint8Array,\n): boolean => {\n  const rawMessage = JSON.stringify(metadata);\n  const sigH = Uint8Array.from(Buffer.from(proof.proofValue, \"base64\"));\n  const msgk = Uint8Array.from(Buffer.from(rawMessage, \"utf8\"));\n  const isValid = ed.verify(sigH, msgk, publicKey);\n  return isValid;\n};\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;"],"names":["$09057b02a7b5c89d$var$_shaS","$568f4ee4022ba00e$var$getRandomValues","$2fa42e15b9a85232$var$privateKey","$09057b02a7b5c89d$var$Gpows","a","$eeb0961446aae8e3$export$d622b2ad8d90c771","$eeb0961446aae8e3$export$6100ba28696e12de","$7221566bd4d49f44$export$aafa59e2e03f2942","$7221566bd4d49f44$export$68d8715fc104d294","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","Object","defineProperty","value","MissingRefError","ValidationError","CodeGen","Name","nil","stringify","str","_","KeywordCxt","$5hxSG","$hHp9H","$81ULr","$BbyF4","META_SUPPORT_DATA","META_SCHEMA_ID","Ajv","default","_addVocabularies","forEach","v","addVocabulary","opts","discriminator","addKeyword","_addDefaultMetaSchema","meta","metaSchema","$data","$dataMetaSchema","addMetaSchema","refs","defaultMeta","getSchema","undefined","$9hgV1","enumerable","get","$l2ufW","$2gvZO","$euTEo","$1sl6b","$jstQR","$9ZpNV","$46MS3","$7eX5i","$83wzf","$FaKkF","$3d88d258a9865bba$var$defaultRegExp","flags","RegExp","$3d88d258a9865bba$var$META_IGNORE_OPTIONS","$3d88d258a9865bba$var$EXT_SCOPE_NAMES","Set","$3d88d258a9865bba$var$removedOptions","errorDataPath","format","nullable","jsonPointers","extendRefs","missingRefs","processCode","sourceCode","strictDefaults","strictKeywords","uniqueItems","unknownFormats","cache","serialize","ajvErrors","$3d88d258a9865bba$var$deprecatedOptions","ignoreKeywordsWithRef","jsPropertySyntax","unicode","$3d88d258a9865bba$var$Ajv","constructor","schemas","formats","_compilations","_loading","_cache","Map","$3d88d258a9865bba$var$requiredOptions","o","_a","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","_s","_t","_u","_v","_w","_x","_y","_z","_0","s","strict","_optz","optimize","regExp","uriResolver","strictSchema","strictNumbers","strictTypes","strictTuples","strictRequired","loopRequired","loopEnum","messages","inlineRefs","schemaId","addUsedSchema","validateSchema","validateFormats","unicodeRegExp","int32range","es5","lines","scope","ValueScope","prefixes","logger","$3d88d258a9865bba$var$getLogger","$3d88d258a9865bba$var$noLogs","console","log","warn","error","formatOpt","RULES","getRules","$3d88d258a9865bba$var$checkOptions","_metaOpts","$3d88d258a9865bba$var$getMetaSchemaOptions","$3d88d258a9865bba$var$addInitialFormats","keywords","$3d88d258a9865bba$var$addInitialKeywords","$3d88d258a9865bba$var$addInitialSchemas","_dataRefSchema","$id","validate","schemaKeyRef","data","compile","valid","errors","schema","_meta","sch","_addSchema","_compileSchemaEnv","compileAsync","loadSchema","runCompileAsync","_schema","loadMetaSchema","$schema","_compileAsync","$ref","e","checkLoaded","loadMissingSchema","missingSchema","ref","missingRef","_loadSchema","addSchema","p","key","_validateSchema","Array","isArray","normalizeId","_checkUnique","throwOrLogError","message","errorsText","keyRef","$3d88d258a9865bba$var$getSchEnv","root","SchemaEnv","resolveSchema","removeSchema","_removeAllSchemas","clear","delete","definitions","def","kwdOrDef","keyword","length","$3d88d258a9865bba$var$checkKeyword","eachItem","kwd","$3d88d258a9865bba$var$addRule","$3d88d258a9865bba$var$keywordMetaschema","definition","type","getJSONTypes","schemaType","k","t","getKeyword","rule","all","removeKeyword","group","rules","i","findIndex","splice","addFormat","name","separator","dataVar","map","instancePath","reduce","text","msg","keywordsJsonPointers","jsonPointer","JSON","parse","segments","split","slice","seg","$3d88d258a9865bba$var$schemaOrData","regex","test","baseId","jtd","localRefs","getSchemaRefs","set","startsWith","_compileMetaSchema","compileSchema","currentOpts","checkOpts","options","optsSchemas","defs","metaOpts","opt","$3d88d258a9865bba$var$KEYWORD_NAME","dataType","post","ruleGroup","find","push","before","$3d88d258a9865bba$var$addBeforeRule","implements","_rule","$3d88d258a9865bba$var$$dataRef","anyOf","getData","validateFunctionCode","$75Cyv","$9KPK3","$9OJAU","$dTewx","$5eunN","$dOpvc","$hYgW9","$6c12d34a75202c62$var$validateFunction","gen","validateName","schemaEnv","body","func","valCxt","$async","$6c12d34a75202c62$var$funcSourceUrl","$6c12d34a75202c62$var$destructureValCxtES5","if","var","parentData","parentDataProperty","rootData","dynamicRef","dynamicAnchors","schId","source","process","$6c12d34a75202c62$var$schemaCxtHasRules","self","$6c12d34a75202c62$var$isSchemaObj","it","$6c12d34a75202c62$var$checkKeywords","checkUnknownRules","$6c12d34a75202c62$var$checkRefsAndKeywords","errSchemaPath","schemaHasRulesButRef","$6c12d34a75202c62$var$typeAndKeywords","errsCount","$6c12d34a75202c62$var$schemaKeywords","types","getSchemaTypes","checkedTypes","coerceAndCheckDataType","$6c12d34a75202c62$var$commentKeyword","$comment","schemaPath","rootName","scopeValue","typeErrors","allErrors","block","$6c12d34a75202c62$var$keywordCode","groupKeywords","shouldUseGroup","checkDataType","$6c12d34a75202c62$var$iterateKeywords","else","reportTypeError","endIf","$6c12d34a75202c62$var$checkContextTypes","dataTypes","$6c12d34a75202c62$var$includesType","$6c12d34a75202c62$var$strictTypesError","join","$6c12d34a75202c62$var$narrowSchemaTypes","withTypes","ts","includes","allowUnionTypes","$6c12d34a75202c62$var$checkKeywordTypes","shouldUseRule","some","schTs","kwdT","useDefaults","assignDefaults","checkStrictMode","$6c12d34a75202c62$var$topSchemaObjCode","$6c12d34a75202c62$var$checkNoDefault","let","vErrors","unevaluated","$6c12d34a75202c62$var$resetEvaluated","evaluated","const","assign","$6c12d34a75202c62$var$returnResults","return","throw","$6c12d34a75202c62$var$assignEvaluated","props","items","topBoolOrEmptySchema","$6c12d34a75202c62$var$KeywordCxt","validateKeywordUsage","schemaValue","schemaRefOrVal","parentSchema","params","schemaCode","$6c12d34a75202c62$var$getData","validSchemaType","allowUndefined","trackErrors","result","condition","successAction","failAction","failResult","not","pass","fail","fail$data","or","invalid$data","append","errorParams","errorPaths","setParams","_error","reportExtraError","reportError","$dataError","keyword$DataError","reset","resetErrorsCount","ok","cond","obj","block$data","codeBlock","$dataValid","check$data","elseIf","wrong$DataType","st","checkDataTypes","DataType","Wrong","invalid$DataSchema","validateSchemaRef","subschema","appl","getSubschema","extendSubschemaData","extendSubschemaMode","nextContext","$6c12d34a75202c62$var$subschemaCode","$6c12d34a75202c62$var$subSchemaObjCode","$6c12d34a75202c62$var$updateContext","resolveUrl","$6c12d34a75202c62$var$checkAsyncSchema","boolOrEmptySchema","mergeEvaluated","schemaCxt","toName","mergeValidEvaluated","ruleType","cxt","funcKeywordCode","macroKeywordCode","$6c12d34a75202c62$var$JSON_POINTER","$6c12d34a75202c62$var$RELATIVE_JSON_POINTER","dataLevel","dataNames","dataPathArr","matches","exec","up","errorMsg","expr","segment","getProperty","unescapeJsonPointer","pointerType","$5296e860644b4914$var$boolError","$5296e860644b4914$var$falseSchemaError","overrideAllErrors","extendErrors","keywordError","$d1552d9220cfb4a2$var$addError","errObj","$d1552d9220cfb4a2$var$returnErrors","errs","compositeRule","$d1552d9220cfb4a2$var$errorObjectCode","forRange","strConcat","errorPath","verbose","$d1552d9220cfb4a2$var$E","propertyName","createErrors","$d1552d9220cfb4a2$var$errorObject","keyValues","$d1552d9220cfb4a2$var$errorInstancePath","instPath","getErrorPath","Type","Str","$d1552d9220cfb4a2$var$errorSchemaPath","schPath","$d1552d9220cfb4a2$var$extraErrorProps","topSchemaRef","object","and","operators","varKinds","ValueScopeName","Scope","regexpCode","$4GpWJ","$eNw2I","GT","_Code","GTE","LT","LTE","EQ","NEQ","NOT","OR","AND","ADD","$f511411e7bf8f284$var$Node","optimizeNodes","optimizeNames","_names","_constants","$f511411e7bf8f284$var$Def","varKind","rhs","render","_n","names","constants","$f511411e7bf8f284$var$optimizeExpr","_CodeOrName","$f511411e7bf8f284$var$Assign","lhs","sideEffects","$f511411e7bf8f284$var$addExprNames","$f511411e7bf8f284$var$AssignOp","op","$f511411e7bf8f284$var$Label","label","$f511411e7bf8f284$var$Break","$f511411e7bf8f284$var$Throw","$f511411e7bf8f284$var$AnyCode","$f511411e7bf8f284$var$ParentNode","nodes","n","$f511411e7bf8f284$var$subtractNames","from","$f511411e7bf8f284$var$addNames","$f511411e7bf8f284$var$BlockNode","$f511411e7bf8f284$var$Root","$f511411e7bf8f284$var$Else","kind","$f511411e7bf8f284$var$If","ns","$f511411e7bf8f284$var$not","$f511411e7bf8f284$var$For","$f511411e7bf8f284$var$ForLoop","iteration","$f511411e7bf8f284$var$ForRange","to","$f511411e7bf8f284$var$ForIter","loop","iterable","$f511411e7bf8f284$var$Func","args","async","_async","$f511411e7bf8f284$var$Return","$f511411e7bf8f284$var$Try","catch","finally","$f511411e7bf8f284$var$Catch","$f511411e7bf8f284$var$Finally","replaceName","_items","c","x","$f511411e7bf8f284$var$par","extScope","_values","_blockStarts","_extScope","_scope","parent","_nodes","toString","_root","prefix","scopeName","prefixOrName","vs","add","getScopeValue","keyOrRef","getValue","scopeRefs","scopeCode","_def","nameOrPrefix","constant","_leafNode","_constant","addCodeArg","thenBody","elseBody","_blockNode","_elseNode","_endBlockNode","_for","node","forBody","endFor","for","forOf","arr","forIn","ownProperties","break","try","tryBody","catchCode","finallyCode","_currNode","nodeCount","endBlock","len","pop","toClose","funcBody","endFunc","N1","N2","$f511411e7bf8f284$var$andCode","$f511411e7bf8f284$var$mappend","$f511411e7bf8f284$var$orCode","y","getEsmExportName","safeStringify","IDENTIFIER","$368f361121c33a9b$var$_CodeOrName","$368f361121c33a9b$var$Name","emptyStr","$368f361121c33a9b$var$_Code","item","_str","$368f361121c33a9b$var$_","strs","$368f361121c33a9b$var$addCodeArg","$368f361121c33a9b$var$plus","$368f361121c33a9b$var$str","$368f361121c33a9b$var$safeStringify","$368f361121c33a9b$var$optimize","b","res","arg","replace","c1","c2","rx","UsedValueState","$ac5e7f513a485aeb$var$UsedValueState","$ac5e7f513a485aeb$var$ValueError","$ac5e7f513a485aeb$var$Scope","_prefixes","_parent","_newName","ng","_nameGroup","index","has","$ac5e7f513a485aeb$var$ValueScopeName","nameStr","setValue","property","itemIndex","scopePath","$ac5e7f513a485aeb$var$line","valueKey","_name","values","_reduceValues","usedValues","getCode","valueCode","nameSet","Started","Completed","useFunc","setEvaluated","evaluatedPropsToName","escapeJsonPointer","escapeFragment","unescapeFragment","schemaHasRules","alwaysValidSchema","toHash","$5457ac2764e63104$var$Type","$5457ac2764e63104$var$checkUnknownRules","$5457ac2764e63104$var$checkStrictMode","$5457ac2764e63104$var$schemaHasRules","$5457ac2764e63104$var$escapeJsonPointer","$5457ac2764e63104$var$unescapeJsonPointer","$5457ac2764e63104$var$makeMergeEvaluated","mergeNames","mergeToName","mergeValues","resultToName","$5457ac2764e63104$var$evaluatedPropsToName","ps","$5457ac2764e63104$var$setEvaluated","keys","hash","decodeURIComponent","encodeURIComponent","xs","f","Math","max","$5457ac2764e63104$var$snippets","mode","dataProp","dataPropType","isNumber","Num","$a0e3ba1039b4828f$var$names","this","json","jsonPos","jsonLen","jsonPart","$2fdda1abbf4dbf9f$var$DataType","$2fdda1abbf4dbf9f$var$getJSONTypes","every","isJSONType","coerceTypes","coerceTo","filter","$2fdda1abbf4dbf9f$var$COERCIBLE","checkTypes","schemaHasRulesForType","wrongType","$2fdda1abbf4dbf9f$var$checkDataTypes","$2fdda1abbf4dbf9f$var$coerceData","coerced","coerceSpecificType","$2fdda1abbf4dbf9f$var$reportTypeError","$2fdda1abbf4dbf9f$var$assignParentData","$2fdda1abbf4dbf9f$var$checkDataType","strictNums","correct","Correct","numCond","_cond","array","notObj","null","number","integer","$2fdda1abbf4dbf9f$var$typeError","$2fdda1abbf4dbf9f$var$getTypeErrorContext","$10f8c5b811d8a69e$var$jsonTypes","groups","string","boolean","$71a08bc6f5a5bab9$var$shouldUseGroup","$71a08bc6f5a5bab9$var$shouldUseRule","$725c26a0727ed10f$var$assignDefault","prop","defaultValue","childData","ty","properties","$7unnO","$a1cbad90d3b10795$var$modifyData","$a1cbad90d3b10795$var$useKeyword","macroSchema","macro","schemaRef","$a1cbad90d3b10795$var$checkAsyncKeyword","validateRef","assignValid","_await","passCxt","passContext","passSchema","callValidateCode","modifying","reportErrs","ruleErrs","validateAsync","validateSync","validateErrs","$a1cbad90d3b10795$var$addErrs","deps","dependencies","prototype","hasOwnProperty","validateUnion","validateArray","usePattern","schemaProperties","allSchemaProperties","noPropertyInData","propertyInData","isOwnProperty","hasPropFunc","reportMissingProp","checkMissingProp","checkReportMissingProp","$573d792233d8638b$var$hasPropFunc","$573d792233d8638b$var$isOwnProperty","$573d792233d8638b$var$noPropertyInData","$573d792233d8638b$var$allSchemaProperties","schemaMap","missingProperty","missing","context","dataAndSchema","$573d792233d8638b$var$newRegExp","pattern","u","validArr","validateItems","notValid","alwaysValid","schValid","_sch","schCxt","schemaProp","dpType","dataContextProps","_nextData","definedProperties","jtdDiscriminator","jtdMetadata","_getFullPath","getFullPath","inlineRef","$7hFx0","$7dBhG","$745dd3bb66238608$var$SIMPLE_INLINED","limit","$745dd3bb66238608$var$hasRef","$745dd3bb66238608$var$REF_KEYWORDS","$745dd3bb66238608$var$countKeys","count","Infinity","$745dd3bb66238608$var$getFullPath","resolver","normalize","$745dd3bb66238608$var$normalizeId","$745dd3bb66238608$var$_getFullPath","serialized","$745dd3bb66238608$var$TRAILING_SLASH_HASH","resolve","$745dd3bb66238608$var$ANCHOR","baseIds","pathPrefix","schemaRefs","allKeys","jsonPtr","parentJsonPtr","fullPath","addRef","_resolve","ambiguos","schOrRef","checkAmbiguosRef","addAnchor","anchor","$anchor","$dynamicAnchor","sch1","sch2","equal","valueOf","$5416ab2f1394f8d9$var$traverse","cb","pre","$5416ab2f1394f8d9$var$_traverse","rootSchema","parentKeyword","keyIndex","arrayKeywords","propsKeywords","skipKeywords","additionalItems","contains","additionalProperties","propertyNames","then","allOf","oneOf","$defs","patternProperties","enum","required","maximum","minimum","exclusiveMaximum","exclusiveMinimum","multipleOf","maxLength","minLength","maxItems","minItems","maxProperties","minProperties","ajv","validation","getCompilingSchema","resolveRef","$e2a7c9c4276e8f03$var$SchemaEnv","env","$e2a7c9c4276e8f03$var$compileSchema","_ValidationError","$e2a7c9c4276e8f03$var$getCompilingSchema","rootId","validateCode","makeValidate","Function","scopeValues","dynamicProps","dynamicItems","$e2a7c9c4276e8f03$var$inlineOrCompile","schEnv","s1","s2","$e2a7c9c4276e8f03$var$resolve","$e2a7c9c4276e8f03$var$resolveSchema","refPath","$e2a7c9c4276e8f03$var$getJsonPointer","schOrFunc","$e2a7c9c4276e8f03$var$PREVENT_SCOPE_CHANGE","parsedRef","fragment","part","partSchema","$2h43S","factory","exports1","merge","_len","arguments","sets","_key","xl","subexp","typeOf","shift","toLowerCase","toUpperCase","buildExps","isIRI","ALPHA$$","DIGIT$$","HEXDIG$$","PCT_ENCODED$","SUB_DELIMS$$","RESERVED$$","IPRIVATE$$","UNRESERVED$$","SCHEME$","USERINFO$","DEC_OCTET_RELAXED$","IPV4ADDRESS$","H16$","LS32$","IPV6ADDRESS1$","IPV6ADDRESS2$","IPV6ADDRESS3$","IPV6ADDRESS4$","IPV6ADDRESS5$","IPV6ADDRESS6$","IPV6ADDRESS7$","IPV6ADDRESS8$","IPV6ADDRESS9$","IPV6ADDRESS$","ZONEID$","IPV6ADDRZ_RELAXED$","IPVFUTURE$","IP_LITERAL$","REG_NAME$","HOST$","PORT$","AUTHORITY$","PCHAR$","SEGMENT$","SEGMENT_NZ$","SEGMENT_NZ_NC$","PATH_ABEMPTY$","PATH_ABSOLUTE$","PATH_NOSCHEME$","PATH_ROOTLESS$","PATH_EMPTY$","QUERY$","FRAGMENT$","HIER_PART$","URI$","RELATIVE_PART$","RELATIVE$","NOT_SCHEME","NOT_USERINFO","NOT_HOST","NOT_PATH","NOT_PATH_NOSCHEME","NOT_QUERY","NOT_FRAGMENT","ESCAPE","UNRESERVED","OTHER_CHARS","PCT_ENCODED","IPV4ADDRESS","IPV6ADDRESS","URI_PROTOCOL","IRI_PROTOCOL","slicedToArray","Symbol","iterator","sliceIterator","_arr","_i","next","done","TypeError","regexPunycode","regexNonASCII","regexSeparators","floor","stringFromCharCode","String","fromCharCode","error$1","RangeError","mapDomain","fn","parts","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","baseMinusTMin","base","decode","input","output","inputLength","bias","basic","lastIndexOf","j","charCodeAt","oldi","w","codePoint","maxInt","baseMinusT","out","fromCodePoint","apply","encode","ucs2decode","counter","extra","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","_currentValue2","basicLength","handledCPCount","m","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","currentValue","handledCPCountPlusOne","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_currentValue","q","qMinusT","punycode","SCHEMES","pctEncChar","chr","pctDecChars","newStr","il","parseInt","substr","c3","_normalizeComponentEncoding","components","protocol","decodeUnreserved","decStr","match","scheme","userinfo","host","path","query","_stripLeadingZeros","_normalizeIPv4","address","_matches","_normalizeIPv6","_matches2","zone","_address$toLowerCase$2","reverse","last","first","firstFields","lastFields","isLastFieldIPv4Address","fieldCount","lastFieldsStart","fields","longestZeroFields","allZeroFields","acc","field","lastLongest","sort","newHost","newFirst","newLast","URI_PARSE","NO_MATCH_IS_UNDEFINED","uriString","iri","reference","port","isNaN","indexOf","schemeHandler","unicodeSupport","domainHost","toASCII","RDS1","RDS2","RDS3","RDS5","removeDotSegments","im","uriTokens","toUnicode","authority","$1","$2","charAt","absolutePath","resolveComponents","relative","skipNormalization","target","tolerant","unescapeComponent","handler","secure","handler$1","isSecure","wsComponents","handler$2","resourceName","_wsComponents$resourc2","handler$3","O","VCHAR$$","NOT_LOCAL_PART","NOT_HFNAME","handler$4","mailtoComponents","unknownHeaders","headers","hfields","hfield","toAddrs","_xl","subject","_x2","_xl2","addr","setInterval","toAddr","atIdx","localPart","domain","URN_PARSE","handler$5","urnComponents","nid","nss","uriComponents","UUID","handler$6","uuidComponents","uuid","baseURI","relativeURI","schemelessOptions","uri","uriA","uriB","escapeComponent","$kt8nB","$9hSw4","$8U9k8","$kLdb8","$koD8T","$ce29f730388cb405$var$draft7Vocabularies","metadataVocabulary","contentVocabulary","$6qsig","$kw3FV","$ee6d041c7fe7d577$var$core","callRef","getValidate","$eef9a5a25da20ed8$var$getValidate","$eef9a5a25da20ed8$var$callRef","addErrorsFrom","addEvaluatedFrom","schEvaluated","callAsyncRef","callRootRef","schOrEnv","callValidate","inlineRefSchema","schName","$3WoId","$bUCRi","$Nqi0g","$9V0CC","$3HmRG","$aQ9E5","$37rVP","$1ObWf","$1jiSd","$6bLKD","$6c2ffd64a2866684$var$validation","$2de9f5322632f65d$var$ops","$2de9f5322632f65d$var$KWDs","okStr","$2de9f5322632f65d$var$def","prec","multipleOfPrecision","invalid","$6BTyZ","$4d014c7f52d4c6e1$var$ucs2length","pos","useLoop","allErrorsMode","loopAllRequired","exitOnErrorMode","requiredKey","$cMsoH","itemTypes","canOptimize","indices","eql","outer","getEql","vSchema","equalCode","$7FQbu","$9llPm","$cNKK7","$a2HBF","$2dY63","$ksuYJ","$bXp0l","$8Wg07","$iBNsK","$eSOrH","$62Mii","$d3kOu","$gC5PA","$fhXQa","$jfpXQ","$5HS6k","draft2020","applicator","validateAdditionalItems","$5964d7729d257dac$var$validateAdditionalItems","validateTuple","$951e51c9b8ab42ca$var$validateTuple","extraItems","schArr","checkStrictTuple","l","fullTuple","prefixItems","min","minContains","maxContains","validateItemsWithCount","_valid","validateSchemaDeps","validatePropertyDeps","depsCount","$ee4e73e135a0dc71$var$def","propDeps","schDeps","$ee4e73e135a0dc71$var$splitDependencies","propertyDeps","schemaDeps","$ee4e73e135a0dc71$var$validatePropertyDeps","$ee4e73e135a0dc71$var$validateSchemaDeps","hasProperty","depProp","additionalProperty","removeAdditional","patProps","deleteAdditional","additionalPropertyCode","applyAdditionalSchema","isAdditional","definedProp","propsSchema","allProps","applyPropertySchema","patterns","alwaysValidPatterns","checkProperties","allowMatchingProperties","validateProperties","pat","validatePatternProperties","checkMatchingProperties","$980bb340f96346f4$var$def","passing","$e0338efb54c30e45$var$hasSchema","ifClause","hasThen","hasElse","validateIf","validateClause","$f1d26b70ddc76007$var$format","$k9lk2","validate$DataFormat","fmts","fDef","fType","invalidFmt","callFormat","validData","validateFormat","formatDef","unknownFormat","unknownMsg","fmtType","fmtRef","getFormat","fmtDef","fmt","validCondition","$6x7md","discrError","tagName","DiscrError","Tag","tag","mapping","validateMapping","getMapping","oneOfMapping","topRequired","hasRequired","tagRequired","propSch","addMappings","addMapping","tagValue","applyTagSchema","Mapping","$ilwRK","$cf76942c31581396$export$bd9e0fcae8e65975","$151113e9b29588b6$export$5ea2dbb44eae89d6","__esModule","validator","$afbb33d5df9729d3$export$bb95c122214a8b29","did","RESOLVER_API_URL","url","response","fetch","method","status","statusText","didDocument","$443fec48b5d8e69c$export$b35af804a0ff5bd0","$2579977b4e52adba$exports","sha384","sha512_256","sha512_224","sha512","SHA512","$bc3a993d7d38a7a0$exports","SHA2","$a0ae23f5901291b4$exports","$a0ae23f5901291b4$var$number","Number","isSafeInteger","$a0ae23f5901291b4$var$bool","$a0ae23f5901291b4$var$bytes","lengths","Uint8Array","$a0ae23f5901291b4$var$hash","create","outputLen","blockLen","$a0ae23f5901291b4$var$exists","instance","checkFinished","destroyed","finished","$a0ae23f5901291b4$var$output","exists","bytes","bool","$29ee4d3171d9809b$exports","randomBytes","wrapXOFConstructorWithOpts","wrapConstructorWithOpts","wrapConstructor","Hash","concatBytes","toBytes","utf8ToBytes","asyncLoop","nextTick","hexToBytes","bytesToHex","isLE","rotr","createView","u32","u8","$a20ad0ecd1be3cb3$exports","$29ee4d3171d9809b$var$isBytes","crypto","buffer","byteOffset","byteLength","Uint32Array","DataView","word","$29ee4d3171d9809b$var$hexes","padStart","hex","$29ee4d3171d9809b$var$asciis","_9","_A","_F","$29ee4d3171d9809b$var$asciiToBase16","char","hl","al","ai","hi","n1","n2","$29ee4d3171d9809b$var$nextTick","$29ee4d3171d9809b$var$asyncLoop","iters","tick","Date","now","diff","$29ee4d3171d9809b$var$utf8ToBytes","TextEncoder","$29ee4d3171d9809b$var$toBytes","arrays","sum","pad","clone","_cloneInto","$29ee4d3171d9809b$var$toStr","defaults","hashCons","hashC","update","digest","tmp","bytesLength","getRandomValues","$bc3a993d7d38a7a0$var$SHA2","padOffset","view","take","dataView","subarray","roundClean","digestInto","fill","$bc3a993d7d38a7a0$var$setBigUint64","setBigUint64","_32n","BigInt","_u32_max","wh","wl","h","setUint32","oview","outLen","state","destroy","$aa71b30d36adb919$exports","add5L","add5H","add4H","add4L","add3H","add3L","rotlBL","rotlBH","rotlSL","rotlSH","rotr32L","rotr32H","rotrBL","rotrBH","rotrSL","rotrSH","shrSL","shrSH","toBig","fromBig","$aa71b30d36adb919$var$U32_MASK64","$aa71b30d36adb919$var$_32n","$aa71b30d36adb919$var$fromBig","le","$aa71b30d36adb919$var$split","lst","Ah","Al","$aa71b30d36adb919$var$toBig","$aa71b30d36adb919$var$shrSH","$aa71b30d36adb919$var$shrSL","$aa71b30d36adb919$var$rotrSH","$aa71b30d36adb919$var$rotrSL","$aa71b30d36adb919$var$rotrBH","$aa71b30d36adb919$var$rotrBL","$aa71b30d36adb919$var$rotr32H","$aa71b30d36adb919$var$rotr32L","$aa71b30d36adb919$var$rotlSH","$aa71b30d36adb919$var$rotlSL","$aa71b30d36adb919$var$rotlBH","$aa71b30d36adb919$var$rotlBL","$aa71b30d36adb919$var$add","Bh","Bl","$aa71b30d36adb919$var$add3L","Cl","$aa71b30d36adb919$var$add3H","low","Ch","$aa71b30d36adb919$var$add4L","Dl","$aa71b30d36adb919$var$add4H","Dh","$aa71b30d36adb919$var$add5L","El","$aa71b30d36adb919$var$add5H","Eh","$2579977b4e52adba$var$SHA512_Kh","$2579977b4e52adba$var$SHA512_Kl","$2579977b4e52adba$var$SHA512_W_H","$2579977b4e52adba$var$SHA512_W_L","$2579977b4e52adba$var$SHA512","Fh","Fl","Gh","Gl","Hh","Hl","offset","getUint32","W15h","W15l","s0h","s0l","W2h","W2l","s1h","s1l","SUMl","SUMh","sigma1h","sigma1l","CHIh","CHIl","T1ll","T1h","T1l","sigma0h","sigma0l","MAJh","MAJl","All","$2579977b4e52adba$var$SHA512_224","$2579977b4e52adba$var$SHA512_256","$2579977b4e52adba$var$SHA384","$510ad3657d73a9d2$exports","sha224","sha256","$510ad3657d73a9d2$var$Chi","$510ad3657d73a9d2$var$Maj","$510ad3657d73a9d2$var$SHA256_K","$510ad3657d73a9d2$var$IV","$510ad3657d73a9d2$var$SHA256_W","$510ad3657d73a9d2$var$SHA256","A","B","C","D","E","F","G","H","W15","W2","s0","T1","T2","sigma0","$510ad3657d73a9d2$var$SHA224","$09057b02a7b5c89d$var$P","$09057b02a7b5c89d$var$N","$09057b02a7b5c89d$export$8ff8607b70325343","d","Gx","Gy","$09057b02a7b5c89d$var$err","$09057b02a7b5c89d$var$str","$09057b02a7b5c89d$var$au8","$09057b02a7b5c89d$var$u8n","$09057b02a7b5c89d$var$toU8","$09057b02a7b5c89d$var$h2b","$09057b02a7b5c89d$var$mod","r","$09057b02a7b5c89d$var$isPoint","$09057b02a7b5c89d$export$c82dbe8d384844da","ex","ey","ez","et","fromAffine","fromHex","normed","$09057b02a7b5c89d$var$b2n_LE","y2","isValid","$09057b02a7b5c89d$var$uvRatio","isXOdd","toAffine","equals","other","X1","Y1","Z1","X2","Y2","Z2","X1Z2","X2Z1","Y1Z2","Y2Z1","is0","$09057b02a7b5c89d$var$I","negate","double","x1y1","X3","Y3","T3","mul","safe","$09057b02a7b5c89d$var$G","$09057b02a7b5c89d$var$wNAF","multiply","scalar","clearCofactor","isSmallOrder","isTorsionFree","z","iz","$09057b02a7b5c89d$var$invert","toRawBytes","$09057b02a7b5c89d$var$n2b_32LE","toHex","$09057b02a7b5c89d$var$b2h","BASE","$09057b02a7b5c89d$var$Gx","ZERO","$09057b02a7b5c89d$var$padh","num","$09057b02a7b5c89d$var$concatB","arrs","md","$09057b02a7b5c89d$var$pow2","power","$09057b02a7b5c89d$var$pow_2_252_3","b2","x2","b4","b5","b10","b20","b40","b80","b160","b240","b250","pow_p_5_8","v3","pow","vx2","root1","root2","useRoot1","useRoot2","noRoot","$09057b02a7b5c89d$var$modL_LE","$09057b02a7b5c89d$var$sha512a","$09057b02a7b5c89d$export$ec2163bf2d3efdc","sha512Async","$09057b02a7b5c89d$var$sha512s","$09057b02a7b5c89d$var$hash2extK","hashed","head","point","pointBytes","$09057b02a7b5c89d$var$getExtendedPublicKeyAsync","priv","$09057b02a7b5c89d$var$getExtendedPublicKey","$09057b02a7b5c89d$export$709eb998bda2edb9","$09057b02a7b5c89d$var$_sign","rBytes","P","R","hashable","finish","$09057b02a7b5c89d$export$c5552dfdbc7cec71","privKey","$09057b02a7b5c89d$var$cr","mod","invert","subtle","sha512Sync","defineProperties","configurable","$09057b02a7b5c89d$var$precompute","points","comp","neg","cnd","mask","shiftBy","off","wbits","off2","abs","cnd1","cnd2","$e445fbc70464835e$var$encodeVarint","$e445fbc70464835e$export$bac36060836195f9","$e445fbc70464835e$export$c4948c4499ef2797","privateKey","$09057b02a7b5c89d$export$eab97d15b1788b8d","publicKey","b64","lens","$eeb0961446aae8e3$var$getLens","validLen","placeHoldersLen","$eeb0961446aae8e3$var$Arr","curByte","$eeb0961446aae8e3$var$revLookup","uint8","extraBytes","len2","$eeb0961446aae8e3$var$encodeChunk","start","end","$eeb0961446aae8e3$var$lookup","$eeb0961446aae8e3$var$code","$eeb0961446aae8e3$var$i","$eeb0961446aae8e3$var$len","mLen","nBytes","eLen","eMax","eBias","nBits","NaN","rt","LN2","$51861dfc7ca9d588$var$customInspectSymbol","$51861dfc7ca9d588$var$createBuffer","buf","setPrototypeOf","$51861dfc7ca9d588$var$Buffer","encodingOrOffset","$51861dfc7ca9d588$var$allocUnsafe","$51861dfc7ca9d588$var$from","$51861dfc7ca9d588$var$fromString","encoding","isEncoding","$51861dfc7ca9d588$var$byteLength","actual","write","ArrayBuffer","isView","$51861dfc7ca9d588$var$fromArrayView","arrayView","$51861dfc7ca9d588$var$isInstance","copy","$51861dfc7ca9d588$var$fromArrayBuffer","$51861dfc7ca9d588$var$fromArrayLike","SharedArrayBuffer","$51861dfc7ca9d588$var$fromObject","isBuffer","$51861dfc7ca9d588$var$checked","toPrimitive","$51861dfc7ca9d588$var$assertSize","size","mustMatch","loweredCase","$51861dfc7ca9d588$var$utf8ToBytes","$51861dfc7ca9d588$var$base64ToBytes","$51861dfc7ca9d588$var$slowToString","$51861dfc7ca9d588$var$hexSlice","$51861dfc7ca9d588$var$hexSliceLookupTable","$51861dfc7ca9d588$var$utf8Slice","$51861dfc7ca9d588$var$asciiSlice","ret","$51861dfc7ca9d588$var$latin1Slice","$51861dfc7ca9d588$var$utf16leSlice","$51861dfc7ca9d588$var$swap","$51861dfc7ca9d588$var$bidirectionalIndexOf","val","dir","$51861dfc7ca9d588$var$arrayIndexOf","indexSize","arrLength","valLength","read","readUInt16BE","foundIndex","found","firstByte","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","$51861dfc7ca9d588$var$decodeCodePointsArray","codePoints","$51861dfc7ca9d588$var$checkOffset","ext","$51861dfc7ca9d588$var$checkInt","$51861dfc7ca9d588$var$wrtBigUInt64LE","$51861dfc7ca9d588$var$checkIntBI","lo","$51861dfc7ca9d588$var$wrtBigUInt64BE","$51861dfc7ca9d588$var$checkIEEE754","$51861dfc7ca9d588$var$writeFloat","littleEndian","noAssert","$51861dfc7ca9d588$var$writeDouble","TYPED_ARRAY_SUPPORT","$51861dfc7ca9d588$var$typedArraySupport","proto","foo","poolSize","alloc","allocUnsafe","allocUnsafeSlow","_isBuffer","compare","concat","list","swap16","swap32","swap64","toLocaleString","inspect","trim","thisStart","thisEnd","thisCopy","targetCopy","isFinite","remaining","$51861dfc7ca9d588$var$hexWrite","strLen","parsed","$51861dfc7ca9d588$var$blitBuffer","$51861dfc7ca9d588$var$asciiToBytes","byteArray","$51861dfc7ca9d588$var$utf16leToBytes","units","toJSON","newBuf","readUintLE","readUIntLE","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readBigUInt64LE","$51861dfc7ca9d588$var$defineBigIntMethod","$51861dfc7ca9d588$var$validateNumber","$51861dfc7ca9d588$var$boundsError","readBigUInt64BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readBigInt64LE","readBigInt64BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","maxBytes","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","$51861dfc7ca9d588$var$errors","$51861dfc7ca9d588$var$E","sym","getMessage","Base","writable","stack","$51861dfc7ca9d588$var$addNumericalSeparator","range","ERR_OUT_OF_RANGE","ERR_INVALID_ARG_TYPE","ERR_BUFFER_OUT_OF_BOUNDS","received","isInteger","$51861dfc7ca9d588$var$INVALID_BASE64_RE","leadSurrogate","$51861dfc7ca9d588$var$base64clean","src","dst","alphabet","table","i16","$51861dfc7ca9d588$var$BufferBigIntNotDefined","$d1b6fbf03b2f6cd0$export$eb2cfd5dac35d0c7","generateProof","metadata","rawMessage","signature","$d1b6fbf03b2f6cd0$require$Buffer","created","toISOString","proofValue","verificationMethod","signProfile","profile","proof","$7ffc1f94643dc7e4$export$2e2bcd8739ae039","randomUUID","bind","$568f4ee4022ba00e$var$rnds8","$1d0137947e8554ce$var$byteToHex","$3fa3ae484854b431$export$2e2bcd8739ae039","rnds","random","rng","$2fa42e15b9a85232$var$profileAPI","baseUrl","getProfile","validateProfile","resp","resolveDID","referenceProfile","storeProfile","getProfiles","$2fa42e15b9a85232$var$validate","document","validateButton","getElementById","addEventListener","profileData","textContent","profileDataText","alert","$2fa42e15b9a85232$var$generateKeys","ppk","$2fa42e15b9a85232$var$resolvers","resolvedDIDResult","didInput","doc","service","serviceEndpoint","$2fa42e15b9a85232$var$reference","resolvedProfileResult","urlInput","$2fa42e15b9a85232$require$Buffer","integrity","$2fa42e15b9a85232$var$downloadKeyListener","downloadKeyButton","blob","Blob","window","URL","createObjectURL","createElement","href","download","click","$2fa42e15b9a85232$var$generateProfile","form","profileResult","event","preventDefault","formData","FormData","signedProfile","signer","$2fa42e15b9a85232$var$getProfiles","profiles","selectElement","option","appendChild","profileId","$2fa42e15b9a85232$var$storeProfile","storeProfileButton","storeProfileResult","$2fa42e15b9a85232$var$setup","urn","mailto","wss","ws","https","http","urnScheme","NOT_HFVALUE","toArray","SOME_DELIMS$$","ATEXT$$","QTEXT$$","_recomposeAuthority","ucs2encode","tMin","tMax","delimiter","initialBias","initialN","basicToDigit","skew","damp","encoded","labels","AUTHORITY_REF$","SAMEDOC_REF$","ABSOLUTE_REF$","RELATIVE_REF$","GENERIC_REF$","ABSOLUTE_URI$","URI_REFERENCE$","PATH$","DEC_OCTET$","UCSCHAR$$","GEN_DELIMS$$","SP$$","DQUOTE$$","CR$","SchemaValidator","ServiceProfileMetadata","ServiceProfile","fetchServiceProfile","createPublicPrivateKey","ProfileSigner","v4","uuidv4","multiHash","ProfileAPI","Promise","profileAPI","generateKeys","resolvers","Buffer","downloadKeyListener","generateProfile","Event","HTMLFormElement","Partial","FormDataEntryValue","metadataKey","setup","JSONSchemaType","profileSchema","serviceEndpointSchema","DIDDocument","Service","DIDResults","ServiceEndpoint","ServiceValidationResult","validateServiceProfiles","results","ed","etc","encodeVarint","hashCode","hashLength","multihash","generateIntegrityValueFromBytes","generateIntegrityValueFromText","utils","randomPrivateKey","getPublicKeyAsync","Proof","sign","verifyServiceProfileProof","sigH","msgk","verify"],"version":3,"file":"index.29124767.js.map"}